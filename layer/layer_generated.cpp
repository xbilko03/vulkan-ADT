#include "layer.hpp"
#include <mutex>
#include <ws2tcpip.h>
#include "layer_generated.h"
#include "vk_layer_table.h"

std::map<void*, VkLayerInstanceDispatchTable> instance_dispatch;
std::map<void*, VkLayerDispatchTable> device_dispatch;
std::mutex global_lock;
typedef std::lock_guard<std::mutex> scoped_lock;
template<typename DispatchableType>
void* GetKey(DispatchableType inst)
{ 
	return *(void**)inst; 
}
void CreateDeviceDispatch(PFN_vkGetDeviceProcAddr gdpa, VkDevice* pDevice) {
VkLayerDispatchTable dispatchTable;
dispatchTable.GetDeviceProcAddr = (PFN_vkGetDeviceProcAddr)gdpa(*pDevice, "vkGetDeviceProcAddr");
dispatchTable.DestroyDevice = (PFN_vkDestroyDevice)gdpa(*pDevice, "vkDestroyDevice");
dispatchTable.GetDeviceQueue = (PFN_vkGetDeviceQueue)gdpa(*pDevice, "vkGetDeviceQueue");
dispatchTable.QueueSubmit = (PFN_vkQueueSubmit)gdpa(*pDevice, "vkQueueSubmit");
dispatchTable.QueueWaitIdle = (PFN_vkQueueWaitIdle)gdpa(*pDevice, "vkQueueWaitIdle");
dispatchTable.DeviceWaitIdle = (PFN_vkDeviceWaitIdle)gdpa(*pDevice, "vkDeviceWaitIdle");
dispatchTable.AllocateMemory = (PFN_vkAllocateMemory)gdpa(*pDevice, "vkAllocateMemory");
dispatchTable.FreeMemory = (PFN_vkFreeMemory)gdpa(*pDevice, "vkFreeMemory");
dispatchTable.MapMemory = (PFN_vkMapMemory)gdpa(*pDevice, "vkMapMemory");
dispatchTable.UnmapMemory = (PFN_vkUnmapMemory)gdpa(*pDevice, "vkUnmapMemory");
dispatchTable.FlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges)gdpa(*pDevice, "vkFlushMappedMemoryRanges");
dispatchTable.InvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges)gdpa(*pDevice, "vkInvalidateMappedMemoryRanges");
dispatchTable.GetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment)gdpa(*pDevice, "vkGetDeviceMemoryCommitment");
dispatchTable.GetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements)gdpa(*pDevice, "vkGetBufferMemoryRequirements");
dispatchTable.BindBufferMemory = (PFN_vkBindBufferMemory)gdpa(*pDevice, "vkBindBufferMemory");
dispatchTable.GetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements)gdpa(*pDevice, "vkGetImageMemoryRequirements");
dispatchTable.BindImageMemory = (PFN_vkBindImageMemory)gdpa(*pDevice, "vkBindImageMemory");
dispatchTable.GetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements)gdpa(*pDevice, "vkGetImageSparseMemoryRequirements");
dispatchTable.QueueBindSparse = (PFN_vkQueueBindSparse)gdpa(*pDevice, "vkQueueBindSparse");
dispatchTable.CreateFence = (PFN_vkCreateFence)gdpa(*pDevice, "vkCreateFence");
dispatchTable.DestroyFence = (PFN_vkDestroyFence)gdpa(*pDevice, "vkDestroyFence");
dispatchTable.ResetFences = (PFN_vkResetFences)gdpa(*pDevice, "vkResetFences");
dispatchTable.GetFenceStatus = (PFN_vkGetFenceStatus)gdpa(*pDevice, "vkGetFenceStatus");
dispatchTable.WaitForFences = (PFN_vkWaitForFences)gdpa(*pDevice, "vkWaitForFences");
dispatchTable.CreateSemaphore = (PFN_vkCreateSemaphore)gdpa(*pDevice, "vkCreateSemaphore");
dispatchTable.DestroySemaphore = (PFN_vkDestroySemaphore)gdpa(*pDevice, "vkDestroySemaphore");
dispatchTable.CreateEvent = (PFN_vkCreateEvent)gdpa(*pDevice, "vkCreateEvent");
dispatchTable.DestroyEvent = (PFN_vkDestroyEvent)gdpa(*pDevice, "vkDestroyEvent");
dispatchTable.GetEventStatus = (PFN_vkGetEventStatus)gdpa(*pDevice, "vkGetEventStatus");
dispatchTable.SetEvent = (PFN_vkSetEvent)gdpa(*pDevice, "vkSetEvent");
dispatchTable.ResetEvent = (PFN_vkResetEvent)gdpa(*pDevice, "vkResetEvent");
dispatchTable.CreateQueryPool = (PFN_vkCreateQueryPool)gdpa(*pDevice, "vkCreateQueryPool");
dispatchTable.DestroyQueryPool = (PFN_vkDestroyQueryPool)gdpa(*pDevice, "vkDestroyQueryPool");
dispatchTable.GetQueryPoolResults = (PFN_vkGetQueryPoolResults)gdpa(*pDevice, "vkGetQueryPoolResults");
dispatchTable.ResetQueryPool = (PFN_vkResetQueryPool)gdpa(*pDevice, "vkResetQueryPool");
dispatchTable.CreateBuffer = (PFN_vkCreateBuffer)gdpa(*pDevice, "vkCreateBuffer");
dispatchTable.DestroyBuffer = (PFN_vkDestroyBuffer)gdpa(*pDevice, "vkDestroyBuffer");
dispatchTable.CreateBufferView = (PFN_vkCreateBufferView)gdpa(*pDevice, "vkCreateBufferView");
dispatchTable.DestroyBufferView = (PFN_vkDestroyBufferView)gdpa(*pDevice, "vkDestroyBufferView");
dispatchTable.CreateImage = (PFN_vkCreateImage)gdpa(*pDevice, "vkCreateImage");
dispatchTable.DestroyImage = (PFN_vkDestroyImage)gdpa(*pDevice, "vkDestroyImage");
dispatchTable.GetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout)gdpa(*pDevice, "vkGetImageSubresourceLayout");
dispatchTable.CreateImageView = (PFN_vkCreateImageView)gdpa(*pDevice, "vkCreateImageView");
dispatchTable.DestroyImageView = (PFN_vkDestroyImageView)gdpa(*pDevice, "vkDestroyImageView");
dispatchTable.CreateShaderModule = (PFN_vkCreateShaderModule)gdpa(*pDevice, "vkCreateShaderModule");
dispatchTable.DestroyShaderModule = (PFN_vkDestroyShaderModule)gdpa(*pDevice, "vkDestroyShaderModule");
dispatchTable.CreatePipelineCache = (PFN_vkCreatePipelineCache)gdpa(*pDevice, "vkCreatePipelineCache");
dispatchTable.DestroyPipelineCache = (PFN_vkDestroyPipelineCache)gdpa(*pDevice, "vkDestroyPipelineCache");
dispatchTable.GetPipelineCacheData = (PFN_vkGetPipelineCacheData)gdpa(*pDevice, "vkGetPipelineCacheData");
dispatchTable.MergePipelineCaches = (PFN_vkMergePipelineCaches)gdpa(*pDevice, "vkMergePipelineCaches");
dispatchTable.CreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines)gdpa(*pDevice, "vkCreateGraphicsPipelines");
dispatchTable.CreateComputePipelines = (PFN_vkCreateComputePipelines)gdpa(*pDevice, "vkCreateComputePipelines");
dispatchTable.GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)gdpa(*pDevice, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
dispatchTable.DestroyPipeline = (PFN_vkDestroyPipeline)gdpa(*pDevice, "vkDestroyPipeline");
dispatchTable.CreatePipelineLayout = (PFN_vkCreatePipelineLayout)gdpa(*pDevice, "vkCreatePipelineLayout");
dispatchTable.DestroyPipelineLayout = (PFN_vkDestroyPipelineLayout)gdpa(*pDevice, "vkDestroyPipelineLayout");
dispatchTable.CreateSampler = (PFN_vkCreateSampler)gdpa(*pDevice, "vkCreateSampler");
dispatchTable.DestroySampler = (PFN_vkDestroySampler)gdpa(*pDevice, "vkDestroySampler");
dispatchTable.CreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout)gdpa(*pDevice, "vkCreateDescriptorSetLayout");
dispatchTable.DestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout)gdpa(*pDevice, "vkDestroyDescriptorSetLayout");
dispatchTable.CreateDescriptorPool = (PFN_vkCreateDescriptorPool)gdpa(*pDevice, "vkCreateDescriptorPool");
dispatchTable.DestroyDescriptorPool = (PFN_vkDestroyDescriptorPool)gdpa(*pDevice, "vkDestroyDescriptorPool");
dispatchTable.ResetDescriptorPool = (PFN_vkResetDescriptorPool)gdpa(*pDevice, "vkResetDescriptorPool");
dispatchTable.AllocateDescriptorSets = (PFN_vkAllocateDescriptorSets)gdpa(*pDevice, "vkAllocateDescriptorSets");
dispatchTable.FreeDescriptorSets = (PFN_vkFreeDescriptorSets)gdpa(*pDevice, "vkFreeDescriptorSets");
dispatchTable.UpdateDescriptorSets = (PFN_vkUpdateDescriptorSets)gdpa(*pDevice, "vkUpdateDescriptorSets");
dispatchTable.CreateFramebuffer = (PFN_vkCreateFramebuffer)gdpa(*pDevice, "vkCreateFramebuffer");
dispatchTable.DestroyFramebuffer = (PFN_vkDestroyFramebuffer)gdpa(*pDevice, "vkDestroyFramebuffer");
dispatchTable.CreateRenderPass = (PFN_vkCreateRenderPass)gdpa(*pDevice, "vkCreateRenderPass");
dispatchTable.DestroyRenderPass = (PFN_vkDestroyRenderPass)gdpa(*pDevice, "vkDestroyRenderPass");
dispatchTable.GetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity)gdpa(*pDevice, "vkGetRenderAreaGranularity");
dispatchTable.GetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR)gdpa(*pDevice, "vkGetRenderingAreaGranularityKHR");
dispatchTable.CreateCommandPool = (PFN_vkCreateCommandPool)gdpa(*pDevice, "vkCreateCommandPool");
dispatchTable.DestroyCommandPool = (PFN_vkDestroyCommandPool)gdpa(*pDevice, "vkDestroyCommandPool");
dispatchTable.ResetCommandPool = (PFN_vkResetCommandPool)gdpa(*pDevice, "vkResetCommandPool");
dispatchTable.AllocateCommandBuffers = (PFN_vkAllocateCommandBuffers)gdpa(*pDevice, "vkAllocateCommandBuffers");
dispatchTable.FreeCommandBuffers = (PFN_vkFreeCommandBuffers)gdpa(*pDevice, "vkFreeCommandBuffers");
dispatchTable.BeginCommandBuffer = (PFN_vkBeginCommandBuffer)gdpa(*pDevice, "vkBeginCommandBuffer");
dispatchTable.EndCommandBuffer = (PFN_vkEndCommandBuffer)gdpa(*pDevice, "vkEndCommandBuffer");
dispatchTable.ResetCommandBuffer = (PFN_vkResetCommandBuffer)gdpa(*pDevice, "vkResetCommandBuffer");
dispatchTable.CmdBindPipeline = (PFN_vkCmdBindPipeline)gdpa(*pDevice, "vkCmdBindPipeline");
dispatchTable.CmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT)gdpa(*pDevice, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
dispatchTable.CmdSetViewport = (PFN_vkCmdSetViewport)gdpa(*pDevice, "vkCmdSetViewport");
dispatchTable.CmdSetScissor = (PFN_vkCmdSetScissor)gdpa(*pDevice, "vkCmdSetScissor");
dispatchTable.CmdSetLineWidth = (PFN_vkCmdSetLineWidth)gdpa(*pDevice, "vkCmdSetLineWidth");
dispatchTable.CmdSetDepthBias = (PFN_vkCmdSetDepthBias)gdpa(*pDevice, "vkCmdSetDepthBias");
dispatchTable.CmdSetBlendConstants = (PFN_vkCmdSetBlendConstants)gdpa(*pDevice, "vkCmdSetBlendConstants");
dispatchTable.CmdSetDepthBounds = (PFN_vkCmdSetDepthBounds)gdpa(*pDevice, "vkCmdSetDepthBounds");
dispatchTable.CmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask)gdpa(*pDevice, "vkCmdSetStencilCompareMask");
dispatchTable.CmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask)gdpa(*pDevice, "vkCmdSetStencilWriteMask");
dispatchTable.CmdSetStencilReference = (PFN_vkCmdSetStencilReference)gdpa(*pDevice, "vkCmdSetStencilReference");
dispatchTable.CmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets)gdpa(*pDevice, "vkCmdBindDescriptorSets");
dispatchTable.CmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer)gdpa(*pDevice, "vkCmdBindIndexBuffer");
dispatchTable.CmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers)gdpa(*pDevice, "vkCmdBindVertexBuffers");
dispatchTable.CmdDraw = (PFN_vkCmdDraw)gdpa(*pDevice, "vkCmdDraw");
dispatchTable.CmdDrawIndexed = (PFN_vkCmdDrawIndexed)gdpa(*pDevice, "vkCmdDrawIndexed");
dispatchTable.CmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT)gdpa(*pDevice, "vkCmdDrawMultiEXT");
dispatchTable.CmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT)gdpa(*pDevice, "vkCmdDrawMultiIndexedEXT");
dispatchTable.CmdDrawIndirect = (PFN_vkCmdDrawIndirect)gdpa(*pDevice, "vkCmdDrawIndirect");
dispatchTable.CmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect)gdpa(*pDevice, "vkCmdDrawIndexedIndirect");
dispatchTable.CmdDispatch = (PFN_vkCmdDispatch)gdpa(*pDevice, "vkCmdDispatch");
dispatchTable.CmdDispatchIndirect = (PFN_vkCmdDispatchIndirect)gdpa(*pDevice, "vkCmdDispatchIndirect");
dispatchTable.CmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI)gdpa(*pDevice, "vkCmdSubpassShadingHUAWEI");
dispatchTable.CmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI)gdpa(*pDevice, "vkCmdDrawClusterHUAWEI");
dispatchTable.CmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI)gdpa(*pDevice, "vkCmdDrawClusterIndirectHUAWEI");
dispatchTable.CmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV)gdpa(*pDevice, "vkCmdUpdatePipelineIndirectBufferNV");
dispatchTable.CmdCopyBuffer = (PFN_vkCmdCopyBuffer)gdpa(*pDevice, "vkCmdCopyBuffer");
dispatchTable.CmdCopyImage = (PFN_vkCmdCopyImage)gdpa(*pDevice, "vkCmdCopyImage");
dispatchTable.CmdBlitImage = (PFN_vkCmdBlitImage)gdpa(*pDevice, "vkCmdBlitImage");
dispatchTable.CmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage)gdpa(*pDevice, "vkCmdCopyBufferToImage");
dispatchTable.CmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer)gdpa(*pDevice, "vkCmdCopyImageToBuffer");
dispatchTable.CmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV)gdpa(*pDevice, "vkCmdCopyMemoryIndirectNV");
dispatchTable.CmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV)gdpa(*pDevice, "vkCmdCopyMemoryToImageIndirectNV");
dispatchTable.CmdUpdateBuffer = (PFN_vkCmdUpdateBuffer)gdpa(*pDevice, "vkCmdUpdateBuffer");
dispatchTable.CmdFillBuffer = (PFN_vkCmdFillBuffer)gdpa(*pDevice, "vkCmdFillBuffer");
dispatchTable.CmdClearColorImage = (PFN_vkCmdClearColorImage)gdpa(*pDevice, "vkCmdClearColorImage");
dispatchTable.CmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage)gdpa(*pDevice, "vkCmdClearDepthStencilImage");
dispatchTable.CmdClearAttachments = (PFN_vkCmdClearAttachments)gdpa(*pDevice, "vkCmdClearAttachments");
dispatchTable.CmdResolveImage = (PFN_vkCmdResolveImage)gdpa(*pDevice, "vkCmdResolveImage");
dispatchTable.CmdSetEvent = (PFN_vkCmdSetEvent)gdpa(*pDevice, "vkCmdSetEvent");
dispatchTable.CmdResetEvent = (PFN_vkCmdResetEvent)gdpa(*pDevice, "vkCmdResetEvent");
dispatchTable.CmdWaitEvents = (PFN_vkCmdWaitEvents)gdpa(*pDevice, "vkCmdWaitEvents");
dispatchTable.CmdPipelineBarrier = (PFN_vkCmdPipelineBarrier)gdpa(*pDevice, "vkCmdPipelineBarrier");
dispatchTable.CmdBeginQuery = (PFN_vkCmdBeginQuery)gdpa(*pDevice, "vkCmdBeginQuery");
dispatchTable.CmdEndQuery = (PFN_vkCmdEndQuery)gdpa(*pDevice, "vkCmdEndQuery");
dispatchTable.CmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT)gdpa(*pDevice, "vkCmdBeginConditionalRenderingEXT");
dispatchTable.CmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT)gdpa(*pDevice, "vkCmdEndConditionalRenderingEXT");
dispatchTable.CmdResetQueryPool = (PFN_vkCmdResetQueryPool)gdpa(*pDevice, "vkCmdResetQueryPool");
dispatchTable.CmdWriteTimestamp = (PFN_vkCmdWriteTimestamp)gdpa(*pDevice, "vkCmdWriteTimestamp");
dispatchTable.CmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults)gdpa(*pDevice, "vkCmdCopyQueryPoolResults");
dispatchTable.CmdPushConstants = (PFN_vkCmdPushConstants)gdpa(*pDevice, "vkCmdPushConstants");
dispatchTable.CmdBeginRenderPass = (PFN_vkCmdBeginRenderPass)gdpa(*pDevice, "vkCmdBeginRenderPass");
dispatchTable.CmdNextSubpass = (PFN_vkCmdNextSubpass)gdpa(*pDevice, "vkCmdNextSubpass");
dispatchTable.CmdEndRenderPass = (PFN_vkCmdEndRenderPass)gdpa(*pDevice, "vkCmdEndRenderPass");
dispatchTable.CmdExecuteCommands = (PFN_vkCmdExecuteCommands)gdpa(*pDevice, "vkCmdExecuteCommands");
dispatchTable.CreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR)gdpa(*pDevice, "vkCreateSharedSwapchainsKHR");
dispatchTable.CreateSwapchainKHR = (PFN_vkCreateSwapchainKHR)gdpa(*pDevice, "vkCreateSwapchainKHR");
dispatchTable.DestroySwapchainKHR = (PFN_vkDestroySwapchainKHR)gdpa(*pDevice, "vkDestroySwapchainKHR");
dispatchTable.GetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR)gdpa(*pDevice, "vkGetSwapchainImagesKHR");
dispatchTable.AcquireNextImageKHR = (PFN_vkAcquireNextImageKHR)gdpa(*pDevice, "vkAcquireNextImageKHR");
dispatchTable.QueuePresentKHR = (PFN_vkQueuePresentKHR)gdpa(*pDevice, "vkQueuePresentKHR");
dispatchTable.DebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)gdpa(*pDevice, "vkDebugMarkerSetObjectNameEXT");
dispatchTable.DebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT)gdpa(*pDevice, "vkDebugMarkerSetObjectTagEXT");
dispatchTable.CmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)gdpa(*pDevice, "vkCmdDebugMarkerBeginEXT");
dispatchTable.CmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)gdpa(*pDevice, "vkCmdDebugMarkerEndEXT");
dispatchTable.CmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)gdpa(*pDevice, "vkCmdDebugMarkerInsertEXT");
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV)gdpa(*pDevice, "vkGetMemoryWin32HandleNV");
#endif
dispatchTable.CmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV)gdpa(*pDevice, "vkCmdExecuteGeneratedCommandsNV");
dispatchTable.CmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV)gdpa(*pDevice, "vkCmdPreprocessGeneratedCommandsNV");
dispatchTable.CmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV)gdpa(*pDevice, "vkCmdBindPipelineShaderGroupNV");
dispatchTable.GetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV)gdpa(*pDevice, "vkGetGeneratedCommandsMemoryRequirementsNV");
dispatchTable.CreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV)gdpa(*pDevice, "vkCreateIndirectCommandsLayoutNV");
dispatchTable.DestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV)gdpa(*pDevice, "vkDestroyIndirectCommandsLayoutNV");
dispatchTable.CmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR)gdpa(*pDevice, "vkCmdPushDescriptorSetKHR");
dispatchTable.TrimCommandPool = (PFN_vkTrimCommandPool)gdpa(*pDevice, "vkTrimCommandPool");
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR)gdpa(*pDevice, "vkGetMemoryWin32HandleKHR");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR)gdpa(*pDevice, "vkGetMemoryWin32HandlePropertiesKHR");
#endif
dispatchTable.GetMemoryFdKHR = (PFN_vkGetMemoryFdKHR)gdpa(*pDevice, "vkGetMemoryFdKHR");
dispatchTable.GetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR)gdpa(*pDevice, "vkGetMemoryFdPropertiesKHR");
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.GetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA)gdpa(*pDevice, "vkGetMemoryZirconHandleFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.GetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA)gdpa(*pDevice, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
#endif
dispatchTable.GetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV)gdpa(*pDevice, "vkGetMemoryRemoteAddressNV");
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetMemorySciBufNV = (PFN_vkGetMemorySciBufNV)gdpa(*pDevice, "vkGetMemorySciBufNV");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR)gdpa(*pDevice, "vkGetSemaphoreWin32HandleKHR");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.ImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR)gdpa(*pDevice, "vkImportSemaphoreWin32HandleKHR");
#endif
dispatchTable.GetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR)gdpa(*pDevice, "vkGetSemaphoreFdKHR");
dispatchTable.ImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR)gdpa(*pDevice, "vkImportSemaphoreFdKHR");
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.GetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA)gdpa(*pDevice, "vkGetSemaphoreZirconHandleFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.ImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA)gdpa(*pDevice, "vkImportSemaphoreZirconHandleFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR)gdpa(*pDevice, "vkGetFenceWin32HandleKHR");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.ImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR)gdpa(*pDevice, "vkImportFenceWin32HandleKHR");
#endif
dispatchTable.GetFenceFdKHR = (PFN_vkGetFenceFdKHR)gdpa(*pDevice, "vkGetFenceFdKHR");
dispatchTable.ImportFenceFdKHR = (PFN_vkImportFenceFdKHR)gdpa(*pDevice, "vkImportFenceFdKHR");
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetFenceSciSyncFenceNV = (PFN_vkGetFenceSciSyncFenceNV)gdpa(*pDevice, "vkGetFenceSciSyncFenceNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetFenceSciSyncObjNV = (PFN_vkGetFenceSciSyncObjNV)gdpa(*pDevice, "vkGetFenceSciSyncObjNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.ImportFenceSciSyncFenceNV = (PFN_vkImportFenceSciSyncFenceNV)gdpa(*pDevice, "vkImportFenceSciSyncFenceNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.ImportFenceSciSyncObjNV = (PFN_vkImportFenceSciSyncObjNV)gdpa(*pDevice, "vkImportFenceSciSyncObjNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetSemaphoreSciSyncObjNV = (PFN_vkGetSemaphoreSciSyncObjNV)gdpa(*pDevice, "vkGetSemaphoreSciSyncObjNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.ImportSemaphoreSciSyncObjNV = (PFN_vkImportSemaphoreSciSyncObjNV)gdpa(*pDevice, "vkImportSemaphoreSciSyncObjNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.CreateSemaphoreSciSyncPoolNV = (PFN_vkCreateSemaphoreSciSyncPoolNV)gdpa(*pDevice, "vkCreateSemaphoreSciSyncPoolNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.DestroySemaphoreSciSyncPoolNV = (PFN_vkDestroySemaphoreSciSyncPoolNV)gdpa(*pDevice, "vkDestroySemaphoreSciSyncPoolNV");
#endif
dispatchTable.DisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT)gdpa(*pDevice, "vkDisplayPowerControlEXT");
dispatchTable.RegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT)gdpa(*pDevice, "vkRegisterDeviceEventEXT");
dispatchTable.RegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT)gdpa(*pDevice, "vkRegisterDisplayEventEXT");
dispatchTable.GetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT)gdpa(*pDevice, "vkGetSwapchainCounterEXT");
dispatchTable.GetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures)gdpa(*pDevice, "vkGetDeviceGroupPeerMemoryFeatures");
dispatchTable.BindBufferMemory2 = (PFN_vkBindBufferMemory2)gdpa(*pDevice, "vkBindBufferMemory2");
dispatchTable.BindImageMemory2 = (PFN_vkBindImageMemory2)gdpa(*pDevice, "vkBindImageMemory2");
dispatchTable.CmdSetDeviceMask = (PFN_vkCmdSetDeviceMask)gdpa(*pDevice, "vkCmdSetDeviceMask");
dispatchTable.GetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR)gdpa(*pDevice, "vkGetDeviceGroupPresentCapabilitiesKHR");
dispatchTable.GetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR)gdpa(*pDevice, "vkGetDeviceGroupSurfacePresentModesKHR");
dispatchTable.AcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR)gdpa(*pDevice, "vkAcquireNextImage2KHR");
dispatchTable.CmdDispatchBase = (PFN_vkCmdDispatchBase)gdpa(*pDevice, "vkCmdDispatchBase");
dispatchTable.CreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate)gdpa(*pDevice, "vkCreateDescriptorUpdateTemplate");
dispatchTable.DestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate)gdpa(*pDevice, "vkDestroyDescriptorUpdateTemplate");
dispatchTable.UpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate)gdpa(*pDevice, "vkUpdateDescriptorSetWithTemplate");
dispatchTable.CmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR)gdpa(*pDevice, "vkCmdPushDescriptorSetWithTemplateKHR");
dispatchTable.SetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT)gdpa(*pDevice, "vkSetHdrMetadataEXT");
dispatchTable.GetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR)gdpa(*pDevice, "vkGetSwapchainStatusKHR");
dispatchTable.GetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE)gdpa(*pDevice, "vkGetRefreshCycleDurationGOOGLE");
dispatchTable.GetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE)gdpa(*pDevice, "vkGetPastPresentationTimingGOOGLE");
dispatchTable.CmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV)gdpa(*pDevice, "vkCmdSetViewportWScalingNV");
dispatchTable.CmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT)gdpa(*pDevice, "vkCmdSetDiscardRectangleEXT");
dispatchTable.CmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT)gdpa(*pDevice, "vkCmdSetDiscardRectangleEnableEXT");
dispatchTable.CmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT)gdpa(*pDevice, "vkCmdSetDiscardRectangleModeEXT");
dispatchTable.CmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT)gdpa(*pDevice, "vkCmdSetSampleLocationsEXT");
dispatchTable.GetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2)gdpa(*pDevice, "vkGetBufferMemoryRequirements2");
dispatchTable.GetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2)gdpa(*pDevice, "vkGetImageMemoryRequirements2");
dispatchTable.GetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2)gdpa(*pDevice, "vkGetImageSparseMemoryRequirements2");
dispatchTable.GetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements)gdpa(*pDevice, "vkGetDeviceBufferMemoryRequirements");
dispatchTable.GetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements)gdpa(*pDevice, "vkGetDeviceImageMemoryRequirements");
dispatchTable.GetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements)gdpa(*pDevice, "vkGetDeviceImageSparseMemoryRequirements");
dispatchTable.CreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion)gdpa(*pDevice, "vkCreateSamplerYcbcrConversion");
dispatchTable.DestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion)gdpa(*pDevice, "vkDestroySamplerYcbcrConversion");
dispatchTable.GetDeviceQueue2 = (PFN_vkGetDeviceQueue2)gdpa(*pDevice, "vkGetDeviceQueue2");
dispatchTable.CreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT)gdpa(*pDevice, "vkCreateValidationCacheEXT");
dispatchTable.DestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT)gdpa(*pDevice, "vkDestroyValidationCacheEXT");
dispatchTable.GetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT)gdpa(*pDevice, "vkGetValidationCacheDataEXT");
dispatchTable.MergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT)gdpa(*pDevice, "vkMergeValidationCachesEXT");
dispatchTable.GetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport)gdpa(*pDevice, "vkGetDescriptorSetLayoutSupport");
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.GetSwapchainGrallocUsageANDROID = (PFN_vkGetSwapchainGrallocUsageANDROID)gdpa(*pDevice, "vkGetSwapchainGrallocUsageANDROID");
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.GetSwapchainGrallocUsage2ANDROID = (PFN_vkGetSwapchainGrallocUsage2ANDROID)gdpa(*pDevice, "vkGetSwapchainGrallocUsage2ANDROID");
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.AcquireImageANDROID = (PFN_vkAcquireImageANDROID)gdpa(*pDevice, "vkAcquireImageANDROID");
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.QueueSignalReleaseImageANDROID = (PFN_vkQueueSignalReleaseImageANDROID)gdpa(*pDevice, "vkQueueSignalReleaseImageANDROID");
#endif
dispatchTable.GetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)gdpa(*pDevice, "vkGetShaderInfoAMD");
dispatchTable.SetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD)gdpa(*pDevice, "vkSetLocalDimmingAMD");
dispatchTable.GetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR)gdpa(*pDevice, "vkGetCalibratedTimestampsKHR");
dispatchTable.SetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT)gdpa(*pDevice, "vkSetDebugUtilsObjectNameEXT");
dispatchTable.SetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT)gdpa(*pDevice, "vkSetDebugUtilsObjectTagEXT");
dispatchTable.QueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT)gdpa(*pDevice, "vkQueueBeginDebugUtilsLabelEXT");
dispatchTable.QueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT)gdpa(*pDevice, "vkQueueEndDebugUtilsLabelEXT");
dispatchTable.QueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT)gdpa(*pDevice, "vkQueueInsertDebugUtilsLabelEXT");
dispatchTable.CmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)gdpa(*pDevice, "vkCmdBeginDebugUtilsLabelEXT");
dispatchTable.CmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)gdpa(*pDevice, "vkCmdEndDebugUtilsLabelEXT");
dispatchTable.CmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT)gdpa(*pDevice, "vkCmdInsertDebugUtilsLabelEXT");
dispatchTable.GetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT)gdpa(*pDevice, "vkGetMemoryHostPointerPropertiesEXT");
dispatchTable.CmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD)gdpa(*pDevice, "vkCmdWriteBufferMarkerAMD");
dispatchTable.CreateRenderPass2 = (PFN_vkCreateRenderPass2)gdpa(*pDevice, "vkCreateRenderPass2");
dispatchTable.CmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2)gdpa(*pDevice, "vkCmdBeginRenderPass2");
dispatchTable.CmdNextSubpass2 = (PFN_vkCmdNextSubpass2)gdpa(*pDevice, "vkCmdNextSubpass2");
dispatchTable.CmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2)gdpa(*pDevice, "vkCmdEndRenderPass2");
dispatchTable.GetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue)gdpa(*pDevice, "vkGetSemaphoreCounterValue");
dispatchTable.WaitSemaphores = (PFN_vkWaitSemaphores)gdpa(*pDevice, "vkWaitSemaphores");
dispatchTable.SignalSemaphore = (PFN_vkSignalSemaphore)gdpa(*pDevice, "vkSignalSemaphore");
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.GetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID)gdpa(*pDevice, "vkGetAndroidHardwareBufferPropertiesANDROID");
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.GetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID)gdpa(*pDevice, "vkGetMemoryAndroidHardwareBufferANDROID");
#endif
dispatchTable.CmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount)gdpa(*pDevice, "vkCmdDrawIndirectCount");
dispatchTable.CmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount)gdpa(*pDevice, "vkCmdDrawIndexedIndirectCount");
dispatchTable.CmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV)gdpa(*pDevice, "vkCmdSetCheckpointNV");
dispatchTable.GetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV)gdpa(*pDevice, "vkGetQueueCheckpointDataNV");
dispatchTable.CmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT)gdpa(*pDevice, "vkCmdBindTransformFeedbackBuffersEXT");
dispatchTable.CmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT)gdpa(*pDevice, "vkCmdBeginTransformFeedbackEXT");
dispatchTable.CmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT)gdpa(*pDevice, "vkCmdEndTransformFeedbackEXT");
dispatchTable.CmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT)gdpa(*pDevice, "vkCmdBeginQueryIndexedEXT");
dispatchTable.CmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT)gdpa(*pDevice, "vkCmdEndQueryIndexedEXT");
dispatchTable.CmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT)gdpa(*pDevice, "vkCmdDrawIndirectByteCountEXT");
dispatchTable.CmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV)gdpa(*pDevice, "vkCmdSetExclusiveScissorNV");
dispatchTable.CmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV)gdpa(*pDevice, "vkCmdSetExclusiveScissorEnableNV");
dispatchTable.CmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV)gdpa(*pDevice, "vkCmdBindShadingRateImageNV");
dispatchTable.CmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV)gdpa(*pDevice, "vkCmdSetViewportShadingRatePaletteNV");
dispatchTable.CmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV)gdpa(*pDevice, "vkCmdSetCoarseSampleOrderNV");
dispatchTable.CmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV)gdpa(*pDevice, "vkCmdDrawMeshTasksNV");
dispatchTable.CmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV)gdpa(*pDevice, "vkCmdDrawMeshTasksIndirectNV");
dispatchTable.CmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV)gdpa(*pDevice, "vkCmdDrawMeshTasksIndirectCountNV");
dispatchTable.CmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT)gdpa(*pDevice, "vkCmdDrawMeshTasksEXT");
dispatchTable.CmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT)gdpa(*pDevice, "vkCmdDrawMeshTasksIndirectEXT");
dispatchTable.CmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT)gdpa(*pDevice, "vkCmdDrawMeshTasksIndirectCountEXT");
dispatchTable.CompileDeferredNV = (PFN_vkCompileDeferredNV)gdpa(*pDevice, "vkCompileDeferredNV");
dispatchTable.CreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV)gdpa(*pDevice, "vkCreateAccelerationStructureNV");
dispatchTable.CmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI)gdpa(*pDevice, "vkCmdBindInvocationMaskHUAWEI");
dispatchTable.DestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR)gdpa(*pDevice, "vkDestroyAccelerationStructureKHR");
dispatchTable.DestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV)gdpa(*pDevice, "vkDestroyAccelerationStructureNV");
dispatchTable.GetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV)gdpa(*pDevice, "vkGetAccelerationStructureMemoryRequirementsNV");
dispatchTable.BindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV)gdpa(*pDevice, "vkBindAccelerationStructureMemoryNV");
dispatchTable.CmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV)gdpa(*pDevice, "vkCmdCopyAccelerationStructureNV");
dispatchTable.CmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR)gdpa(*pDevice, "vkCmdCopyAccelerationStructureKHR");
dispatchTable.CopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR)gdpa(*pDevice, "vkCopyAccelerationStructureKHR");
dispatchTable.CmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR)gdpa(*pDevice, "vkCmdCopyAccelerationStructureToMemoryKHR");
dispatchTable.CopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR)gdpa(*pDevice, "vkCopyAccelerationStructureToMemoryKHR");
dispatchTable.CmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR)gdpa(*pDevice, "vkCmdCopyMemoryToAccelerationStructureKHR");
dispatchTable.CopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR)gdpa(*pDevice, "vkCopyMemoryToAccelerationStructureKHR");
dispatchTable.CmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR)gdpa(*pDevice, "vkCmdWriteAccelerationStructuresPropertiesKHR");
dispatchTable.CmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV)gdpa(*pDevice, "vkCmdWriteAccelerationStructuresPropertiesNV");
dispatchTable.CmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV)gdpa(*pDevice, "vkCmdBuildAccelerationStructureNV");
dispatchTable.WriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR)gdpa(*pDevice, "vkWriteAccelerationStructuresPropertiesKHR");
dispatchTable.CmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR)gdpa(*pDevice, "vkCmdTraceRaysKHR");
dispatchTable.CmdTraceRaysNV = (PFN_vkCmdTraceRaysNV)gdpa(*pDevice, "vkCmdTraceRaysNV");
dispatchTable.GetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR)gdpa(*pDevice, "vkGetRayTracingShaderGroupHandlesKHR");
dispatchTable.GetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)gdpa(*pDevice, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
dispatchTable.GetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV)gdpa(*pDevice, "vkGetAccelerationStructureHandleNV");
dispatchTable.CreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV)gdpa(*pDevice, "vkCreateRayTracingPipelinesNV");
dispatchTable.CreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR)gdpa(*pDevice, "vkCreateRayTracingPipelinesKHR");
dispatchTable.CmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR)gdpa(*pDevice, "vkCmdTraceRaysIndirectKHR");
dispatchTable.CmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR)gdpa(*pDevice, "vkCmdTraceRaysIndirect2KHR");
dispatchTable.GetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR)gdpa(*pDevice, "vkGetDeviceAccelerationStructureCompatibilityKHR");
dispatchTable.GetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR)gdpa(*pDevice, "vkGetRayTracingShaderGroupStackSizeKHR");
dispatchTable.CmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR)gdpa(*pDevice, "vkCmdSetRayTracingPipelineStackSizeKHR");
dispatchTable.GetImageViewHandleNVX = (PFN_vkGetImageViewHandleNVX)gdpa(*pDevice, "vkGetImageViewHandleNVX");
dispatchTable.GetImageViewAddressNVX = (PFN_vkGetImageViewAddressNVX)gdpa(*pDevice, "vkGetImageViewAddressNVX");
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT)gdpa(*pDevice, "vkGetDeviceGroupSurfacePresentModes2EXT");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.AcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT)gdpa(*pDevice, "vkAcquireFullScreenExclusiveModeEXT");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.ReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT)gdpa(*pDevice, "vkReleaseFullScreenExclusiveModeEXT");
#endif
dispatchTable.AcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR)gdpa(*pDevice, "vkAcquireProfilingLockKHR");
dispatchTable.ReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR)gdpa(*pDevice, "vkReleaseProfilingLockKHR");
dispatchTable.GetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT)gdpa(*pDevice, "vkGetImageDrmFormatModifierPropertiesEXT");
dispatchTable.GetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress)gdpa(*pDevice, "vkGetBufferOpaqueCaptureAddress");
dispatchTable.GetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress)gdpa(*pDevice, "vkGetBufferDeviceAddress");
dispatchTable.InitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL)gdpa(*pDevice, "vkInitializePerformanceApiINTEL");
dispatchTable.UninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL)gdpa(*pDevice, "vkUninitializePerformanceApiINTEL");
dispatchTable.CmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL)gdpa(*pDevice, "vkCmdSetPerformanceMarkerINTEL");
dispatchTable.CmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL)gdpa(*pDevice, "vkCmdSetPerformanceStreamMarkerINTEL");
dispatchTable.CmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL)gdpa(*pDevice, "vkCmdSetPerformanceOverrideINTEL");
dispatchTable.AcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL)gdpa(*pDevice, "vkAcquirePerformanceConfigurationINTEL");
dispatchTable.ReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL)gdpa(*pDevice, "vkReleasePerformanceConfigurationINTEL");
dispatchTable.QueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL)gdpa(*pDevice, "vkQueueSetPerformanceConfigurationINTEL");
dispatchTable.GetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL)gdpa(*pDevice, "vkGetPerformanceParameterINTEL");
dispatchTable.GetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress)gdpa(*pDevice, "vkGetDeviceMemoryOpaqueCaptureAddress");
dispatchTable.GetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR)gdpa(*pDevice, "vkGetPipelineExecutablePropertiesKHR");
dispatchTable.GetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR)gdpa(*pDevice, "vkGetPipelineExecutableStatisticsKHR");
dispatchTable.GetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR)gdpa(*pDevice, "vkGetPipelineExecutableInternalRepresentationsKHR");
dispatchTable.CreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR)gdpa(*pDevice, "vkCreateAccelerationStructureKHR");
dispatchTable.CmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR)gdpa(*pDevice, "vkCmdBuildAccelerationStructuresKHR");
dispatchTable.CmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR)gdpa(*pDevice, "vkCmdBuildAccelerationStructuresIndirectKHR");
dispatchTable.BuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR)gdpa(*pDevice, "vkBuildAccelerationStructuresKHR");
dispatchTable.GetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR)gdpa(*pDevice, "vkGetAccelerationStructureDeviceAddressKHR");
dispatchTable.CreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR)gdpa(*pDevice, "vkCreateDeferredOperationKHR");
dispatchTable.DestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR)gdpa(*pDevice, "vkDestroyDeferredOperationKHR");
dispatchTable.GetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR)gdpa(*pDevice, "vkGetDeferredOperationMaxConcurrencyKHR");
dispatchTable.GetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR)gdpa(*pDevice, "vkGetDeferredOperationResultKHR");
dispatchTable.DeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR)gdpa(*pDevice, "vkDeferredOperationJoinKHR");
dispatchTable.GetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV)gdpa(*pDevice, "vkGetPipelineIndirectMemoryRequirementsNV");
dispatchTable.GetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV)gdpa(*pDevice, "vkGetPipelineIndirectDeviceAddressNV");
dispatchTable.CmdSetCullMode = (PFN_vkCmdSetCullMode)gdpa(*pDevice, "vkCmdSetCullMode");
dispatchTable.CmdSetFrontFace = (PFN_vkCmdSetFrontFace)gdpa(*pDevice, "vkCmdSetFrontFace");
dispatchTable.CmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology)gdpa(*pDevice, "vkCmdSetPrimitiveTopology");
dispatchTable.CmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount)gdpa(*pDevice, "vkCmdSetViewportWithCount");
dispatchTable.CmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount)gdpa(*pDevice, "vkCmdSetScissorWithCount");
dispatchTable.CmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR)gdpa(*pDevice, "vkCmdBindIndexBuffer2KHR");
dispatchTable.CmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2)gdpa(*pDevice, "vkCmdBindVertexBuffers2");
dispatchTable.CmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable)gdpa(*pDevice, "vkCmdSetDepthTestEnable");
dispatchTable.CmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable)gdpa(*pDevice, "vkCmdSetDepthWriteEnable");
dispatchTable.CmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp)gdpa(*pDevice, "vkCmdSetDepthCompareOp");
dispatchTable.CmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable)gdpa(*pDevice, "vkCmdSetDepthBoundsTestEnable");
dispatchTable.CmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable)gdpa(*pDevice, "vkCmdSetStencilTestEnable");
dispatchTable.CmdSetStencilOp = (PFN_vkCmdSetStencilOp)gdpa(*pDevice, "vkCmdSetStencilOp");
dispatchTable.CmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT)gdpa(*pDevice, "vkCmdSetPatchControlPointsEXT");
dispatchTable.CmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable)gdpa(*pDevice, "vkCmdSetRasterizerDiscardEnable");
dispatchTable.CmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable)gdpa(*pDevice, "vkCmdSetDepthBiasEnable");
dispatchTable.CmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT)gdpa(*pDevice, "vkCmdSetLogicOpEXT");
dispatchTable.CmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable)gdpa(*pDevice, "vkCmdSetPrimitiveRestartEnable");
dispatchTable.CmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT)gdpa(*pDevice, "vkCmdSetTessellationDomainOriginEXT");
dispatchTable.CmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT)gdpa(*pDevice, "vkCmdSetDepthClampEnableEXT");
dispatchTable.CmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT)gdpa(*pDevice, "vkCmdSetPolygonModeEXT");
dispatchTable.CmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT)gdpa(*pDevice, "vkCmdSetRasterizationSamplesEXT");
dispatchTable.CmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT)gdpa(*pDevice, "vkCmdSetSampleMaskEXT");
dispatchTable.CmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT)gdpa(*pDevice, "vkCmdSetAlphaToCoverageEnableEXT");
dispatchTable.CmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT)gdpa(*pDevice, "vkCmdSetAlphaToOneEnableEXT");
dispatchTable.CmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT)gdpa(*pDevice, "vkCmdSetLogicOpEnableEXT");
dispatchTable.CmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT)gdpa(*pDevice, "vkCmdSetColorBlendEnableEXT");
dispatchTable.CmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT)gdpa(*pDevice, "vkCmdSetColorBlendEquationEXT");
dispatchTable.CmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT)gdpa(*pDevice, "vkCmdSetColorWriteMaskEXT");
dispatchTable.CmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT)gdpa(*pDevice, "vkCmdSetRasterizationStreamEXT");
dispatchTable.CmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT)gdpa(*pDevice, "vkCmdSetConservativeRasterizationModeEXT");
dispatchTable.CmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT)gdpa(*pDevice, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
dispatchTable.CmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT)gdpa(*pDevice, "vkCmdSetDepthClipEnableEXT");
dispatchTable.CmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT)gdpa(*pDevice, "vkCmdSetSampleLocationsEnableEXT");
dispatchTable.CmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT)gdpa(*pDevice, "vkCmdSetColorBlendAdvancedEXT");
dispatchTable.CmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT)gdpa(*pDevice, "vkCmdSetProvokingVertexModeEXT");
dispatchTable.CmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT)gdpa(*pDevice, "vkCmdSetLineRasterizationModeEXT");
dispatchTable.CmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT)gdpa(*pDevice, "vkCmdSetLineStippleEnableEXT");
dispatchTable.CmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT)gdpa(*pDevice, "vkCmdSetDepthClipNegativeOneToOneEXT");
dispatchTable.CmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV)gdpa(*pDevice, "vkCmdSetViewportWScalingEnableNV");
dispatchTable.CmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV)gdpa(*pDevice, "vkCmdSetViewportSwizzleNV");
dispatchTable.CmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV)gdpa(*pDevice, "vkCmdSetCoverageToColorEnableNV");
dispatchTable.CmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV)gdpa(*pDevice, "vkCmdSetCoverageToColorLocationNV");
dispatchTable.CmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV)gdpa(*pDevice, "vkCmdSetCoverageModulationModeNV");
dispatchTable.CmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV)gdpa(*pDevice, "vkCmdSetCoverageModulationTableEnableNV");
dispatchTable.CmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV)gdpa(*pDevice, "vkCmdSetCoverageModulationTableNV");
dispatchTable.CmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV)gdpa(*pDevice, "vkCmdSetShadingRateImageEnableNV");
dispatchTable.CmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV)gdpa(*pDevice, "vkCmdSetCoverageReductionModeNV");
dispatchTable.CmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV)gdpa(*pDevice, "vkCmdSetRepresentativeFragmentTestEnableNV");
dispatchTable.CreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot)gdpa(*pDevice, "vkCreatePrivateDataSlot");
dispatchTable.DestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot)gdpa(*pDevice, "vkDestroyPrivateDataSlot");
dispatchTable.SetPrivateData = (PFN_vkSetPrivateData)gdpa(*pDevice, "vkSetPrivateData");
dispatchTable.GetPrivateData = (PFN_vkGetPrivateData)gdpa(*pDevice, "vkGetPrivateData");
dispatchTable.CmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2)gdpa(*pDevice, "vkCmdCopyBuffer2");
dispatchTable.CmdCopyImage2 = (PFN_vkCmdCopyImage2)gdpa(*pDevice, "vkCmdCopyImage2");
dispatchTable.CmdBlitImage2 = (PFN_vkCmdBlitImage2)gdpa(*pDevice, "vkCmdBlitImage2");
dispatchTable.CmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2)gdpa(*pDevice, "vkCmdCopyBufferToImage2");
dispatchTable.CmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2)gdpa(*pDevice, "vkCmdCopyImageToBuffer2");
dispatchTable.CmdResolveImage2 = (PFN_vkCmdResolveImage2)gdpa(*pDevice, "vkCmdResolveImage2");
dispatchTable.CmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR)gdpa(*pDevice, "vkCmdSetFragmentShadingRateKHR");
dispatchTable.CmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV)gdpa(*pDevice, "vkCmdSetFragmentShadingRateEnumNV");
dispatchTable.GetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR)gdpa(*pDevice, "vkGetAccelerationStructureBuildSizesKHR");
dispatchTable.CmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT)gdpa(*pDevice, "vkCmdSetVertexInputEXT");
dispatchTable.CmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT)gdpa(*pDevice, "vkCmdSetColorWriteEnableEXT");
dispatchTable.CmdSetEvent2 = (PFN_vkCmdSetEvent2)gdpa(*pDevice, "vkCmdSetEvent2");
dispatchTable.CmdResetEvent2 = (PFN_vkCmdResetEvent2)gdpa(*pDevice, "vkCmdResetEvent2");
dispatchTable.CmdWaitEvents2 = (PFN_vkCmdWaitEvents2)gdpa(*pDevice, "vkCmdWaitEvents2");
dispatchTable.CmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2)gdpa(*pDevice, "vkCmdPipelineBarrier2");
dispatchTable.QueueSubmit2 = (PFN_vkQueueSubmit2)gdpa(*pDevice, "vkQueueSubmit2");
dispatchTable.CmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2)gdpa(*pDevice, "vkCmdWriteTimestamp2");
dispatchTable.CmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD)gdpa(*pDevice, "vkCmdWriteBufferMarker2AMD");
dispatchTable.GetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV)gdpa(*pDevice, "vkGetQueueCheckpointData2NV");
dispatchTable.CopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT)gdpa(*pDevice, "vkCopyMemoryToImageEXT");
dispatchTable.CopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT)gdpa(*pDevice, "vkCopyImageToMemoryEXT");
dispatchTable.CopyImageToImageEXT = (PFN_vkCopyImageToImageEXT)gdpa(*pDevice, "vkCopyImageToImageEXT");
dispatchTable.TransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT)gdpa(*pDevice, "vkTransitionImageLayoutEXT");
dispatchTable.CreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR)gdpa(*pDevice, "vkCreateVideoSessionKHR");
dispatchTable.DestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR)gdpa(*pDevice, "vkDestroyVideoSessionKHR");
dispatchTable.CreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR)gdpa(*pDevice, "vkCreateVideoSessionParametersKHR");
dispatchTable.UpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR)gdpa(*pDevice, "vkUpdateVideoSessionParametersKHR");
dispatchTable.GetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR)gdpa(*pDevice, "vkGetEncodedVideoSessionParametersKHR");
dispatchTable.DestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR)gdpa(*pDevice, "vkDestroyVideoSessionParametersKHR");
dispatchTable.GetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR)gdpa(*pDevice, "vkGetVideoSessionMemoryRequirementsKHR");
dispatchTable.BindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR)gdpa(*pDevice, "vkBindVideoSessionMemoryKHR");
dispatchTable.CmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR)gdpa(*pDevice, "vkCmdDecodeVideoKHR");
dispatchTable.CmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR)gdpa(*pDevice, "vkCmdBeginVideoCodingKHR");
dispatchTable.CmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR)gdpa(*pDevice, "vkCmdControlVideoCodingKHR");
dispatchTable.CmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR)gdpa(*pDevice, "vkCmdEndVideoCodingKHR");
dispatchTable.CmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR)gdpa(*pDevice, "vkCmdEncodeVideoKHR");
dispatchTable.CmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV)gdpa(*pDevice, "vkCmdDecompressMemoryNV");
dispatchTable.CmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV)gdpa(*pDevice, "vkCmdDecompressMemoryIndirectCountNV");
dispatchTable.CreateCuModuleNVX = (PFN_vkCreateCuModuleNVX)gdpa(*pDevice, "vkCreateCuModuleNVX");
dispatchTable.CreateCuFunctionNVX = (PFN_vkCreateCuFunctionNVX)gdpa(*pDevice, "vkCreateCuFunctionNVX");
dispatchTable.DestroyCuModuleNVX = (PFN_vkDestroyCuModuleNVX)gdpa(*pDevice, "vkDestroyCuModuleNVX");
dispatchTable.DestroyCuFunctionNVX = (PFN_vkDestroyCuFunctionNVX)gdpa(*pDevice, "vkDestroyCuFunctionNVX");
dispatchTable.CmdCuLaunchKernelNVX = (PFN_vkCmdCuLaunchKernelNVX)gdpa(*pDevice, "vkCmdCuLaunchKernelNVX");
dispatchTable.GetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT)gdpa(*pDevice, "vkGetDescriptorSetLayoutSizeEXT");
dispatchTable.GetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT)gdpa(*pDevice, "vkGetDescriptorSetLayoutBindingOffsetEXT");
dispatchTable.GetDescriptorEXT = (PFN_vkGetDescriptorEXT)gdpa(*pDevice, "vkGetDescriptorEXT");
dispatchTable.CmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT)gdpa(*pDevice, "vkCmdBindDescriptorBuffersEXT");
dispatchTable.CmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT)gdpa(*pDevice, "vkCmdSetDescriptorBufferOffsetsEXT");
dispatchTable.CmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)gdpa(*pDevice, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
dispatchTable.GetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT)gdpa(*pDevice, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
dispatchTable.GetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT)gdpa(*pDevice, "vkGetImageOpaqueCaptureDescriptorDataEXT");
dispatchTable.GetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT)gdpa(*pDevice, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
dispatchTable.GetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT)gdpa(*pDevice, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
dispatchTable.GetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)gdpa(*pDevice, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
dispatchTable.SetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT)gdpa(*pDevice, "vkSetDeviceMemoryPriorityEXT");
dispatchTable.WaitForPresentKHR = (PFN_vkWaitForPresentKHR)gdpa(*pDevice, "vkWaitForPresentKHR");
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.CreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA)gdpa(*pDevice, "vkCreateBufferCollectionFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.SetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA)gdpa(*pDevice, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.SetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA)gdpa(*pDevice, "vkSetBufferCollectionImageConstraintsFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.DestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA)gdpa(*pDevice, "vkDestroyBufferCollectionFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.GetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA)gdpa(*pDevice, "vkGetBufferCollectionPropertiesFUCHSIA");
#endif
dispatchTable.CreateCudaModuleNV = (PFN_vkCreateCudaModuleNV)gdpa(*pDevice, "vkCreateCudaModuleNV");
dispatchTable.GetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV)gdpa(*pDevice, "vkGetCudaModuleCacheNV");
dispatchTable.CreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV)gdpa(*pDevice, "vkCreateCudaFunctionNV");
dispatchTable.DestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV)gdpa(*pDevice, "vkDestroyCudaModuleNV");
dispatchTable.DestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV)gdpa(*pDevice, "vkDestroyCudaFunctionNV");
dispatchTable.CmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV)gdpa(*pDevice, "vkCmdCudaLaunchKernelNV");
dispatchTable.CmdBeginRendering = (PFN_vkCmdBeginRendering)gdpa(*pDevice, "vkCmdBeginRendering");
dispatchTable.CmdEndRendering = (PFN_vkCmdEndRendering)gdpa(*pDevice, "vkCmdEndRendering");
dispatchTable.GetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE)gdpa(*pDevice, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
dispatchTable.GetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE)gdpa(*pDevice, "vkGetDescriptorSetHostMappingVALVE");
dispatchTable.CreateMicromapEXT = (PFN_vkCreateMicromapEXT)gdpa(*pDevice, "vkCreateMicromapEXT");
dispatchTable.CmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT)gdpa(*pDevice, "vkCmdBuildMicromapsEXT");
dispatchTable.BuildMicromapsEXT = (PFN_vkBuildMicromapsEXT)gdpa(*pDevice, "vkBuildMicromapsEXT");
dispatchTable.DestroyMicromapEXT = (PFN_vkDestroyMicromapEXT)gdpa(*pDevice, "vkDestroyMicromapEXT");
dispatchTable.CmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT)gdpa(*pDevice, "vkCmdCopyMicromapEXT");
dispatchTable.CopyMicromapEXT = (PFN_vkCopyMicromapEXT)gdpa(*pDevice, "vkCopyMicromapEXT");
dispatchTable.CmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT)gdpa(*pDevice, "vkCmdCopyMicromapToMemoryEXT");
dispatchTable.CopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT)gdpa(*pDevice, "vkCopyMicromapToMemoryEXT");
dispatchTable.CmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT)gdpa(*pDevice, "vkCmdCopyMemoryToMicromapEXT");
dispatchTable.CopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT)gdpa(*pDevice, "vkCopyMemoryToMicromapEXT");
dispatchTable.CmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT)gdpa(*pDevice, "vkCmdWriteMicromapsPropertiesEXT");
dispatchTable.WriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT)gdpa(*pDevice, "vkWriteMicromapsPropertiesEXT");
dispatchTable.GetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT)gdpa(*pDevice, "vkGetDeviceMicromapCompatibilityEXT");
dispatchTable.GetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT)gdpa(*pDevice, "vkGetMicromapBuildSizesEXT");
dispatchTable.GetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT)gdpa(*pDevice, "vkGetShaderModuleIdentifierEXT");
dispatchTable.GetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT)gdpa(*pDevice, "vkGetShaderModuleCreateInfoIdentifierEXT");
dispatchTable.GetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR)gdpa(*pDevice, "vkGetImageSubresourceLayout2KHR");
dispatchTable.GetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT)gdpa(*pDevice, "vkGetPipelinePropertiesEXT");
#if defined(VK_USE_PLATFORM_METAL_EXT)
dispatchTable.ExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT)gdpa(*pDevice, "vkExportMetalObjectsEXT");
#endif
dispatchTable.GetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM)gdpa(*pDevice, "vkGetFramebufferTilePropertiesQCOM");
dispatchTable.GetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM)gdpa(*pDevice, "vkGetDynamicRenderingTilePropertiesQCOM");
dispatchTable.CreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV)gdpa(*pDevice, "vkCreateOpticalFlowSessionNV");
dispatchTable.DestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV)gdpa(*pDevice, "vkDestroyOpticalFlowSessionNV");
dispatchTable.BindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV)gdpa(*pDevice, "vkBindOpticalFlowSessionImageNV");
dispatchTable.CmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV)gdpa(*pDevice, "vkCmdOpticalFlowExecuteNV");
dispatchTable.GetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT)gdpa(*pDevice, "vkGetDeviceFaultInfoEXT");
dispatchTable.CmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT)gdpa(*pDevice, "vkCmdSetDepthBias2EXT");
dispatchTable.ReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT)gdpa(*pDevice, "vkReleaseSwapchainImagesEXT");
dispatchTable.GetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR)gdpa(*pDevice, "vkGetDeviceImageSubresourceLayoutKHR");
dispatchTable.MapMemory2KHR = (PFN_vkMapMemory2KHR)gdpa(*pDevice, "vkMapMemory2KHR");
dispatchTable.UnmapMemory2KHR = (PFN_vkUnmapMemory2KHR)gdpa(*pDevice, "vkUnmapMemory2KHR");
dispatchTable.CreateShadersEXT = (PFN_vkCreateShadersEXT)gdpa(*pDevice, "vkCreateShadersEXT");
dispatchTable.DestroyShaderEXT = (PFN_vkDestroyShaderEXT)gdpa(*pDevice, "vkDestroyShaderEXT");
dispatchTable.GetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT)gdpa(*pDevice, "vkGetShaderBinaryDataEXT");
dispatchTable.CmdBindShadersEXT = (PFN_vkCmdBindShadersEXT)gdpa(*pDevice, "vkCmdBindShadersEXT");
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
dispatchTable.GetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX)gdpa(*pDevice, "vkGetScreenBufferPropertiesQNX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.GetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX)gdpa(*pDevice, "vkGetExecutionGraphPipelineScratchSizeAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.GetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX)gdpa(*pDevice, "vkGetExecutionGraphPipelineNodeIndexAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.CreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX)gdpa(*pDevice, "vkCreateExecutionGraphPipelinesAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.CmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX)gdpa(*pDevice, "vkCmdInitializeGraphScratchMemoryAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.CmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX)gdpa(*pDevice, "vkCmdDispatchGraphAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.CmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX)gdpa(*pDevice, "vkCmdDispatchGraphIndirectAMDX");
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
dispatchTable.CmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX)gdpa(*pDevice, "vkCmdDispatchGraphIndirectCountAMDX");
#endif
dispatchTable.CmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR)gdpa(*pDevice, "vkCmdBindDescriptorSets2KHR");
dispatchTable.CmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR)gdpa(*pDevice, "vkCmdPushConstants2KHR");
dispatchTable.CmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR)gdpa(*pDevice, "vkCmdPushDescriptorSet2KHR");
dispatchTable.CmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR)gdpa(*pDevice, "vkCmdPushDescriptorSetWithTemplate2KHR");
dispatchTable.CmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT)gdpa(*pDevice, "vkCmdSetDescriptorBufferOffsets2EXT");
dispatchTable.CmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)gdpa(*pDevice, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
dispatchTable.SetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV)gdpa(*pDevice, "vkSetLatencySleepModeNV");
dispatchTable.LatencySleepNV = (PFN_vkLatencySleepNV)gdpa(*pDevice, "vkLatencySleepNV");
dispatchTable.SetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV)gdpa(*pDevice, "vkSetLatencyMarkerNV");
dispatchTable.GetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV)gdpa(*pDevice, "vkGetLatencyTimingsNV");
dispatchTable.QueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV)gdpa(*pDevice, "vkQueueNotifyOutOfBandNV");
dispatchTable.ResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT)gdpa(*pDevice, "vkResetQueryPoolEXT");
dispatchTable.TrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR)gdpa(*pDevice, "vkTrimCommandPoolKHR");
dispatchTable.GetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR)gdpa(*pDevice, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
dispatchTable.BindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR)gdpa(*pDevice, "vkBindBufferMemory2KHR");
dispatchTable.BindImageMemory2KHR = (PFN_vkBindImageMemory2KHR)gdpa(*pDevice, "vkBindImageMemory2KHR");
dispatchTable.CmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR)gdpa(*pDevice, "vkCmdSetDeviceMaskKHR");
dispatchTable.CmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR)gdpa(*pDevice, "vkCmdDispatchBaseKHR");
dispatchTable.CreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR)gdpa(*pDevice, "vkCreateDescriptorUpdateTemplateKHR");
dispatchTable.DestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR)gdpa(*pDevice, "vkDestroyDescriptorUpdateTemplateKHR");
dispatchTable.UpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR)gdpa(*pDevice, "vkUpdateDescriptorSetWithTemplateKHR");
dispatchTable.GetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR)gdpa(*pDevice, "vkGetBufferMemoryRequirements2KHR");
dispatchTable.GetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR)gdpa(*pDevice, "vkGetImageMemoryRequirements2KHR");
dispatchTable.GetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR)gdpa(*pDevice, "vkGetImageSparseMemoryRequirements2KHR");
dispatchTable.GetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR)gdpa(*pDevice, "vkGetDeviceBufferMemoryRequirementsKHR");
dispatchTable.GetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR)gdpa(*pDevice, "vkGetDeviceImageMemoryRequirementsKHR");
dispatchTable.GetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR)gdpa(*pDevice, "vkGetDeviceImageSparseMemoryRequirementsKHR");
dispatchTable.CreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR)gdpa(*pDevice, "vkCreateSamplerYcbcrConversionKHR");
dispatchTable.DestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR)gdpa(*pDevice, "vkDestroySamplerYcbcrConversionKHR");
dispatchTable.GetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR)gdpa(*pDevice, "vkGetDescriptorSetLayoutSupportKHR");
dispatchTable.GetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT)gdpa(*pDevice, "vkGetCalibratedTimestampsEXT");
dispatchTable.CreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR)gdpa(*pDevice, "vkCreateRenderPass2KHR");
dispatchTable.CmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR)gdpa(*pDevice, "vkCmdBeginRenderPass2KHR");
dispatchTable.CmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR)gdpa(*pDevice, "vkCmdNextSubpass2KHR");
dispatchTable.CmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR)gdpa(*pDevice, "vkCmdEndRenderPass2KHR");
dispatchTable.GetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR)gdpa(*pDevice, "vkGetSemaphoreCounterValueKHR");
dispatchTable.WaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR)gdpa(*pDevice, "vkWaitSemaphoresKHR");
dispatchTable.SignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR)gdpa(*pDevice, "vkSignalSemaphoreKHR");
dispatchTable.CmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR)gdpa(*pDevice, "vkCmdDrawIndirectCountKHR");
dispatchTable.CmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD)gdpa(*pDevice, "vkCmdDrawIndirectCountAMD");
dispatchTable.CmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR)gdpa(*pDevice, "vkCmdDrawIndexedIndirectCountKHR");
dispatchTable.CmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD)gdpa(*pDevice, "vkCmdDrawIndexedIndirectCountAMD");
dispatchTable.GetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV)gdpa(*pDevice, "vkGetRayTracingShaderGroupHandlesNV");
dispatchTable.GetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR)gdpa(*pDevice, "vkGetBufferOpaqueCaptureAddressKHR");
dispatchTable.GetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR)gdpa(*pDevice, "vkGetBufferDeviceAddressKHR");
dispatchTable.GetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT)gdpa(*pDevice, "vkGetBufferDeviceAddressEXT");
dispatchTable.GetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR)gdpa(*pDevice, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
dispatchTable.CmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT)gdpa(*pDevice, "vkCmdSetLineStippleEXT");
dispatchTable.CmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT)gdpa(*pDevice, "vkCmdSetCullModeEXT");
dispatchTable.CmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT)gdpa(*pDevice, "vkCmdSetFrontFaceEXT");
dispatchTable.CmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT)gdpa(*pDevice, "vkCmdSetPrimitiveTopologyEXT");
dispatchTable.CmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT)gdpa(*pDevice, "vkCmdSetViewportWithCountEXT");
dispatchTable.CmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT)gdpa(*pDevice, "vkCmdSetScissorWithCountEXT");
dispatchTable.CmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT)gdpa(*pDevice, "vkCmdBindVertexBuffers2EXT");
dispatchTable.CmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT)gdpa(*pDevice, "vkCmdSetDepthTestEnableEXT");
dispatchTable.CmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT)gdpa(*pDevice, "vkCmdSetDepthWriteEnableEXT");
dispatchTable.CmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT)gdpa(*pDevice, "vkCmdSetDepthCompareOpEXT");
dispatchTable.CmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT)gdpa(*pDevice, "vkCmdSetDepthBoundsTestEnableEXT");
dispatchTable.CmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT)gdpa(*pDevice, "vkCmdSetStencilTestEnableEXT");
dispatchTable.CmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT)gdpa(*pDevice, "vkCmdSetStencilOpEXT");
dispatchTable.CmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT)gdpa(*pDevice, "vkCmdSetRasterizerDiscardEnableEXT");
dispatchTable.CmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT)gdpa(*pDevice, "vkCmdSetDepthBiasEnableEXT");
dispatchTable.CmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT)gdpa(*pDevice, "vkCmdSetPrimitiveRestartEnableEXT");
dispatchTable.CreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT)gdpa(*pDevice, "vkCreatePrivateDataSlotEXT");
dispatchTable.DestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT)gdpa(*pDevice, "vkDestroyPrivateDataSlotEXT");
dispatchTable.SetPrivateDataEXT = (PFN_vkSetPrivateDataEXT)gdpa(*pDevice, "vkSetPrivateDataEXT");
dispatchTable.GetPrivateDataEXT = (PFN_vkGetPrivateDataEXT)gdpa(*pDevice, "vkGetPrivateDataEXT");
dispatchTable.CmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR)gdpa(*pDevice, "vkCmdCopyBuffer2KHR");
dispatchTable.CmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR)gdpa(*pDevice, "vkCmdCopyImage2KHR");
dispatchTable.CmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR)gdpa(*pDevice, "vkCmdBlitImage2KHR");
dispatchTable.CmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR)gdpa(*pDevice, "vkCmdCopyBufferToImage2KHR");
dispatchTable.CmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR)gdpa(*pDevice, "vkCmdCopyImageToBuffer2KHR");
dispatchTable.CmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR)gdpa(*pDevice, "vkCmdResolveImage2KHR");
dispatchTable.CmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR)gdpa(*pDevice, "vkCmdSetEvent2KHR");
dispatchTable.CmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR)gdpa(*pDevice, "vkCmdResetEvent2KHR");
dispatchTable.CmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR)gdpa(*pDevice, "vkCmdWaitEvents2KHR");
dispatchTable.CmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR)gdpa(*pDevice, "vkCmdPipelineBarrier2KHR");
dispatchTable.QueueSubmit2KHR = (PFN_vkQueueSubmit2KHR)gdpa(*pDevice, "vkQueueSubmit2KHR");
dispatchTable.CmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR)gdpa(*pDevice, "vkCmdWriteTimestamp2KHR");
dispatchTable.CmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR)gdpa(*pDevice, "vkCmdBeginRenderingKHR");
dispatchTable.CmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR)gdpa(*pDevice, "vkCmdEndRenderingKHR");
dispatchTable.GetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT)gdpa(*pDevice, "vkGetImageSubresourceLayout2EXT");

{ scoped_lock l(global_lock); 
device_dispatch[GetKey(*pDevice)] = dispatchTable; 
} 
} 
 
void CreateInstanceDispatch(PFN_vkGetInstanceProcAddr gpa, VkInstance* pInstance) {
VkLayerInstanceDispatchTable dispatchTable;
dispatchTable.CreateInstance = (PFN_vkCreateInstance)gpa(*pInstance, "vkCreateInstance");
dispatchTable.DestroyInstance = (PFN_vkDestroyInstance)gpa(*pInstance, "vkDestroyInstance");
dispatchTable.EnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices)gpa(*pInstance, "vkEnumeratePhysicalDevices");
dispatchTable.GetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)gpa(*pInstance, "vkGetInstanceProcAddr");
dispatchTable.GetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties)gpa(*pInstance, "vkGetPhysicalDeviceProperties");
dispatchTable.GetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties)gpa(*pInstance, "vkGetPhysicalDeviceQueueFamilyProperties");
dispatchTable.GetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties)gpa(*pInstance, "vkGetPhysicalDeviceMemoryProperties");
dispatchTable.GetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures)gpa(*pInstance, "vkGetPhysicalDeviceFeatures");
dispatchTable.GetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties)gpa(*pInstance, "vkGetPhysicalDeviceFormatProperties");
dispatchTable.GetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties)gpa(*pInstance, "vkGetPhysicalDeviceImageFormatProperties");
dispatchTable.CreateDevice = (PFN_vkCreateDevice)gpa(*pInstance, "vkCreateDevice");
dispatchTable.EnumerateInstanceExtensionProperties = (PFN_vkEnumerateInstanceExtensionProperties)gpa(*pInstance, "vkEnumerateInstanceExtensionProperties");
dispatchTable.EnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties)gpa(*pInstance, "vkEnumerateDeviceLayerProperties");
dispatchTable.EnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties)gpa(*pInstance, "vkEnumerateDeviceExtensionProperties");
dispatchTable.GetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties)gpa(*pInstance, "vkGetPhysicalDeviceSparseImageFormatProperties");
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
dispatchTable.CreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR)gpa(*pInstance, "vkCreateAndroidSurfaceKHR");
#endif
dispatchTable.GetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
dispatchTable.GetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
dispatchTable.GetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR)gpa(*pInstance, "vkGetDisplayPlaneSupportedDisplaysKHR");
dispatchTable.GetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR)gpa(*pInstance, "vkGetDisplayModePropertiesKHR");
dispatchTable.CreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR)gpa(*pInstance, "vkCreateDisplayModeKHR");
dispatchTable.GetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR)gpa(*pInstance, "vkGetDisplayPlaneCapabilitiesKHR");
dispatchTable.CreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR)gpa(*pInstance, "vkCreateDisplayPlaneSurfaceKHR");
dispatchTable.DestroySurfaceKHR = (PFN_vkDestroySurfaceKHR)gpa(*pInstance, "vkDestroySurfaceKHR");
dispatchTable.GetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceSupportKHR");
dispatchTable.GetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
dispatchTable.GetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
dispatchTable.GetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
#if defined(VK_USE_PLATFORM_VI_NN)
dispatchTable.CreateViSurfaceNN = (PFN_vkCreateViSurfaceNN)gpa(*pInstance, "vkCreateViSurfaceNN");
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
dispatchTable.CreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR)gpa(*pInstance, "vkCreateWaylandSurfaceKHR");
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
dispatchTable.GetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)gpa(*pInstance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR)gpa(*pInstance, "vkCreateWin32SurfaceKHR");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)gpa(*pInstance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
dispatchTable.CreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR)gpa(*pInstance, "vkCreateXlibSurfaceKHR");
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
dispatchTable.GetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)gpa(*pInstance, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
dispatchTable.CreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR)gpa(*pInstance, "vkCreateXcbSurfaceKHR");
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
dispatchTable.GetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)gpa(*pInstance, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
dispatchTable.CreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT)gpa(*pInstance, "vkCreateDirectFBSurfaceEXT");
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
dispatchTable.GetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)gpa(*pInstance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
dispatchTable.CreateImagePipeSurfaceFUCHSIA = (PFN_vkCreateImagePipeSurfaceFUCHSIA)gpa(*pInstance, "vkCreateImagePipeSurfaceFUCHSIA");
#endif
#if defined(VK_USE_PLATFORM_GGP)
dispatchTable.CreateStreamDescriptorSurfaceGGP = (PFN_vkCreateStreamDescriptorSurfaceGGP)gpa(*pInstance, "vkCreateStreamDescriptorSurfaceGGP");
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
dispatchTable.CreateScreenSurfaceQNX = (PFN_vkCreateScreenSurfaceQNX)gpa(*pInstance, "vkCreateScreenSurfaceQNX");
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
dispatchTable.GetPhysicalDeviceScreenPresentationSupportQNX = (PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX)gpa(*pInstance, "vkGetPhysicalDeviceScreenPresentationSupportQNX");
#endif
dispatchTable.CreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT)gpa(*pInstance, "vkCreateDebugReportCallbackEXT");
dispatchTable.DestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT)gpa(*pInstance, "vkDestroyDebugReportCallbackEXT");
dispatchTable.DebugReportMessageEXT = (PFN_vkDebugReportMessageEXT)gpa(*pInstance, "vkDebugReportMessageEXT");
dispatchTable.GetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)gpa(*pInstance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
dispatchTable.GetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2)gpa(*pInstance, "vkGetPhysicalDeviceFeatures2");
dispatchTable.GetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2)gpa(*pInstance, "vkGetPhysicalDeviceProperties2");
dispatchTable.GetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2)gpa(*pInstance, "vkGetPhysicalDeviceFormatProperties2");
dispatchTable.GetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2)gpa(*pInstance, "vkGetPhysicalDeviceImageFormatProperties2");
dispatchTable.GetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2)gpa(*pInstance, "vkGetPhysicalDeviceQueueFamilyProperties2");
dispatchTable.GetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2)gpa(*pInstance, "vkGetPhysicalDeviceMemoryProperties2");
dispatchTable.GetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2)gpa(*pInstance, "vkGetPhysicalDeviceSparseImageFormatProperties2");
dispatchTable.GetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties)gpa(*pInstance, "vkGetPhysicalDeviceExternalBufferProperties");
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetPhysicalDeviceExternalMemorySciBufPropertiesNV = (PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV)gpa(*pInstance, "vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV");
#endif
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetPhysicalDeviceSciBufAttributesNV = (PFN_vkGetPhysicalDeviceSciBufAttributesNV)gpa(*pInstance, "vkGetPhysicalDeviceSciBufAttributesNV");
#endif
dispatchTable.GetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties)gpa(*pInstance, "vkGetPhysicalDeviceExternalSemaphoreProperties");
dispatchTable.GetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties)gpa(*pInstance, "vkGetPhysicalDeviceExternalFenceProperties");
#if defined(VK_USE_PLATFORM_SCI)
dispatchTable.GetPhysicalDeviceSciSyncAttributesNV = (PFN_vkGetPhysicalDeviceSciSyncAttributesNV)gpa(*pInstance, "vkGetPhysicalDeviceSciSyncAttributesNV");
#endif
dispatchTable.ReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT)gpa(*pInstance, "vkReleaseDisplayEXT");
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
dispatchTable.AcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT)gpa(*pInstance, "vkAcquireXlibDisplayEXT");
#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
dispatchTable.GetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT)gpa(*pInstance, "vkGetRandROutputDisplayEXT");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.AcquireWinrtDisplayNV = (PFN_vkAcquireWinrtDisplayNV)gpa(*pInstance, "vkAcquireWinrtDisplayNV");
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetWinrtDisplayNV = (PFN_vkGetWinrtDisplayNV)gpa(*pInstance, "vkGetWinrtDisplayNV");
#endif
dispatchTable.GetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
dispatchTable.EnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups)gpa(*pInstance, "vkEnumeratePhysicalDeviceGroups");
dispatchTable.GetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR)gpa(*pInstance, "vkGetPhysicalDevicePresentRectanglesKHR");
#if defined(VK_USE_PLATFORM_IOS_MVK)
dispatchTable.CreateIOSSurfaceMVK = (PFN_vkCreateIOSSurfaceMVK)gpa(*pInstance, "vkCreateIOSSurfaceMVK");
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
dispatchTable.CreateMacOSSurfaceMVK = (PFN_vkCreateMacOSSurfaceMVK)gpa(*pInstance, "vkCreateMacOSSurfaceMVK");
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
dispatchTable.CreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT)gpa(*pInstance, "vkCreateMetalSurfaceEXT");
#endif
dispatchTable.GetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT)gpa(*pInstance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
dispatchTable.GetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
dispatchTable.GetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR)gpa(*pInstance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
dispatchTable.GetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceDisplayProperties2KHR");
dispatchTable.GetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
dispatchTable.GetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR)gpa(*pInstance, "vkGetDisplayModeProperties2KHR");
dispatchTable.GetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR)gpa(*pInstance, "vkGetDisplayPlaneCapabilities2KHR");
dispatchTable.GetPhysicalDeviceCalibrateableTimeDomainsKHR = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)gpa(*pInstance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR");
dispatchTable.CreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT)gpa(*pInstance, "vkCreateDebugUtilsMessengerEXT");
dispatchTable.DestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT)gpa(*pInstance, "vkDestroyDebugUtilsMessengerEXT");
dispatchTable.SubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT)gpa(*pInstance, "vkSubmitDebugUtilsMessageEXT");
dispatchTable.GetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)gpa(*pInstance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
#if defined(VK_USE_PLATFORM_WIN32_KHR)
dispatchTable.GetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT)gpa(*pInstance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
#endif
dispatchTable.EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)gpa(*pInstance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
dispatchTable.GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)gpa(*pInstance, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
dispatchTable.CreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT)gpa(*pInstance, "vkCreateHeadlessSurfaceEXT");
dispatchTable.GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = (PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)gpa(*pInstance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
dispatchTable.GetPhysicalDeviceToolProperties = (PFN_vkGetPhysicalDeviceToolProperties)gpa(*pInstance, "vkGetPhysicalDeviceToolProperties");
dispatchTable.GetPhysicalDeviceFragmentShadingRatesKHR = (PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR)gpa(*pInstance, "vkGetPhysicalDeviceFragmentShadingRatesKHR");
dispatchTable.GetPhysicalDeviceVideoCapabilitiesKHR = (PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceVideoCapabilitiesKHR");
dispatchTable.GetPhysicalDeviceVideoFormatPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceVideoFormatPropertiesKHR");
dispatchTable.GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR");
dispatchTable.AcquireDrmDisplayEXT = (PFN_vkAcquireDrmDisplayEXT)gpa(*pInstance, "vkAcquireDrmDisplayEXT");
dispatchTable.GetDrmDisplayEXT = (PFN_vkGetDrmDisplayEXT)gpa(*pInstance, "vkGetDrmDisplayEXT");
dispatchTable.GetPhysicalDeviceOpticalFlowImageFormatsNV = (PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)gpa(*pInstance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
dispatchTable.GetPhysicalDeviceCooperativeMatrixPropertiesKHR = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
dispatchTable.GetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR)gpa(*pInstance, "vkGetPhysicalDeviceFeatures2KHR");
dispatchTable.GetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceProperties2KHR");
dispatchTable.GetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceFormatProperties2KHR");
dispatchTable.GetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceImageFormatProperties2KHR");
dispatchTable.GetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
dispatchTable.GetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceMemoryProperties2KHR");
dispatchTable.GetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)gpa(*pInstance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
dispatchTable.GetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
dispatchTable.GetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
dispatchTable.GetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR)gpa(*pInstance, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
dispatchTable.EnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR)gpa(*pInstance, "vkEnumeratePhysicalDeviceGroupsKHR");
dispatchTable.GetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)gpa(*pInstance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
dispatchTable.GetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT)gpa(*pInstance, "vkGetPhysicalDeviceToolPropertiesEXT");

{ scoped_lock l(global_lock); 
instance_dispatch[GetKey(*pInstance)] = dispatchTable; 
} 
} 
 

/* actual data we're recording in this layer */

/*struct CommandStats
{
    uint32_t drawCount = 0, instanceCount = 0, vertCount = 0;
};
std::map<VkCommandBuffer, CommandStats> commandbuffer_stats;
*/
bool connected = false;
bool skipLock = false;
#include <memory>
#include <fstream>

std::string bool_as_text(VkBool32 b)
{
    std::stringstream converter;
    converter << std::boolalpha << b;   // flag boolalpha calls converter.setf(std::ios_base::boolalpha)
    return converter.str();
}

std::string GetWindowName()
{
    /* get the name of the program the layer is on [windows only] */
    char buf[MAX_PATH];
    GetModuleFileNameA(nullptr, buf, MAX_PATH);
    std::filesystem::path progPath(buf);
    auto filename = progPath.filename().string();
    return filename;
}

/* Layer init and shutdown */
VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateInstance(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance)
{
    /* create new process */
    STARTUPINFO info = { sizeof(info) };
    PROCESS_INFORMATION processInfo;

    /* prevent opening vkDetails on appUI startup */
    if (GetWindowName() != "vkDetails.exe")
    {
        /* open new vkDetails window */
        CreateProcess("C:\\Users\\jozef\\Desktop\\vk details\\out\\build\\x64-debug\\vkDetails.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &info, &processInfo);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);

        /* connect layer to vkDetails */
        if (layerWinsockInit(&ConnectSocket) == 0)
        {
            connected = true;
        }
        if (connected)
        {
            /* fetch enviroment variables */
            try
            {
                char* appdata = getenv("APPDATA");
                std::string configPath = appdata;

                /* WINDOWS vk_layer_settings.txt path */
                configPath += "\\..\\Local\\LunarG\\vkconfig\\override\\vk_layer_settings.txt";

                std::ifstream configFile(configPath);
                if (configFile.is_open())
                {
                    std::stringstream buffer;
                    buffer << configFile.rdbuf();
                    SetMemoryVariables(buffer.str());
                }
                else
                {
                    //could not find settings, vkDetails layer will use default settings
                }

            }
            catch (std::exception e)
            {
                //do nothing, vkDetails layer will use default settings
            }
        }
    }

    VkLayerInstanceCreateInfo* layerCreateInfo = (VkLayerInstanceCreateInfo*)pCreateInfo->pNext;

    /* step through the chain of pNext until we get to the link info */
    while (layerCreateInfo && (layerCreateInfo->sType != VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO || layerCreateInfo->function != VK_LAYER_LINK_INFO))
    {
        layerCreateInfo = (VkLayerInstanceCreateInfo*)layerCreateInfo->pNext;
    }

    if (layerCreateInfo == NULL)
    {
        /* No loader instance create info */
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    /* map this function to dispatch table */
    PFN_vkGetInstanceProcAddr gpa = layerCreateInfo->u.pLayerInfo->pfnNextGetInstanceProcAddr;
    layerCreateInfo->u.pLayerInfo = layerCreateInfo->u.pLayerInfo->pNext;
    PFN_vkCreateInstance createFunc = (PFN_vkCreateInstance)gpa(VK_NULL_HANDLE, "vkCreateInstance");

    /* fetch our own dispatch table for the functions we need, into the next layer */
    CreateInstanceDispatch(gpa, pInstance);

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkCreateInstance!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef CREATEINSTANCE_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_CreateInstance_before(pCreateInfo, pAllocator, pInstance);
    }
    #endif

    /* send to loader */
    VkResult ret = createFunc(pCreateInfo, pAllocator, pInstance);

    /* additional call if defined by user [on the way back out of loader] */
    #ifdef CREATEINSTANCE_AFTER_EXEC_EXISTS
    if (connected) {
        layer_CreateInstance_after(pCreateInfo, pAllocator, pInstance);
    }
    #endif 

    /* send call after loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "pCreateInfo->sType=" + std::to_string(pCreateInfo->sType) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pNext=" + ptrToString((void**)pCreateInfo->pNext) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->flags=" + std::to_string(pCreateInfo->flags) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->sType=" + std::to_string(pCreateInfo->pApplicationInfo->sType) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->pNext=" + ptrToString((void**)pCreateInfo->pApplicationInfo->pNext) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->pApplicationName=" + charToString((char*)pCreateInfo->pApplicationInfo->pApplicationName) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->applicationVersion=" + std::to_string(pCreateInfo->pApplicationInfo->applicationVersion) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->pEngineName=" + charToString((char*)pCreateInfo->pApplicationInfo->pEngineName) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->engineVersion=" + std::to_string(pCreateInfo->pApplicationInfo->engineVersion) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pApplicationInfo->apiVersion=" + std::to_string(pCreateInfo->pApplicationInfo->apiVersion) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->enabledLayerCount=" + std::to_string(pCreateInfo->enabledLayerCount) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->ppEnabledLayerNames=" + charToString((char*)pCreateInfo->ppEnabledLayerNames) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->enabledExtensionCount=" + std::to_string(pCreateInfo->enabledExtensionCount) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->ppEnabledExtensionNames=" + charToString((char*)pCreateInfo->ppEnabledExtensionNames) + '!');
        
        winsockSendToUI(&ConnectSocket, "end_vkCreateInstance!");

        if (callEveryBreak || callAtBreak)
            newCall();
    }

    return ret;
}

VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator)
{
    scoped_lock l(global_lock);

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkDestroyInstance!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef DESTROYINSTANCE_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_DestroyInstance_before(instance, pAllocator);
    }
    #endif

    /* Destroy layer */
    instance_dispatch.erase(GetKey(instance));

    /* additional call if defined by user [on the way back out of loader] */
    #ifdef DESTROYINSTANCE_AFTER_EXEC_EXISTS
    if (connected) {
        layer_DestroyInstance_after(instance, pAllocator);
    }
    #endif 

    /* send call after loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkDestroyInstance!");

        if (callEveryBreak || callAtBreak)
            newCall();
    }

    /* Disconnect from the VkDetails */
    layerWinsockExit(&ConnectSocket);
}

VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice)
{
    VkLayerDeviceCreateInfo* layerCreateInfo = (VkLayerDeviceCreateInfo*)pCreateInfo->pNext;

    /* step through the chain of pNext until we get to the link info */
    while (layerCreateInfo && (layerCreateInfo->sType != VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO ||
        layerCreateInfo->function != VK_LAYER_LINK_INFO))
    {
        layerCreateInfo = (VkLayerDeviceCreateInfo*)layerCreateInfo->pNext;
    }

    if (layerCreateInfo == NULL)
    {
        /* No loader instance create info */
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    PFN_vkGetInstanceProcAddr gipa = layerCreateInfo->u.pLayerInfo->pfnNextGetInstanceProcAddr;
    PFN_vkGetDeviceProcAddr gdpa = layerCreateInfo->u.pLayerInfo->pfnNextGetDeviceProcAddr;
    /* move chain on for next layer */
    layerCreateInfo->u.pLayerInfo = layerCreateInfo->u.pLayerInfo->pNext;

    PFN_vkCreateDevice createFunc = (PFN_vkCreateDevice)gipa(VK_NULL_HANDLE, "vkCreateDevice");

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkCreateDevice!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef CREATEDEVICE_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_CreateDevice_before(physicalDevice, pCreateInfo, pAllocator, pDevice);
    }
    #endif
        
    /* send to loader */
    VkResult ret = createFunc(physicalDevice, pCreateInfo, pAllocator, pDevice);

    /* additional call if defined by user [on the way back out of loader] */
    #ifdef CREATEDEVICE_AFTER_EXEC_EXISTS
    if (connected) {
        layer_CreateDevice_after(physicalDevice, pCreateInfo, pAllocator, pDevice);
    }
    #endif

    /* send call after loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "pCreateInfo->sType=" + std::to_string(pCreateInfo->sType) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pNext=" + ptrToString((void**)pCreateInfo->pNext) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->flags=" + std::to_string(pCreateInfo->flags) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->queueCreateInfoCount=" + std::to_string(pCreateInfo->queueCreateInfoCount) + '!');
        for (unsigned int i = 0; i < pCreateInfo->queueCreateInfoCount; i++)
        {
            winsockSendToUI(&ConnectSocket, "pCreateInfo->pQueueCreateInfos" + std::to_string(i) + "->sType=" + std::to_string(pCreateInfo->pQueueCreateInfos[i].sType) + '!');
            winsockSendToUI(&ConnectSocket, "pCreateInfo->pQueueCreateInfos" + std::to_string(i) + "->flags=" + std::to_string(pCreateInfo->pQueueCreateInfos[i].flags) + '!');
            winsockSendToUI(&ConnectSocket, "pCreateInfo->pQueueCreateInfos" + std::to_string(i) + "->queueFamilyIndex=" + std::to_string(pCreateInfo->pQueueCreateInfos[i].queueFamilyIndex) + '!');
            winsockSendToUI(&ConnectSocket, "pCreateInfo->pQueueCreateInfos" + std::to_string(i) + "->queueCount=" + std::to_string(pCreateInfo->pQueueCreateInfos[i].queueCount) + '!');
            for (unsigned int a = 0; a < pCreateInfo->pQueueCreateInfos[i].queueCount; a++)
                winsockSendToUI(&ConnectSocket, "pCreateInfo->pQueueCreateInfos" + std::to_string(i) + "->pQueuePriorities" + std::to_string(a) + "=" + std::to_string(pCreateInfo->pQueueCreateInfos[i].pQueuePriorities[a]) + '!');
        }
        winsockSendToUI(&ConnectSocket, "pCreateInfo->enabledLayerCount=" + std::to_string(pCreateInfo->enabledLayerCount) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->ppEnabledLayerNames=" + charToString((char*)pCreateInfo->ppEnabledLayerNames) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->enabledExtensionCount=" + std::to_string(pCreateInfo->enabledExtensionCount) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->ppEnabledExtensionNames=" + charToString((char*)pCreateInfo->ppEnabledExtensionNames) + '!');
        winsockSendToUI(&ConnectSocket, "pCreateInfo->pNext=" + ptrToString((void**)pCreateInfo->pEnabledFeatures) + '!');
        winsockSendToUI(&ConnectSocket, "end_vkCreateDevice!");

        if (callEveryBreak || callAtBreak)
            newCall();
    }

    /* fetch our own dispatch table for the functions we need, into the next layer */
    CreateDeviceDispatch(gdpa, pDevice);

    return ret;
}

VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator)
{
    scoped_lock l(global_lock);
    
    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkDestroyDevice!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef DESTROYDEVICE_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_DestroyDevice_before(device, pAllocator);
    }
    #endif

    device_dispatch.erase(GetKey(device));

    /* additional call if defined by user [on the way back out of loader] */
    #ifdef DESTROYDEVICE_AFTER_EXEC_EXISTS
    if (connected) {
        layer_DestroyDevice_after(device, pAllocator);
    }
    #endif 

    /* send call after loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkDestroyDevice!");

        if (callEveryBreak || callAtBreak)
            newCall();
    }
}

/* Enumeration function */
VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumerateInstanceLayerProperties(uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{
    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkEnumerateInstanceLayerProperties!");
    }

    /* additional call if defined by user [before taken to loader] */
#ifdef ENUMERATEINSTANCELAYERPROPERTIES_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_EnumerateInstanceLayerProperties_before(pPropertyCount, pProperties);
    }
#endif
    if (pPropertyCount) *pPropertyCount = 1;

    if (pProperties)
    {
        strcpy_s(pProperties->layerName, "vkDetailsLayer");
        strcpy_s(pProperties->description, "https://github.com/xbilko03/ADT_VAPI");
        pProperties->implementationVersion = 1;
        pProperties->specVersion = VK_API_VERSION_1_0;
    }

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkEnumerateInstanceLayerProperties!");
        if (callEveryBreak || callAtBreak)
            newCall();
    }

    return VK_SUCCESS;
}

VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkEnumerateDeviceLayerProperties!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef ENUMERATEDEVICELAYERPROPERTIES_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_EnumerateDeviceLayerProperties_before(physicalDevice, pPropertyCount, pProperties);
    }
    #endif

    if (pPropertyCount) *pPropertyCount = 1;

    if (pProperties)
    {
        strcpy_s(pProperties->layerName, "vkDetailsLayer");
        strcpy_s(pProperties->description, "https://github.com/xbilko03/ADT_VAPI");
        pProperties->implementationVersion = 1;
        pProperties->specVersion = VK_API_VERSION_1_0;
    }

    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkEnumerateDeviceLayerProperties!");
        if (callEveryBreak || callAtBreak)
            newCall();
    }

    return VK_SUCCESS;
}

VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumerateInstanceExtensionProperties(const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{
    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkEnumerateInstanceExtensionProperties!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef ENUMERATEINSTANCEEXTENSIONPROPERTIES_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_EnumerateInstanceExtensionProperties_before(pLayerName, pPropertyCount, pProperties);
    }
    #endif

    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkEnumerateInstanceExtensionProperties!");

        if (callEveryBreak || callAtBreak)
            newCall();
    }

    if (pLayerName == NULL || strcmp(pLayerName, "VK_LAYER_SAMPLE_DetailsLayer"))
        return VK_ERROR_LAYER_NOT_PRESENT;

    /* don't expose any extensions */
    if (pPropertyCount) *pPropertyCount = 0;
    return VK_SUCCESS;
}

VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "begin_vkEnumerateDeviceExtensionProperties!");
    }

    /* additional call if defined by user [before taken to loader] */
    #ifdef ENUMERATEDEVICEEXTENSIONPROPERTIES_BEFORE_EXEC_EXISTS
    if (connected) {
        layer_EnumerateDeviceExtensionProperties_before(physicalDevice, pLayerName, pPropertyCount, pProperties);
    }
    #endif

    /* send call before loader */
    if (connected) {
        winsockSendToUI(&ConnectSocket, "end_vkEnumerateDeviceExtensionProperties!");


        if (callEveryBreak || callAtBreak)
            newCall();
    }


    /*  pass through any queries that aren't to us */
    if (pLayerName == NULL || strcmp(pLayerName, "VK_LAYER_SAMPLE_DetailsLayer"))
    {
        if (physicalDevice == VK_NULL_HANDLE)
            return VK_SUCCESS;

        scoped_lock l(global_lock);
        return instance_dispatch[GetKey(physicalDevice)].EnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
    }

    /* don't expose any extensions */
    if (pPropertyCount) *pPropertyCount = 0;


    return VK_SUCCESS;
}

/* Generated part */

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumeratePhysicalDevices(VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkEnumeratePhysicalDevices!");
}
#ifdef ENUMERATEPHYSICALDEVICES_BEFORE_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDevices_before(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"pPhysicalDevices=" + ptrToString((void**)std::addressof(pPhysicalDevices)) + '!');
}
#ifdef ENUMERATEPHYSICALDEVICES_AFTER_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDevices_after(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkEnumeratePhysicalDevices!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceProperties!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties_before(physicalDevice, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties(physicalDevice, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->apiVersion=" + std::to_string(pProperties->apiVersion) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->driverVersion=" + std::to_string(pProperties->driverVersion) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->vendorID=" + std::to_string(pProperties->vendorID) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->deviceID=" + std::to_string(pProperties->deviceID) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->limits=" + ptrToString((void**)std::addressof(pProperties->limits)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->sparseProperties=" + ptrToString((void**)std::addressof(pProperties->sparseProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties_after(physicalDevice, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties(physicalDevice, pProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceQueueFamilyProperties!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties_before(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pQueueFamilyProperties != VK_NULL_HANDLE && pQueueFamilyProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->queueFlags=" + ptrToString((void**)std::addressof(pQueueFamilyProperties->queueFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->queueCount=" + std::to_string(pQueueFamilyProperties->queueCount) + '!');
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->timestampValidBits=" + std::to_string(pQueueFamilyProperties->timestampValidBits) + '!');
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->minImageTransferGranularity=" + ptrToString((void**)std::addressof(pQueueFamilyProperties->minImageTransferGranularity)) + '!');
}else winsockSendToUI(&ConnectSocket, "pQueueFamilyProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties_after(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceQueueFamilyProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceMemoryProperties!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties_before(physicalDevice, pMemoryProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pMemoryProperties != VK_NULL_HANDLE && pMemoryProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryProperties->memoryTypeCount=" + std::to_string(pMemoryProperties->memoryTypeCount) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryProperties->memoryHeapCount=" + std::to_string(pMemoryProperties->memoryHeapCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties_after(physicalDevice, pMemoryProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceMemoryProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFeatures!");
}
#ifdef GETPHYSICALDEVICEFEATURES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures_before(physicalDevice, pFeatures);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures(physicalDevice, pFeatures);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFeatures != VK_NULL_HANDLE && pFeatures != NULL) {
winsockSendToUI(&ConnectSocket,"pFeatures->robustBufferAccess=" + bool_as_text(pFeatures->robustBufferAccess) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->fullDrawIndexUint32=" + bool_as_text(pFeatures->fullDrawIndexUint32) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->imageCubeArray=" + bool_as_text(pFeatures->imageCubeArray) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->independentBlend=" + bool_as_text(pFeatures->independentBlend) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->geometryShader=" + bool_as_text(pFeatures->geometryShader) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->tessellationShader=" + bool_as_text(pFeatures->tessellationShader) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sampleRateShading=" + bool_as_text(pFeatures->sampleRateShading) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->dualSrcBlend=" + bool_as_text(pFeatures->dualSrcBlend) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->logicOp=" + bool_as_text(pFeatures->logicOp) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->multiDrawIndirect=" + bool_as_text(pFeatures->multiDrawIndirect) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->drawIndirectFirstInstance=" + bool_as_text(pFeatures->drawIndirectFirstInstance) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->depthClamp=" + bool_as_text(pFeatures->depthClamp) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->depthBiasClamp=" + bool_as_text(pFeatures->depthBiasClamp) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->fillModeNonSolid=" + bool_as_text(pFeatures->fillModeNonSolid) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->depthBounds=" + bool_as_text(pFeatures->depthBounds) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->wideLines=" + bool_as_text(pFeatures->wideLines) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->largePoints=" + bool_as_text(pFeatures->largePoints) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->alphaToOne=" + bool_as_text(pFeatures->alphaToOne) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->multiViewport=" + bool_as_text(pFeatures->multiViewport) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->samplerAnisotropy=" + bool_as_text(pFeatures->samplerAnisotropy) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->textureCompressionETC2=" + bool_as_text(pFeatures->textureCompressionETC2) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->textureCompressionASTC_LDR=" + bool_as_text(pFeatures->textureCompressionASTC_LDR) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->textureCompressionBC=" + bool_as_text(pFeatures->textureCompressionBC) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->occlusionQueryPrecise=" + bool_as_text(pFeatures->occlusionQueryPrecise) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->pipelineStatisticsQuery=" + bool_as_text(pFeatures->pipelineStatisticsQuery) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->vertexPipelineStoresAndAtomics=" + bool_as_text(pFeatures->vertexPipelineStoresAndAtomics) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->fragmentStoresAndAtomics=" + bool_as_text(pFeatures->fragmentStoresAndAtomics) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderTessellationAndGeometryPointSize=" + bool_as_text(pFeatures->shaderTessellationAndGeometryPointSize) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderImageGatherExtended=" + bool_as_text(pFeatures->shaderImageGatherExtended) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageImageExtendedFormats=" + bool_as_text(pFeatures->shaderStorageImageExtendedFormats) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageImageMultisample=" + bool_as_text(pFeatures->shaderStorageImageMultisample) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageImageReadWithoutFormat=" + bool_as_text(pFeatures->shaderStorageImageReadWithoutFormat) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageImageWriteWithoutFormat=" + bool_as_text(pFeatures->shaderStorageImageWriteWithoutFormat) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderUniformBufferArrayDynamicIndexing=" + bool_as_text(pFeatures->shaderUniformBufferArrayDynamicIndexing) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderSampledImageArrayDynamicIndexing=" + bool_as_text(pFeatures->shaderSampledImageArrayDynamicIndexing) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageBufferArrayDynamicIndexing=" + bool_as_text(pFeatures->shaderStorageBufferArrayDynamicIndexing) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderStorageImageArrayDynamicIndexing=" + bool_as_text(pFeatures->shaderStorageImageArrayDynamicIndexing) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderClipDistance=" + bool_as_text(pFeatures->shaderClipDistance) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderCullDistance=" + bool_as_text(pFeatures->shaderCullDistance) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderFloat64=" + bool_as_text(pFeatures->shaderFloat64) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderInt64=" + bool_as_text(pFeatures->shaderInt64) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderInt16=" + bool_as_text(pFeatures->shaderInt16) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderResourceResidency=" + bool_as_text(pFeatures->shaderResourceResidency) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->shaderResourceMinLod=" + bool_as_text(pFeatures->shaderResourceMinLod) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseBinding=" + bool_as_text(pFeatures->sparseBinding) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidencyBuffer=" + bool_as_text(pFeatures->sparseResidencyBuffer) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidencyImage2D=" + bool_as_text(pFeatures->sparseResidencyImage2D) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidencyImage3D=" + bool_as_text(pFeatures->sparseResidencyImage3D) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidency2Samples=" + bool_as_text(pFeatures->sparseResidency2Samples) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidency4Samples=" + bool_as_text(pFeatures->sparseResidency4Samples) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidency8Samples=" + bool_as_text(pFeatures->sparseResidency8Samples) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidency16Samples=" + bool_as_text(pFeatures->sparseResidency16Samples) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->sparseResidencyAliased=" + bool_as_text(pFeatures->sparseResidencyAliased) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->variableMultisampleRate=" + bool_as_text(pFeatures->variableMultisampleRate) + '!');
winsockSendToUI(&ConnectSocket,"pFeatures->inheritedQueries=" + bool_as_text(pFeatures->inheritedQueries) + '!');
}else winsockSendToUI(&ConnectSocket, "pFeatures=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFEATURES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures_after(physicalDevice, pFeatures);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFeatures!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures(physicalDevice, pFeatures);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFormatProperties!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties_before(physicalDevice, format, pFormatProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFormatProperties != VK_NULL_HANDLE && pFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pFormatProperties->linearTilingFeatures=" + ptrToString((void**)std::addressof(pFormatProperties->linearTilingFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pFormatProperties->optimalTilingFeatures=" + ptrToString((void**)std::addressof(pFormatProperties->optimalTilingFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pFormatProperties->bufferFeatures=" + ptrToString((void**)std::addressof(pFormatProperties->bufferFeatures)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties_after(physicalDevice, format, pFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFormatProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceImageFormatProperties!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties_before(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"usage=" + ptrToString((void**)std::addressof(usage)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
if(pImageFormatProperties != VK_NULL_HANDLE && pImageFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->maxExtent=" + ptrToString((void**)std::addressof(pImageFormatProperties->maxExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->maxMipLevels=" + std::to_string(pImageFormatProperties->maxMipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->maxArrayLayers=" + std::to_string(pImageFormatProperties->maxArrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->sampleCounts=" + ptrToString((void**)std::addressof(pImageFormatProperties->sampleCounts)) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->maxResourceSize=" + std::to_string(pImageFormatProperties->maxResourceSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties_after(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceImageFormatProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSparseImageFormatProperties!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties_before(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"usage=" + ptrToString((void**)std::addressof(usage)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->aspectMask=" + ptrToString((void**)std::addressof(pProperties->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->imageGranularity=" + ptrToString((void**)std::addressof(pProperties->imageGranularity)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->flags=" + ptrToString((void**)std::addressof(pProperties->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties_after(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSparseImageFormatProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
}
}

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateAndroidSurfaceKHR(VkInstance instance, VkAndroidSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateAndroidSurfaceKHR!");
}
#ifdef CREATEANDROIDSURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateAndroidSurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->window=" + ptrToString((void**)std::addressof(pCreateInfo->window)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEANDROIDSURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateAndroidSurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateAndroidSurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceDisplayPropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPropertiesKHR_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->display=" + ptrToString((void**)std::addressof(pProperties->display)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->physicalDimensions=" + ptrToString((void**)std::addressof(pProperties->physicalDimensions)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->physicalResolution=" + ptrToString((void**)std::addressof(pProperties->physicalResolution)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->supportedTransforms=" + ptrToString((void**)std::addressof(pProperties->supportedTransforms)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->planeReorderPossible=" + bool_as_text(pProperties->planeReorderPossible) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->persistentContent=" + bool_as_text(pProperties->persistentContent) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPropertiesKHR_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceDisplayPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceDisplayPlanePropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPlanePropertiesKHR_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->currentDisplay=" + ptrToString((void**)std::addressof(pProperties->currentDisplay)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->currentStackIndex=" + std::to_string(pProperties->currentStackIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPLANEPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPlanePropertiesKHR_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceDisplayPlanePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDisplayPlaneSupportedDisplaysKHR!");
}
#ifdef GETDISPLAYPLANESUPPORTEDDISPLAYSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneSupportedDisplaysKHR_before(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"planeIndex=" + std::to_string(planeIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDisplays=" + ptrToString((void**)std::addressof(pDisplays)) + '!');
}
#ifdef GETDISPLAYPLANESUPPORTEDDISPLAYSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneSupportedDisplaysKHR_after(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDisplayPlaneSupportedDisplaysKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDisplayModePropertiesKHR!");
}
#ifdef GETDISPLAYMODEPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDisplayModePropertiesKHR_before(physicalDevice, display, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->displayMode=" + ptrToString((void**)std::addressof(pProperties->displayMode)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->parameters=" + ptrToString((void**)std::addressof(pProperties->parameters)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETDISPLAYMODEPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDisplayModePropertiesKHR_after(physicalDevice, display, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDisplayModePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, VkDisplayModeCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDisplayModeKHR!");
}
#ifdef CREATEDISPLAYMODEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDisplayModeKHR_before(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->parameters=" + ptrToString((void**)std::addressof(pCreateInfo->parameters)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pMode=" + ptrToString((void**)std::addressof(pMode)) + '!');
}
#ifdef CREATEDISPLAYMODEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDisplayModeKHR_after(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDisplayModeKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].CreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDisplayPlaneCapabilitiesKHR!");
}
#ifdef GETDISPLAYPLANECAPABILITIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneCapabilitiesKHR_before(physicalDevice, mode, planeIndex, pCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"mode=" + ptrToString((void**)std::addressof(mode)) + '!');
winsockSendToUI(&ConnectSocket,"planeIndex=" + std::to_string(planeIndex) + '!');
if(pCapabilities != VK_NULL_HANDLE && pCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pCapabilities->supportedAlpha=" + ptrToString((void**)std::addressof(pCapabilities->supportedAlpha)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minSrcPosition=" + ptrToString((void**)std::addressof(pCapabilities->minSrcPosition)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxSrcPosition=" + ptrToString((void**)std::addressof(pCapabilities->maxSrcPosition)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minSrcExtent=" + ptrToString((void**)std::addressof(pCapabilities->minSrcExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxSrcExtent=" + ptrToString((void**)std::addressof(pCapabilities->maxSrcExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minDstPosition=" + ptrToString((void**)std::addressof(pCapabilities->minDstPosition)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxDstPosition=" + ptrToString((void**)std::addressof(pCapabilities->maxDstPosition)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minDstExtent=" + ptrToString((void**)std::addressof(pCapabilities->minDstExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxDstExtent=" + ptrToString((void**)std::addressof(pCapabilities->maxDstExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETDISPLAYPLANECAPABILITIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneCapabilitiesKHR_after(physicalDevice, mode, planeIndex, pCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDisplayPlaneCapabilitiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDisplayPlaneSurfaceKHR(VkInstance instance, VkDisplaySurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDisplayPlaneSurfaceKHR!");
}
#ifdef CREATEDISPLAYPLANESURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDisplayPlaneSurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->displayMode=" + ptrToString((void**)std::addressof(pCreateInfo->displayMode)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->planeIndex=" + std::to_string(pCreateInfo->planeIndex) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->planeStackIndex=" + std::to_string(pCreateInfo->planeStackIndex) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->globalAlpha=" + std::to_string(pCreateInfo->globalAlpha) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->imageExtent=" + ptrToString((void**)std::addressof(pCreateInfo->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEDISPLAYPLANESURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDisplayPlaneSurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDisplayPlaneSurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySurfaceKHR!");
}
#ifdef DESTROYSURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySurfaceKHR_before(instance, surface, pAllocator);
}
#endif 
instance_dispatch[GetKey(instance)].DestroySurfaceKHR(instance, surface, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySurfaceKHR_after(instance, surface, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(instance)].DestroySurfaceKHR(instance, surface, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceSupportKHR!");
}
#ifdef GETPHYSICALDEVICESURFACESUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceSupportKHR_before(physicalDevice, queueFamilyIndex, surface, pSupported);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
winsockSendToUI(&ConnectSocket,"pSupported=" + ptrToString((void**)std::addressof(pSupported)) + '!');
}
#ifdef GETPHYSICALDEVICESURFACESUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceSupportKHR_after(physicalDevice, queueFamilyIndex, surface, pSupported);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceCapabilitiesKHR!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilitiesKHR_before(physicalDevice, surface, pSurfaceCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
if(pSurfaceCapabilities != VK_NULL_HANDLE && pSurfaceCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->minImageCount=" + std::to_string(pSurfaceCapabilities->minImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageCount=" + std::to_string(pSurfaceCapabilities->maxImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->currentExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->currentExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->minImageExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->minImageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->maxImageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageArrayLayers=" + std::to_string(pSurfaceCapabilities->maxImageArrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedTransforms=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedTransforms)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedCompositeAlpha=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedCompositeAlpha)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedUsageFlags=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedUsageFlags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilitiesKHR_after(physicalDevice, surface, pSurfaceCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceCapabilitiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceFormatsKHR!");
}
#ifdef GETPHYSICALDEVICESURFACEFORMATSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceFormatsKHR_before(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
if(pSurfaceFormats != VK_NULL_HANDLE && pSurfaceFormats != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSurfaceFormats=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESURFACEFORMATSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceFormatsKHR_after(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceFormatsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfacePresentModesKHR!");
}
#ifdef GETPHYSICALDEVICESURFACEPRESENTMODESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfacePresentModesKHR_before(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
winsockSendToUI(&ConnectSocket,"pPresentModes=" + ptrToString((void**)std::addressof(pPresentModes)) + '!');
}
#ifdef GETPHYSICALDEVICESURFACEPRESENTMODESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfacePresentModesKHR_after(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfacePresentModesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_VI_NN)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateViSurfaceNN(VkInstance instance, VkViSurfaceCreateInfoNN* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateViSurfaceNN!");
}
#ifdef CREATEVISURFACENN_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateViSurfaceNN_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEVISURFACENN_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateViSurfaceNN_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateViSurfaceNN!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateWaylandSurfaceKHR(VkInstance instance, VkWaylandSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateWaylandSurfaceKHR!");
}
#ifdef CREATEWAYLANDSURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateWaylandSurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->display=" + ptrToString((void**)std::addressof(pCreateInfo->display)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->surface=" + ptrToString((void**)std::addressof(pCreateInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEWAYLANDSURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateWaylandSurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateWaylandSurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, wl_display* display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceWaylandPresentationSupportKHR!");
}
#ifdef GETPHYSICALDEVICEWAYLANDPRESENTATIONSUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceWaylandPresentationSupportKHR_before(physicalDevice, queueFamilyIndex, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef GETPHYSICALDEVICEWAYLANDPRESENTATIONSUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceWaylandPresentationSupportKHR_after(physicalDevice, queueFamilyIndex, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceWaylandPresentationSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateWin32SurfaceKHR(VkInstance instance, VkWin32SurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateWin32SurfaceKHR!");
}
#ifdef CREATEWIN32SURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateWin32SurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->hinstance=" + ptrToString((void**)std::addressof(pCreateInfo->hinstance)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->hwnd=" + ptrToString((void**)std::addressof(pCreateInfo->hwnd)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEWIN32SURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateWin32SurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateWin32SurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceWin32PresentationSupportKHR!");
}
#ifdef GETPHYSICALDEVICEWIN32PRESENTATIONSUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceWin32PresentationSupportKHR_before(physicalDevice, queueFamilyIndex);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
}
#ifdef GETPHYSICALDEVICEWIN32PRESENTATIONSUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceWin32PresentationSupportKHR_after(physicalDevice, queueFamilyIndex);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceWin32PresentationSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateXlibSurfaceKHR(VkInstance instance, VkXlibSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateXlibSurfaceKHR!");
}
#ifdef CREATEXLIBSURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateXlibSurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->dpy=" + ptrToString((void**)std::addressof(pCreateInfo->dpy)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->window=" + ptrToString((void**)std::addressof(pCreateInfo->window)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEXLIBSURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateXlibSurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateXlibSurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceXlibPresentationSupportKHR!");
}
#ifdef GETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceXlibPresentationSupportKHR_before(physicalDevice, queueFamilyIndex, dpy, visualID);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"dpy=" + ptrToString((void**)std::addressof(dpy)) + '!');
winsockSendToUI(&ConnectSocket,"visualID=" + ptrToString((void**)std::addressof(visualID)) + '!');
}
#ifdef GETPHYSICALDEVICEXLIBPRESENTATIONSUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceXlibPresentationSupportKHR_after(physicalDevice, queueFamilyIndex, dpy, visualID);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceXlibPresentationSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateXcbSurfaceKHR(VkInstance instance, VkXcbSurfaceCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateXcbSurfaceKHR!");
}
#ifdef CREATEXCBSURFACEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateXcbSurfaceKHR_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->connection=" + ptrToString((void**)std::addressof(pCreateInfo->connection)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->window=" + ptrToString((void**)std::addressof(pCreateInfo->window)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEXCBSURFACEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateXcbSurfaceKHR_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateXcbSurfaceKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceXcbPresentationSupportKHR!");
}
#ifdef GETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceXcbPresentationSupportKHR_before(physicalDevice, queueFamilyIndex, connection, visual_id);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"connection=" + ptrToString((void**)std::addressof(connection)) + '!');
winsockSendToUI(&ConnectSocket,"visual_id=" + ptrToString((void**)std::addressof(visual_id)) + '!');
}
#ifdef GETPHYSICALDEVICEXCBPRESENTATIONSUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceXcbPresentationSupportKHR_after(physicalDevice, queueFamilyIndex, connection, visual_id);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceXcbPresentationSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDirectFBSurfaceEXT(VkInstance instance, VkDirectFBSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDirectFBSurfaceEXT!");
}
#ifdef CREATEDIRECTFBSURFACEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDirectFBSurfaceEXT_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->dfb=" + ptrToString((void**)std::addressof(pCreateInfo->dfb)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->surface=" + ptrToString((void**)std::addressof(pCreateInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEDIRECTFBSURFACEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDirectFBSurfaceEXT_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDirectFBSurfaceEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB* dfb) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceDirectFBPresentationSupportEXT!");
}
#ifdef GETPHYSICALDEVICEDIRECTFBPRESENTATIONSUPPORTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDirectFBPresentationSupportEXT_before(physicalDevice, queueFamilyIndex, dfb);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"dfb=" + ptrToString((void**)std::addressof(dfb)) + '!');
}
#ifdef GETPHYSICALDEVICEDIRECTFBPRESENTATIONSUPPORTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDirectFBPresentationSupportEXT_after(physicalDevice, queueFamilyIndex, dfb);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceDirectFBPresentationSupportEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateImagePipeSurfaceFUCHSIA(VkInstance instance, VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateImagePipeSurfaceFUCHSIA!");
}
#ifdef CREATEIMAGEPIPESURFACEFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateImagePipeSurfaceFUCHSIA_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->imagePipeHandle=" + ptrToString((void**)std::addressof(pCreateInfo->imagePipeHandle)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEIMAGEPIPESURFACEFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateImagePipeSurfaceFUCHSIA_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateImagePipeSurfaceFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_GGP)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateStreamDescriptorSurfaceGGP(VkInstance instance, VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateStreamDescriptorSurfaceGGP!");
}
#ifdef CREATESTREAMDESCRIPTORSURFACEGGP_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateStreamDescriptorSurfaceGGP_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->streamDescriptor=" + ptrToString((void**)std::addressof(pCreateInfo->streamDescriptor)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATESTREAMDESCRIPTORSURFACEGGP_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateStreamDescriptorSurfaceGGP_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateStreamDescriptorSurfaceGGP!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateScreenSurfaceQNX(VkInstance instance, VkScreenSurfaceCreateInfoQNX* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateScreenSurfaceQNX!");
}
#ifdef CREATESCREENSURFACEQNX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateScreenSurfaceQNX_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->context=" + ptrToString((void**)std::addressof(pCreateInfo->context)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->window=" + ptrToString((void**)std::addressof(pCreateInfo->window)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATESCREENSURFACEQNX_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateScreenSurfaceQNX_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateScreenSurfaceQNX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
 VK_LAYER_EXPORT VkBool32 VKAPI_CALL DebuggerLayer_GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, _screen_window* window) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceScreenPresentationSupportQNX!");
}
#ifdef GETPHYSICALDEVICESCREENPRESENTATIONSUPPORTQNX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceScreenPresentationSupportQNX_before(physicalDevice, queueFamilyIndex, window);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"window=" + ptrToString((void**)std::addressof(window)) + '!');
}
#ifdef GETPHYSICALDEVICESCREENPRESENTATIONSUPPORTQNX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceScreenPresentationSupportQNX_after(physicalDevice, queueFamilyIndex, window);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceScreenPresentationSupportQNX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDebugReportCallbackEXT!");
}
#ifdef CREATEDEBUGREPORTCALLBACKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDebugReportCallbackEXT_before(instance, pCreateInfo, pAllocator, pCallback);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pfnCallback=" + ptrToString((void**)std::addressof(pCreateInfo->pfnCallback)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCallback=" + ptrToString((void**)std::addressof(pCallback)) + '!');
}
#ifdef CREATEDEBUGREPORTCALLBACKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDebugReportCallbackEXT_after(instance, pCreateInfo, pAllocator, pCallback);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDebugReportCallbackEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDebugReportCallbackEXT!");
}
#ifdef DESTROYDEBUGREPORTCALLBACKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDebugReportCallbackEXT_before(instance, callback, pAllocator);
}
#endif 
instance_dispatch[GetKey(instance)].DestroyDebugReportCallbackEXT(instance, callback, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"callback=" + ptrToString((void**)std::addressof(callback)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDEBUGREPORTCALLBACKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDebugReportCallbackEXT_after(instance, callback, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDebugReportCallbackEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(instance)].DestroyDebugReportCallbackEXT(instance, callback, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, char* pLayerPrefix, char* pMessage) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDebugReportMessageEXT!");
}
#ifdef DEBUGREPORTMESSAGEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DebugReportMessageEXT_before(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
#endif 
instance_dispatch[GetKey(instance)].DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
winsockSendToUI(&ConnectSocket,"object=" + std::to_string(object) + '!');
winsockSendToUI(&ConnectSocket,"location=" + std::to_string(location) + '!');
winsockSendToUI(&ConnectSocket,"messageCode=" + std::to_string(messageCode) + '!');
}
#ifdef DEBUGREPORTMESSAGEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DebugReportMessageEXT_after(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDebugReportMessageEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(instance)].DebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalImageFormatPropertiesNV!");
}
#ifdef GETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalImageFormatPropertiesNV_before(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"usage=" + ptrToString((void**)std::addressof(usage)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
winsockSendToUI(&ConnectSocket,"externalHandleType=" + ptrToString((void**)std::addressof(externalHandleType)) + '!');
if(pExternalImageFormatProperties != VK_NULL_HANDLE && pExternalImageFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalImageFormatProperties->imageFormatProperties=" + ptrToString((void**)std::addressof(pExternalImageFormatProperties->imageFormatProperties)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalImageFormatProperties->externalMemoryFeatures=" + ptrToString((void**)std::addressof(pExternalImageFormatProperties->externalMemoryFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalImageFormatProperties->exportFromImportedHandleTypes=" + ptrToString((void**)std::addressof(pExternalImageFormatProperties->exportFromImportedHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalImageFormatProperties->compatibleHandleTypes=" + ptrToString((void**)std::addressof(pExternalImageFormatProperties->compatibleHandleTypes)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalImageFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALIMAGEFORMATPROPERTIESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalImageFormatPropertiesNV_after(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalImageFormatPropertiesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFeatures2!");
}
#ifdef GETPHYSICALDEVICEFEATURES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures2_before(physicalDevice, pFeatures);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFeatures != VK_NULL_HANDLE && pFeatures != NULL) {
winsockSendToUI(&ConnectSocket,"pFeatures->features=" + ptrToString((void**)std::addressof(pFeatures->features)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFeatures=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFEATURES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures2_after(physicalDevice, pFeatures);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFeatures2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceProperties2!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties2_before(physicalDevice, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties2(physicalDevice, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->properties=" + ptrToString((void**)std::addressof(pProperties->properties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties2_after(physicalDevice, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties2(physicalDevice, pProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFormatProperties2!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties2_before(physicalDevice, format, pFormatProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFormatProperties != VK_NULL_HANDLE && pFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pFormatProperties->formatProperties=" + ptrToString((void**)std::addressof(pFormatProperties->formatProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties2_after(physicalDevice, format, pFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFormatProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceImageFormatProperties2!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties2_before(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pImageFormatInfo != VK_NULL_HANDLE && pImageFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImageFormatInfo->usage=" + ptrToString((void**)std::addressof(pImageFormatInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatInfo->flags=" + ptrToString((void**)std::addressof(pImageFormatInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageFormatInfo=VK_NULL_HANDLE!");
if(pImageFormatProperties != VK_NULL_HANDLE && pImageFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->imageFormatProperties=" + ptrToString((void**)std::addressof(pImageFormatProperties->imageFormatProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties2_after(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceImageFormatProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceQueueFamilyProperties2!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties2_before(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pQueueFamilyProperties != VK_NULL_HANDLE && pQueueFamilyProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->queueFamilyProperties=" + ptrToString((void**)std::addressof(pQueueFamilyProperties->queueFamilyProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pQueueFamilyProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties2_after(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceQueueFamilyProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceMemoryProperties2!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties2_before(physicalDevice, pMemoryProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pMemoryProperties != VK_NULL_HANDLE && pMemoryProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryProperties->memoryProperties=" + ptrToString((void**)std::addressof(pMemoryProperties->memoryProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties2_after(physicalDevice, pMemoryProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceMemoryProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSparseImageFormatProperties2!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties2_before(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFormatInfo != VK_NULL_HANDLE && pFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pFormatInfo->usage=" + ptrToString((void**)std::addressof(pFormatInfo->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFormatInfo=VK_NULL_HANDLE!");
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->properties=" + ptrToString((void**)std::addressof(pProperties->properties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties2_after(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSparseImageFormatProperties2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalBufferProperties!");
}
#ifdef GETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalBufferProperties_before(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalBufferInfo != VK_NULL_HANDLE && pExternalBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalBufferInfo->flags=" + ptrToString((void**)std::addressof(pExternalBufferInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalBufferInfo->usage=" + ptrToString((void**)std::addressof(pExternalBufferInfo->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalBufferInfo=VK_NULL_HANDLE!");
if(pExternalBufferProperties != VK_NULL_HANDLE && pExternalBufferProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalBufferProperties->externalMemoryProperties=" + ptrToString((void**)std::addressof(pExternalBufferProperties->externalMemoryProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalBufferProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALBUFFERPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalBufferProperties_after(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalBufferProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
}

#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalMemorySciBufPropertiesNV(VkPhysicalDevice physicalDevice, VkExternalMemoryHandleTypeFlagBits handleType, NvSciBufObj handle, VkMemorySciBufPropertiesNV* pMemorySciBufProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV!");
}
#ifdef GETPHYSICALDEVICEEXTERNALMEMORYSCIBUFPROPERTIESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalMemorySciBufPropertiesNV_before(physicalDevice, handleType, handle, pMemorySciBufProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalMemorySciBufPropertiesNV(physicalDevice, handleType, handle, pMemorySciBufProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"handle=" + ptrToString((void**)std::addressof(handle)) + '!');
if(pMemorySciBufProperties != VK_NULL_HANDLE && pMemorySciBufProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemorySciBufProperties->memoryTypeBits=" + std::to_string(pMemorySciBufProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemorySciBufProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALMEMORYSCIBUFPROPERTIESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalMemorySciBufPropertiesNV_after(physicalDevice, handleType, handle, pMemorySciBufProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalMemorySciBufPropertiesNV(physicalDevice, handleType, handle, pMemorySciBufProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSciBufAttributesNV(VkPhysicalDevice physicalDevice, NvSciBufAttrList pAttributes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSciBufAttributesNV!");
}
#ifdef GETPHYSICALDEVICESCIBUFATTRIBUTESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSciBufAttributesNV_before(physicalDevice, pAttributes);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSciBufAttributesNV(physicalDevice, pAttributes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"pAttributes=" + ptrToString((void**)std::addressof(pAttributes)) + '!');
}
#ifdef GETPHYSICALDEVICESCIBUFATTRIBUTESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSciBufAttributesNV_after(physicalDevice, pAttributes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSciBufAttributesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSciBufAttributesNV(physicalDevice, pAttributes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalSemaphoreProperties!");
}
#ifdef GETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalSemaphoreProperties_before(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalSemaphoreInfo != VK_NULL_HANDLE && pExternalSemaphoreInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pExternalSemaphoreInfo=VK_NULL_HANDLE!");
if(pExternalSemaphoreProperties != VK_NULL_HANDLE && pExternalSemaphoreProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->exportFromImportedHandleTypes=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->exportFromImportedHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->compatibleHandleTypes=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->compatibleHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->externalSemaphoreFeatures=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->externalSemaphoreFeatures)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalSemaphoreProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalSemaphoreProperties_after(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalSemaphoreProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalFenceProperties!");
}
#ifdef GETPHYSICALDEVICEEXTERNALFENCEPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalFenceProperties_before(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalFenceInfo != VK_NULL_HANDLE && pExternalFenceInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pExternalFenceInfo=VK_NULL_HANDLE!");
if(pExternalFenceProperties != VK_NULL_HANDLE && pExternalFenceProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->exportFromImportedHandleTypes=" + ptrToString((void**)std::addressof(pExternalFenceProperties->exportFromImportedHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->compatibleHandleTypes=" + ptrToString((void**)std::addressof(pExternalFenceProperties->compatibleHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->externalFenceFeatures=" + ptrToString((void**)std::addressof(pExternalFenceProperties->externalFenceFeatures)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalFenceProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALFENCEPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalFenceProperties_after(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalFenceProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
}

#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSciSyncAttributesNV(VkPhysicalDevice physicalDevice, VkSciSyncAttributesInfoNV* pSciSyncAttributesInfo, NvSciSyncAttrList pAttributes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSciSyncAttributesNV!");
}
#ifdef GETPHYSICALDEVICESCISYNCATTRIBUTESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSciSyncAttributesNV_before(physicalDevice, pSciSyncAttributesInfo, pAttributes);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSciSyncAttributesNV(physicalDevice, pSciSyncAttributesInfo, pAttributes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pSciSyncAttributesInfo != VK_NULL_HANDLE && pSciSyncAttributesInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSciSyncAttributesInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pAttributes=" + ptrToString((void**)std::addressof(pAttributes)) + '!');
}
#ifdef GETPHYSICALDEVICESCISYNCATTRIBUTESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSciSyncAttributesNV_after(physicalDevice, pSciSyncAttributesInfo, pAttributes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSciSyncAttributesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSciSyncAttributesNV(physicalDevice, pSciSyncAttributesInfo, pAttributes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkReleaseDisplayEXT!");
}
#ifdef RELEASEDISPLAYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ReleaseDisplayEXT_before(physicalDevice, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].ReleaseDisplayEXT(physicalDevice, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef RELEASEDISPLAYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_ReleaseDisplayEXT_after(physicalDevice, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkReleaseDisplayEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].ReleaseDisplayEXT(physicalDevice, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireXlibDisplayEXT!");
}
#ifdef ACQUIREXLIBDISPLAYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireXlibDisplayEXT_before(physicalDevice, dpy, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireXlibDisplayEXT(physicalDevice, dpy, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"dpy=" + ptrToString((void**)std::addressof(dpy)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef ACQUIREXLIBDISPLAYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireXlibDisplayEXT_after(physicalDevice, dpy, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireXlibDisplayEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireXlibDisplayEXT(physicalDevice, dpy, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRandROutputDisplayEXT!");
}
#ifdef GETRANDROUTPUTDISPLAYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRandROutputDisplayEXT_before(physicalDevice, dpy, rrOutput, pDisplay);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"dpy=" + ptrToString((void**)std::addressof(dpy)) + '!');
winsockSendToUI(&ConnectSocket,"rrOutput=" + ptrToString((void**)std::addressof(rrOutput)) + '!');
winsockSendToUI(&ConnectSocket,"pDisplay=" + ptrToString((void**)std::addressof(pDisplay)) + '!');
}
#ifdef GETRANDROUTPUTDISPLAYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRandROutputDisplayEXT_after(physicalDevice, dpy, rrOutput, pDisplay);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRandROutputDisplayEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireWinrtDisplayNV!");
}
#ifdef ACQUIREWINRTDISPLAYNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireWinrtDisplayNV_before(physicalDevice, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireWinrtDisplayNV(physicalDevice, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef ACQUIREWINRTDISPLAYNV_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireWinrtDisplayNV_after(physicalDevice, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireWinrtDisplayNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireWinrtDisplayNV(physicalDevice, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR* pDisplay) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetWinrtDisplayNV!");
}
#ifdef GETWINRTDISPLAYNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetWinrtDisplayNV_before(physicalDevice, deviceRelativeId, pDisplay);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"deviceRelativeId=" + std::to_string(deviceRelativeId) + '!');
winsockSendToUI(&ConnectSocket,"pDisplay=" + ptrToString((void**)std::addressof(pDisplay)) + '!');
}
#ifdef GETWINRTDISPLAYNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetWinrtDisplayNV_after(physicalDevice, deviceRelativeId, pDisplay);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetWinrtDisplayNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceCapabilities2EXT!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIES2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilities2EXT_before(physicalDevice, surface, pSurfaceCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
if(pSurfaceCapabilities != VK_NULL_HANDLE && pSurfaceCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->minImageCount=" + std::to_string(pSurfaceCapabilities->minImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageCount=" + std::to_string(pSurfaceCapabilities->maxImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->currentExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->currentExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->minImageExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->minImageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageExtent=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->maxImageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->maxImageArrayLayers=" + std::to_string(pSurfaceCapabilities->maxImageArrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedTransforms=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedTransforms)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedCompositeAlpha=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedCompositeAlpha)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedUsageFlags=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedUsageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->supportedSurfaceCounters=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->supportedSurfaceCounters)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIES2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilities2EXT_after(physicalDevice, surface, pSurfaceCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceCapabilities2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkEnumeratePhysicalDeviceGroups!");
}
#ifdef ENUMERATEPHYSICALDEVICEGROUPS_BEFORE_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceGroups_before(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pPhysicalDeviceGroupProperties != VK_NULL_HANDLE && pPhysicalDeviceGroupProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pPhysicalDeviceGroupProperties->physicalDeviceCount=" + std::to_string(pPhysicalDeviceGroupProperties->physicalDeviceCount) + '!');
winsockSendToUI(&ConnectSocket,"pPhysicalDeviceGroupProperties->subsetAllocation=" + bool_as_text(pPhysicalDeviceGroupProperties->subsetAllocation) + '!');
}else winsockSendToUI(&ConnectSocket, "pPhysicalDeviceGroupProperties=VK_NULL_HANDLE!");
}
#ifdef ENUMERATEPHYSICALDEVICEGROUPS_AFTER_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceGroups_after(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkEnumeratePhysicalDeviceGroups!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDevicePresentRectanglesKHR!");
}
#ifdef GETPHYSICALDEVICEPRESENTRECTANGLESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDevicePresentRectanglesKHR_before(physicalDevice, surface, pRectCount, pRects);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
if(pRects != VK_NULL_HANDLE && pRects != NULL) {
winsockSendToUI(&ConnectSocket,"pRects->offset=" + ptrToString((void**)std::addressof(pRects->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pRects->extent=" + ptrToString((void**)std::addressof(pRects->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRects=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEPRESENTRECTANGLESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDevicePresentRectanglesKHR_after(physicalDevice, surface, pRectCount, pRects);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDevicePresentRectanglesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_IOS_MVK)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateIOSSurfaceMVK(VkInstance instance, VkIOSSurfaceCreateInfoMVK* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateIOSSurfaceMVK!");
}
#ifdef CREATEIOSSURFACEMVK_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateIOSSurfaceMVK_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEIOSSURFACEMVK_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateIOSSurfaceMVK_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateIOSSurfaceMVK!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateMacOSSurfaceMVK(VkInstance instance, VkMacOSSurfaceCreateInfoMVK* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateMacOSSurfaceMVK!");
}
#ifdef CREATEMACOSSURFACEMVK_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateMacOSSurfaceMVK_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEMACOSSURFACEMVK_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateMacOSSurfaceMVK_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateMacOSSurfaceMVK!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateMetalSurfaceEXT(VkInstance instance, VkMetalSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateMetalSurfaceEXT!");
}
#ifdef CREATEMETALSURFACEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateMetalSurfaceEXT_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pLayer=" + ptrToString((void**)std::addressof(pCreateInfo->pLayer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEMETALSURFACEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateMetalSurfaceEXT_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateMetalSurfaceEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceMultisamplePropertiesEXT!");
}
#ifdef GETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMultisamplePropertiesEXT_before(physicalDevice, samples, pMultisampleProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pMultisampleProperties != VK_NULL_HANDLE && pMultisampleProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMultisampleProperties->maxSampleLocationGridSize=" + ptrToString((void**)std::addressof(pMultisampleProperties->maxSampleLocationGridSize)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMultisampleProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEMULTISAMPLEPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMultisamplePropertiesEXT_after(physicalDevice, samples, pMultisampleProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceMultisamplePropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceCapabilities2KHR!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilities2KHR_before(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pSurfaceInfo != VK_NULL_HANDLE && pSurfaceInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceInfo->surface=" + ptrToString((void**)std::addressof(pSurfaceInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceInfo=VK_NULL_HANDLE!");
if(pSurfaceCapabilities != VK_NULL_HANDLE && pSurfaceCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceCapabilities->surfaceCapabilities=" + ptrToString((void**)std::addressof(pSurfaceCapabilities->surfaceCapabilities)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESURFACECAPABILITIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceCapabilities2KHR_after(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceCapabilities2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfaceFormats2KHR!");
}
#ifdef GETPHYSICALDEVICESURFACEFORMATS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceFormats2KHR_before(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pSurfaceInfo != VK_NULL_HANDLE && pSurfaceInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceInfo->surface=" + ptrToString((void**)std::addressof(pSurfaceInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceInfo=VK_NULL_HANDLE!");
if(pSurfaceFormats != VK_NULL_HANDLE && pSurfaceFormats != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceFormats->surfaceFormat=" + ptrToString((void**)std::addressof(pSurfaceFormats->surfaceFormat)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceFormats=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESURFACEFORMATS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfaceFormats2KHR_after(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfaceFormats2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceDisplayProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayProperties2KHR_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->displayProperties=" + ptrToString((void**)std::addressof(pProperties->displayProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayProperties2KHR_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceDisplayProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceDisplayPlaneProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPlaneProperties2KHR_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->displayPlaneProperties=" + ptrToString((void**)std::addressof(pProperties->displayPlaneProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEDISPLAYPLANEPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceDisplayPlaneProperties2KHR_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceDisplayPlaneProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDisplayModeProperties2KHR!");
}
#ifdef GETDISPLAYMODEPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDisplayModeProperties2KHR_before(physicalDevice, display, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->displayModeProperties=" + ptrToString((void**)std::addressof(pProperties->displayModeProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETDISPLAYMODEPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDisplayModeProperties2KHR_after(physicalDevice, display, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDisplayModeProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDisplayPlaneCapabilities2KHR!");
}
#ifdef GETDISPLAYPLANECAPABILITIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneCapabilities2KHR_before(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pDisplayPlaneInfo != VK_NULL_HANDLE && pDisplayPlaneInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDisplayPlaneInfo->mode=" + ptrToString((void**)std::addressof(pDisplayPlaneInfo->mode)) + '!');
winsockSendToUI(&ConnectSocket,"pDisplayPlaneInfo->planeIndex=" + std::to_string(pDisplayPlaneInfo->planeIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pDisplayPlaneInfo=VK_NULL_HANDLE!");
if(pCapabilities != VK_NULL_HANDLE && pCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pCapabilities->capabilities=" + ptrToString((void**)std::addressof(pCapabilities->capabilities)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETDISPLAYPLANECAPABILITIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDisplayPlaneCapabilities2KHR_after(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDisplayPlaneCapabilities2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR!");
}
#ifdef GETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCalibrateableTimeDomainsKHR_before(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"pTimeDomains=" + ptrToString((void**)std::addressof(pTimeDomains)) + '!');
}
#ifdef GETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCalibrateableTimeDomainsKHR_after(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDebugUtilsMessengerEXT!");
}
#ifdef CREATEDEBUGUTILSMESSENGEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDebugUtilsMessengerEXT_before(instance, pCreateInfo, pAllocator, pMessenger);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->messageSeverity=" + ptrToString((void**)std::addressof(pCreateInfo->messageSeverity)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->messageType=" + ptrToString((void**)std::addressof(pCreateInfo->messageType)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pfnUserCallback=" + ptrToString((void**)std::addressof(pCreateInfo->pfnUserCallback)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pMessenger=" + ptrToString((void**)std::addressof(pMessenger)) + '!');
}
#ifdef CREATEDEBUGUTILSMESSENGEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDebugUtilsMessengerEXT_after(instance, pCreateInfo, pAllocator, pMessenger);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDebugUtilsMessengerEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDebugUtilsMessengerEXT!");
}
#ifdef DESTROYDEBUGUTILSMESSENGEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDebugUtilsMessengerEXT_before(instance, messenger, pAllocator);
}
#endif 
instance_dispatch[GetKey(instance)].DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"messenger=" + ptrToString((void**)std::addressof(messenger)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDEBUGUTILSMESSENGEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDebugUtilsMessengerEXT_after(instance, messenger, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDebugUtilsMessengerEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(instance)].DestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSubmitDebugUtilsMessageEXT!");
}
#ifdef SUBMITDEBUGUTILSMESSAGEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SubmitDebugUtilsMessageEXT_before(instance, messageSeverity, messageTypes, pCallbackData);
}
#endif 
instance_dispatch[GetKey(instance)].SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
winsockSendToUI(&ConnectSocket,"messageTypes=" + ptrToString((void**)std::addressof(messageTypes)) + '!');
if(pCallbackData != VK_NULL_HANDLE && pCallbackData != NULL) {
winsockSendToUI(&ConnectSocket,"pCallbackData->flags=" + ptrToString((void**)std::addressof(pCallbackData->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCallbackData->messageIdNumber=" + std::to_string(pCallbackData->messageIdNumber) + '!');
winsockSendToUI(&ConnectSocket,"pCallbackData->queueLabelCount=" + std::to_string(pCallbackData->queueLabelCount) + '!');
if(pCallbackData->pQueueLabels != VK_NULL_HANDLE && pCallbackData->pQueueLabels != NULL) {
}else winsockSendToUI(&ConnectSocket, "pQueueLabels=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCallbackData->cmdBufLabelCount=" + std::to_string(pCallbackData->cmdBufLabelCount) + '!');
if(pCallbackData->pCmdBufLabels != VK_NULL_HANDLE && pCallbackData->pCmdBufLabels != NULL) {
}else winsockSendToUI(&ConnectSocket, "pCmdBufLabels=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCallbackData->objectCount=" + std::to_string(pCallbackData->objectCount) + '!');
if(pCallbackData->pObjects != VK_NULL_HANDLE && pCallbackData->pObjects != NULL) {
winsockSendToUI(&ConnectSocket,"pCallbackData->pObjects->objectHandle=" + std::to_string(pCallbackData->pObjects->objectHandle) + '!');
}else winsockSendToUI(&ConnectSocket, "pObjects=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCallbackData=VK_NULL_HANDLE!");
}
#ifdef SUBMITDEBUGUTILSMESSAGEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SubmitDebugUtilsMessageEXT_after(instance, messageSeverity, messageTypes, pCallbackData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSubmitDebugUtilsMessageEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(instance)].SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV!");
}
#ifdef GETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCooperativeMatrixPropertiesNV_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->MSize=" + std::to_string(pProperties->MSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->NSize=" + std::to_string(pProperties->NSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->KSize=" + std::to_string(pProperties->KSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->AType=" + ptrToString((void**)std::addressof(pProperties->AType)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->BType=" + ptrToString((void**)std::addressof(pProperties->BType)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->CType=" + ptrToString((void**)std::addressof(pProperties->CType)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->DType=" + ptrToString((void**)std::addressof(pProperties->DType)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->scope=" + ptrToString((void**)std::addressof(pProperties->scope)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCooperativeMatrixPropertiesNV_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSurfacePresentModes2EXT!");
}
#ifdef GETPHYSICALDEVICESURFACEPRESENTMODES2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfacePresentModes2EXT_before(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pSurfaceInfo != VK_NULL_HANDLE && pSurfaceInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceInfo->surface=" + ptrToString((void**)std::addressof(pSurfaceInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPresentModes=" + ptrToString((void**)std::addressof(pPresentModes)) + '!');
}
#ifdef GETPHYSICALDEVICESURFACEPRESENTMODES2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSurfacePresentModes2EXT_after(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSurfacePresentModes2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR!");
}
#ifdef ENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_before(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
if(pCounters != VK_NULL_HANDLE && pCounters != NULL) {
}else winsockSendToUI(&ConnectSocket, "pCounters=VK_NULL_HANDLE!");
if(pCounterDescriptions != VK_NULL_HANDLE && pCounterDescriptions != NULL) {
winsockSendToUI(&ConnectSocket,"pCounterDescriptions->flags=" + ptrToString((void**)std::addressof(pCounterDescriptions->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCounterDescriptions=VK_NULL_HANDLE!");
}
#ifdef ENUMERATEPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYCOUNTERSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR_after(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, VkQueryPoolPerformanceCreateInfoKHR* pPerformanceQueryCreateInfo, uint32_t* pNumPasses) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR_before(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pPerformanceQueryCreateInfo != VK_NULL_HANDLE && pPerformanceQueryCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPerformanceQueryCreateInfo->queueFamilyIndex=" + std::to_string(pPerformanceQueryCreateInfo->queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pPerformanceQueryCreateInfo->counterIndexCount=" + std::to_string(pPerformanceQueryCreateInfo->counterIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pPerformanceQueryCreateInfo=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPERFORMANCEQUERYPASSESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR_after(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateHeadlessSurfaceEXT(VkInstance instance, VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateHeadlessSurfaceEXT!");
}
#ifdef CREATEHEADLESSSURFACEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateHeadlessSurfaceEXT_before(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSurface=" + ptrToString((void**)std::addressof(pSurface)) + '!');
}
#ifdef CREATEHEADLESSSURFACEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateHeadlessSurfaceEXT_after(instance, pCreateInfo, pAllocator, pSurface);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateHeadlessSurfaceEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].CreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV!");
}
#ifdef GETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_before(physicalDevice, pCombinationCount, pCombinations);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pCombinations != VK_NULL_HANDLE && pCombinations != NULL) {
winsockSendToUI(&ConnectSocket,"pCombinations->depthStencilSamples=" + ptrToString((void**)std::addressof(pCombinations->depthStencilSamples)) + '!');
winsockSendToUI(&ConnectSocket,"pCombinations->colorSamples=" + ptrToString((void**)std::addressof(pCombinations->colorSamples)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCombinations=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESUPPORTEDFRAMEBUFFERMIXEDSAMPLESCOMBINATIONSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV_after(physicalDevice, pCombinationCount, pCombinations);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceToolProperties!");
}
#ifdef GETPHYSICALDEVICETOOLPROPERTIES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceToolProperties_before(physicalDevice, pToolCount, pToolProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pToolProperties != VK_NULL_HANDLE && pToolProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pToolProperties->purposes=" + ptrToString((void**)std::addressof(pToolProperties->purposes)) + '!');
}else winsockSendToUI(&ConnectSocket, "pToolProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICETOOLPROPERTIES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceToolProperties_after(physicalDevice, pToolCount, pToolProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceToolProperties!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t* pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFragmentShadingRatesKHR!");
}
#ifdef GETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFragmentShadingRatesKHR_before(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFragmentShadingRates != VK_NULL_HANDLE && pFragmentShadingRates != NULL) {
winsockSendToUI(&ConnectSocket,"pFragmentShadingRates->sampleCounts=" + ptrToString((void**)std::addressof(pFragmentShadingRates->sampleCounts)) + '!');
winsockSendToUI(&ConnectSocket,"pFragmentShadingRates->fragmentSize=" + ptrToString((void**)std::addressof(pFragmentShadingRates->fragmentSize)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFragmentShadingRates=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFRAGMENTSHADINGRATESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFragmentShadingRatesKHR_after(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFragmentShadingRatesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkVideoProfileInfoKHR* pVideoProfile, VkVideoCapabilitiesKHR* pCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceVideoCapabilitiesKHR!");
}
#ifdef GETPHYSICALDEVICEVIDEOCAPABILITIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoCapabilitiesKHR_before(physicalDevice, pVideoProfile, pCapabilities);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pVideoProfile != VK_NULL_HANDLE && pVideoProfile != NULL) {
winsockSendToUI(&ConnectSocket,"pVideoProfile->chromaSubsampling=" + ptrToString((void**)std::addressof(pVideoProfile->chromaSubsampling)) + '!');
winsockSendToUI(&ConnectSocket,"pVideoProfile->lumaBitDepth=" + ptrToString((void**)std::addressof(pVideoProfile->lumaBitDepth)) + '!');
winsockSendToUI(&ConnectSocket,"pVideoProfile->chromaBitDepth=" + ptrToString((void**)std::addressof(pVideoProfile->chromaBitDepth)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoProfile=VK_NULL_HANDLE!");
if(pCapabilities != VK_NULL_HANDLE && pCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pCapabilities->flags=" + ptrToString((void**)std::addressof(pCapabilities->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minBitstreamBufferOffsetAlignment=" + std::to_string(pCapabilities->minBitstreamBufferOffsetAlignment) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minBitstreamBufferSizeAlignment=" + std::to_string(pCapabilities->minBitstreamBufferSizeAlignment) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->pictureAccessGranularity=" + ptrToString((void**)std::addressof(pCapabilities->pictureAccessGranularity)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->minCodedExtent=" + ptrToString((void**)std::addressof(pCapabilities->minCodedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxCodedExtent=" + ptrToString((void**)std::addressof(pCapabilities->maxCodedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxDpbSlots=" + std::to_string(pCapabilities->maxDpbSlots) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->maxActiveReferencePictures=" + std::to_string(pCapabilities->maxActiveReferencePictures) + '!');
winsockSendToUI(&ConnectSocket,"pCapabilities->stdHeaderVersion=" + ptrToString((void**)std::addressof(pCapabilities->stdHeaderVersion)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEVIDEOCAPABILITIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoCapabilitiesKHR_after(physicalDevice, pVideoProfile, pCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceVideoCapabilitiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceVideoFormatInfoKHR* pVideoFormatInfo, uint32_t* pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceVideoFormatPropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoFormatPropertiesKHR_before(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pVideoFormatInfo != VK_NULL_HANDLE && pVideoFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pVideoFormatInfo->imageUsage=" + ptrToString((void**)std::addressof(pVideoFormatInfo->imageUsage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoFormatInfo=VK_NULL_HANDLE!");
if(pVideoFormatProperties != VK_NULL_HANDLE && pVideoFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pVideoFormatProperties->componentMapping=" + ptrToString((void**)std::addressof(pVideoFormatProperties->componentMapping)) + '!');
winsockSendToUI(&ConnectSocket,"pVideoFormatProperties->imageCreateFlags=" + ptrToString((void**)std::addressof(pVideoFormatProperties->imageCreateFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pVideoFormatProperties->imageUsageFlags=" + ptrToString((void**)std::addressof(pVideoFormatProperties->imageUsageFlags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEVIDEOFORMATPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoFormatPropertiesKHR_after(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceVideoFormatPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR* pQualityLevelProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEVIDEOENCODEQUALITYLEVELPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR_before(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pQualityLevelInfo != VK_NULL_HANDLE && pQualityLevelInfo != NULL) {
if(pQualityLevelInfo->pVideoProfile != VK_NULL_HANDLE && pQualityLevelInfo->pVideoProfile != NULL) {
winsockSendToUI(&ConnectSocket,"pQualityLevelInfo->pVideoProfile->chromaSubsampling=" + ptrToString((void**)std::addressof(pQualityLevelInfo->pVideoProfile->chromaSubsampling)) + '!');
winsockSendToUI(&ConnectSocket,"pQualityLevelInfo->pVideoProfile->lumaBitDepth=" + ptrToString((void**)std::addressof(pQualityLevelInfo->pVideoProfile->lumaBitDepth)) + '!');
winsockSendToUI(&ConnectSocket,"pQualityLevelInfo->pVideoProfile->chromaBitDepth=" + ptrToString((void**)std::addressof(pQualityLevelInfo->pVideoProfile->chromaBitDepth)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoProfile=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pQualityLevelInfo->qualityLevel=" + std::to_string(pQualityLevelInfo->qualityLevel) + '!');
}else winsockSendToUI(&ConnectSocket, "pQualityLevelInfo=VK_NULL_HANDLE!");
if(pQualityLevelProperties != VK_NULL_HANDLE && pQualityLevelProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pQualityLevelProperties->preferredRateControlLayerCount=" + std::to_string(pQualityLevelProperties->preferredRateControlLayerCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pQualityLevelProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEVIDEOENCODEQUALITYLEVELPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR_after(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireDrmDisplayEXT!");
}
#ifdef ACQUIREDRMDISPLAYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireDrmDisplayEXT_before(physicalDevice, drmFd, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireDrmDisplayEXT(physicalDevice, drmFd, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"drmFd=" + std::to_string(drmFd) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef ACQUIREDRMDISPLAYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireDrmDisplayEXT_after(physicalDevice, drmFd, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireDrmDisplayEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].AcquireDrmDisplayEXT(physicalDevice, drmFd, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR* display) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDrmDisplayEXT!");
}
#ifdef GETDRMDISPLAYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDrmDisplayEXT_before(physicalDevice, drmFd, connectorId, display);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"drmFd=" + std::to_string(drmFd) + '!');
winsockSendToUI(&ConnectSocket,"connectorId=" + std::to_string(connectorId) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
}
#ifdef GETDRMDISPLAYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDrmDisplayEXT_after(physicalDevice, drmFd, connectorId, display);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDrmDisplayEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, VkOpticalFlowImageFormatInfoNV* pOpticalFlowImageFormatInfo, uint32_t* pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceOpticalFlowImageFormatsNV!");
}
#ifdef GETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceOpticalFlowImageFormatsNV_before(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pOpticalFlowImageFormatInfo != VK_NULL_HANDLE && pOpticalFlowImageFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pOpticalFlowImageFormatInfo->usage=" + ptrToString((void**)std::addressof(pOpticalFlowImageFormatInfo->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pOpticalFlowImageFormatInfo=VK_NULL_HANDLE!");
if(pImageFormatProperties != VK_NULL_HANDLE && pImageFormatProperties != NULL) {
}else winsockSendToUI(&ConnectSocket, "pImageFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEOPTICALFLOWIMAGEFORMATSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceOpticalFlowImageFormatsNV_after(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceOpticalFlowImageFormatsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR!");
}
#ifdef GETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCooperativeMatrixPropertiesKHR_before(physicalDevice, pPropertyCount, pProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->MSize=" + std::to_string(pProperties->MSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->NSize=" + std::to_string(pProperties->NSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->KSize=" + std::to_string(pProperties->KSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->saturatingAccumulation=" + bool_as_text(pProperties->saturatingAccumulation) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICECOOPERATIVEMATRIXPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCooperativeMatrixPropertiesKHR_after(physicalDevice, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFeatures2KHR!");
}
#ifdef GETPHYSICALDEVICEFEATURES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures2KHR_before(physicalDevice, pFeatures);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFeatures != VK_NULL_HANDLE && pFeatures != NULL) {
winsockSendToUI(&ConnectSocket,"pFeatures->features=" + ptrToString((void**)std::addressof(pFeatures->features)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFeatures=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFEATURES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFeatures2KHR_after(physicalDevice, pFeatures);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFeatures2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties2KHR_before(physicalDevice, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->properties=" + ptrToString((void**)std::addressof(pProperties->properties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceProperties2KHR_after(physicalDevice, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceFormatProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties2KHR_before(physicalDevice, format, pFormatProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFormatProperties != VK_NULL_HANDLE && pFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pFormatProperties->formatProperties=" + ptrToString((void**)std::addressof(pFormatProperties->formatProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEFORMATPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceFormatProperties2KHR_after(physicalDevice, format, pFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceFormatProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceImageFormatProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties2KHR_before(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pImageFormatInfo != VK_NULL_HANDLE && pImageFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImageFormatInfo->usage=" + ptrToString((void**)std::addressof(pImageFormatInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pImageFormatInfo->flags=" + ptrToString((void**)std::addressof(pImageFormatInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageFormatInfo=VK_NULL_HANDLE!");
if(pImageFormatProperties != VK_NULL_HANDLE && pImageFormatProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pImageFormatProperties->imageFormatProperties=" + ptrToString((void**)std::addressof(pImageFormatProperties->imageFormatProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageFormatProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEIMAGEFORMATPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceImageFormatProperties2KHR_after(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceImageFormatProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceQueueFamilyProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties2KHR_before(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pQueueFamilyProperties != VK_NULL_HANDLE && pQueueFamilyProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pQueueFamilyProperties->queueFamilyProperties=" + ptrToString((void**)std::addressof(pQueueFamilyProperties->queueFamilyProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pQueueFamilyProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEQUEUEFAMILYPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceQueueFamilyProperties2KHR_after(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceQueueFamilyProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceMemoryProperties2KHR!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties2KHR_before(physicalDevice, pMemoryProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pMemoryProperties != VK_NULL_HANDLE && pMemoryProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryProperties->memoryProperties=" + ptrToString((void**)std::addressof(pMemoryProperties->memoryProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEMEMORYPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceMemoryProperties2KHR_after(physicalDevice, pMemoryProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceMemoryProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceSparseImageFormatProperties2KHR!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties2KHR_before(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pFormatInfo != VK_NULL_HANDLE && pFormatInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pFormatInfo->usage=" + ptrToString((void**)std::addressof(pFormatInfo->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFormatInfo=VK_NULL_HANDLE!");
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->properties=" + ptrToString((void**)std::addressof(pProperties->properties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICESPARSEIMAGEFORMATPROPERTIES2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceSparseImageFormatProperties2KHR_after(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceSparseImageFormatProperties2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalBufferPropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEEXTERNALBUFFERPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalBufferPropertiesKHR_before(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalBufferInfo != VK_NULL_HANDLE && pExternalBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalBufferInfo->flags=" + ptrToString((void**)std::addressof(pExternalBufferInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalBufferInfo->usage=" + ptrToString((void**)std::addressof(pExternalBufferInfo->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalBufferInfo=VK_NULL_HANDLE!");
if(pExternalBufferProperties != VK_NULL_HANDLE && pExternalBufferProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalBufferProperties->externalMemoryProperties=" + ptrToString((void**)std::addressof(pExternalBufferProperties->externalMemoryProperties)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalBufferProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALBUFFERPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalBufferPropertiesKHR_after(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalBufferPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalSemaphorePropertiesKHR_before(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalSemaphoreInfo != VK_NULL_HANDLE && pExternalSemaphoreInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pExternalSemaphoreInfo=VK_NULL_HANDLE!");
if(pExternalSemaphoreProperties != VK_NULL_HANDLE && pExternalSemaphoreProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->exportFromImportedHandleTypes=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->exportFromImportedHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->compatibleHandleTypes=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->compatibleHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalSemaphoreProperties->externalSemaphoreFeatures=" + ptrToString((void**)std::addressof(pExternalSemaphoreProperties->externalSemaphoreFeatures)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalSemaphoreProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALSEMAPHOREPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalSemaphorePropertiesKHR_after(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceExternalFencePropertiesKHR!");
}
#ifdef GETPHYSICALDEVICEEXTERNALFENCEPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalFencePropertiesKHR_before(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif 
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pExternalFenceInfo != VK_NULL_HANDLE && pExternalFenceInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pExternalFenceInfo=VK_NULL_HANDLE!");
if(pExternalFenceProperties != VK_NULL_HANDLE && pExternalFenceProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->exportFromImportedHandleTypes=" + ptrToString((void**)std::addressof(pExternalFenceProperties->exportFromImportedHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->compatibleHandleTypes=" + ptrToString((void**)std::addressof(pExternalFenceProperties->compatibleHandleTypes)) + '!');
winsockSendToUI(&ConnectSocket,"pExternalFenceProperties->externalFenceFeatures=" + ptrToString((void**)std::addressof(pExternalFenceProperties->externalFenceFeatures)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExternalFenceProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICEEXTERNALFENCEPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceExternalFencePropertiesKHR_after(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceExternalFencePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkEnumeratePhysicalDeviceGroupsKHR!");
}
#ifdef ENUMERATEPHYSICALDEVICEGROUPSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceGroupsKHR_before(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"instance=" + ptrToString((void**)std::addressof(instance)) + '!');
if(pPhysicalDeviceGroupProperties != VK_NULL_HANDLE && pPhysicalDeviceGroupProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pPhysicalDeviceGroupProperties->physicalDeviceCount=" + std::to_string(pPhysicalDeviceGroupProperties->physicalDeviceCount) + '!');
winsockSendToUI(&ConnectSocket,"pPhysicalDeviceGroupProperties->subsetAllocation=" + bool_as_text(pPhysicalDeviceGroupProperties->subsetAllocation) + '!');
}else winsockSendToUI(&ConnectSocket, "pPhysicalDeviceGroupProperties=VK_NULL_HANDLE!");
}
#ifdef ENUMERATEPHYSICALDEVICEGROUPSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_EnumeratePhysicalDeviceGroupsKHR_after(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkEnumeratePhysicalDeviceGroupsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(instance)].EnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT!");
}
#ifdef GETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCalibrateableTimeDomainsEXT_before(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
winsockSendToUI(&ConnectSocket,"pTimeDomains=" + ptrToString((void**)std::addressof(pTimeDomains)) + '!');
}
#ifdef GETPHYSICALDEVICECALIBRATEABLETIMEDOMAINSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceCalibrateableTimeDomainsEXT_after(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t* pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPhysicalDeviceToolPropertiesEXT!");
}
#ifdef GETPHYSICALDEVICETOOLPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceToolPropertiesEXT_before(physicalDevice, pToolCount, pToolProperties);
}
#endif 
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"physicalDevice=" + ptrToString((void**)std::addressof(physicalDevice)) + '!');
if(pToolProperties != VK_NULL_HANDLE && pToolProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pToolProperties->purposes=" + ptrToString((void**)std::addressof(pToolProperties->purposes)) + '!');
}else winsockSendToUI(&ConnectSocket, "pToolProperties=VK_NULL_HANDLE!");
}
#ifdef GETPHYSICALDEVICETOOLPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPhysicalDeviceToolPropertiesEXT_after(physicalDevice, pToolCount, pToolProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPhysicalDeviceToolPropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = instance_dispatch[GetKey(physicalDevice)].GetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceQueue!");
}
#ifdef GETDEVICEQUEUE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceQueue_before(device, queueFamilyIndex, queueIndex, pQueue);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"queueFamilyIndex=" + std::to_string(queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"queueIndex=" + std::to_string(queueIndex) + '!');
winsockSendToUI(&ConnectSocket,"pQueue=" + ptrToString((void**)std::addressof(pQueue)) + '!');
}
#ifdef GETDEVICEQUEUE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceQueue_after(device, queueFamilyIndex, queueIndex, pQueue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceQueue!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueSubmit(VkQueue queue, uint32_t submitCount, VkSubmitInfo* pSubmits, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueSubmit!");
}
#ifdef QUEUESUBMIT_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueSubmit_before(queue, submitCount, pSubmits, fence);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueSubmit(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"submitCount=" + std::to_string(submitCount) + '!');
if(pSubmits != VK_NULL_HANDLE && pSubmits != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->waitSemaphoreCount=" + std::to_string(pSubmits->waitSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphores=" + ptrToString((void**)std::addressof(pSubmits->pWaitSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitDstStageMask=" + ptrToString((void**)std::addressof(pSubmits->pWaitDstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->commandBufferCount=" + std::to_string(pSubmits->commandBufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pCommandBuffers=" + ptrToString((void**)std::addressof(pSubmits->pCommandBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->signalSemaphoreCount=" + std::to_string(pSubmits->signalSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphores=" + ptrToString((void**)std::addressof(pSubmits->pSignalSemaphores)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubmits=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef QUEUESUBMIT_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueSubmit_after(queue, submitCount, pSubmits, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueSubmit!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueSubmit(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueWaitIdle(VkQueue queue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueWaitIdle!");
}
#ifdef QUEUEWAITIDLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueWaitIdle_before(queue);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueWaitIdle(queue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
}
#ifdef QUEUEWAITIDLE_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueWaitIdle_after(queue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueWaitIdle!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueWaitIdle(queue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_DeviceWaitIdle(VkDevice device) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDeviceWaitIdle!");
}
#ifdef DEVICEWAITIDLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DeviceWaitIdle_before(device);
}
#endif 
auto ret = device_dispatch[GetKey(device)].DeviceWaitIdle(device);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
}
#ifdef DEVICEWAITIDLE_AFTER_EXEC_EXISTS
if(connected) {
layer_DeviceWaitIdle_after(device);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDeviceWaitIdle!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].DeviceWaitIdle(device);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AllocateMemory(VkDevice device, VkMemoryAllocateInfo* pAllocateInfo, VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAllocateMemory!");
}
#ifdef ALLOCATEMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_AllocateMemory_before(device, pAllocateInfo, pAllocator, pMemory);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAllocateInfo != VK_NULL_HANDLE && pAllocateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocateInfo->allocationSize=" + std::to_string(pAllocateInfo->allocationSize) + '!');
winsockSendToUI(&ConnectSocket,"pAllocateInfo->memoryTypeIndex=" + std::to_string(pAllocateInfo->memoryTypeIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pMemory=" + ptrToString((void**)std::addressof(pMemory)) + '!');
}
#ifdef ALLOCATEMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_AllocateMemory_after(device, pAllocateInfo, pAllocator, pMemory);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAllocateMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_FreeMemory(VkDevice device, VkDeviceMemory memory, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkFreeMemory!");
}
#ifdef FREEMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_FreeMemory_before(device, memory, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].FreeMemory(device, memory, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef FREEMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_FreeMemory_after(device, memory, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkFreeMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].FreeMemory(device, memory, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkMapMemory!");
}
#ifdef MAPMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_MapMemory_before(device, memory, offset, size, flags, ppData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].MapMemory(device, memory, offset, size, flags, ppData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"size=" + std::to_string(size) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
winsockSendToUI(&ConnectSocket,"ppData=" + ptrToString((void**)std::addressof(ppData)) + '!');
}
#ifdef MAPMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_MapMemory_after(device, memory, offset, size, flags, ppData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkMapMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].MapMemory(device, memory, offset, size, flags, ppData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_UnmapMemory(VkDevice device, VkDeviceMemory memory) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUnmapMemory!");
}
#ifdef UNMAPMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_UnmapMemory_before(device, memory);
}
#endif 
device_dispatch[GetKey(device)].UnmapMemory(device, memory);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
}
#ifdef UNMAPMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_UnmapMemory_after(device, memory);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUnmapMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].UnmapMemory(device, memory);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkFlushMappedMemoryRanges!");
}
#ifdef FLUSHMAPPEDMEMORYRANGES_BEFORE_EXEC_EXISTS
if(connected) {
layer_FlushMappedMemoryRanges_before(device, memoryRangeCount, pMemoryRanges);
}
#endif 
auto ret = device_dispatch[GetKey(device)].FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memoryRangeCount=" + std::to_string(memoryRangeCount) + '!');
if(pMemoryRanges != VK_NULL_HANDLE && pMemoryRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRanges->memory=" + ptrToString((void**)std::addressof(pMemoryRanges->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRanges->offset=" + std::to_string(pMemoryRanges->offset) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRanges->size=" + std::to_string(pMemoryRanges->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRanges=VK_NULL_HANDLE!");
}
#ifdef FLUSHMAPPEDMEMORYRANGES_AFTER_EXEC_EXISTS
if(connected) {
layer_FlushMappedMemoryRanges_after(device, memoryRangeCount, pMemoryRanges);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkFlushMappedMemoryRanges!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].FlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, VkMappedMemoryRange* pMemoryRanges) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkInvalidateMappedMemoryRanges!");
}
#ifdef INVALIDATEMAPPEDMEMORYRANGES_BEFORE_EXEC_EXISTS
if(connected) {
layer_InvalidateMappedMemoryRanges_before(device, memoryRangeCount, pMemoryRanges);
}
#endif 
auto ret = device_dispatch[GetKey(device)].InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memoryRangeCount=" + std::to_string(memoryRangeCount) + '!');
if(pMemoryRanges != VK_NULL_HANDLE && pMemoryRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRanges->memory=" + ptrToString((void**)std::addressof(pMemoryRanges->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRanges->offset=" + std::to_string(pMemoryRanges->offset) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRanges->size=" + std::to_string(pMemoryRanges->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRanges=VK_NULL_HANDLE!");
}
#ifdef INVALIDATEMAPPEDMEMORYRANGES_AFTER_EXEC_EXISTS
if(connected) {
layer_InvalidateMappedMemoryRanges_after(device, memoryRangeCount, pMemoryRanges);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkInvalidateMappedMemoryRanges!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].InvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceMemoryCommitment!");
}
#ifdef GETDEVICEMEMORYCOMMITMENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryCommitment_before(device, memory, pCommittedMemoryInBytes);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"pCommittedMemoryInBytes=" + ptrToString((void**)std::addressof(pCommittedMemoryInBytes)) + '!');
}
#ifdef GETDEVICEMEMORYCOMMITMENT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryCommitment_after(device, memory, pCommittedMemoryInBytes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceMemoryCommitment!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferMemoryRequirements!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements_before(device, buffer, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->size=" + std::to_string(pMemoryRequirements->size) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->alignment=" + std::to_string(pMemoryRequirements->alignment) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryTypeBits=" + std::to_string(pMemoryRequirements->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements_after(device, buffer, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindBufferMemory!");
}
#ifdef BINDBUFFERMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory_before(device, buffer, memory, memoryOffset);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindBufferMemory(device, buffer, memory, memoryOffset);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"memoryOffset=" + std::to_string(memoryOffset) + '!');
}
#ifdef BINDBUFFERMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory_after(device, buffer, memory, memoryOffset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindBufferMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindBufferMemory(device, buffer, memory, memoryOffset);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageMemoryRequirements!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements_before(device, image, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageMemoryRequirements(device, image, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->size=" + std::to_string(pMemoryRequirements->size) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->alignment=" + std::to_string(pMemoryRequirements->alignment) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryTypeBits=" + std::to_string(pMemoryRequirements->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements_after(device, image, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageMemoryRequirements(device, image, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindImageMemory!");
}
#ifdef BINDIMAGEMEMORY_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindImageMemory_before(device, image, memory, memoryOffset);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindImageMemory(device, image, memory, memoryOffset);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"memoryOffset=" + std::to_string(memoryOffset) + '!');
}
#ifdef BINDIMAGEMEMORY_AFTER_EXEC_EXISTS
if(connected) {
layer_BindImageMemory_after(device, image, memory, memoryOffset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindImageMemory!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindImageMemory(device, image, memory, memoryOffset);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSparseMemoryRequirements!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements_before(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pSparseMemoryRequirements != VK_NULL_HANDLE && pSparseMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->formatProperties=" + ptrToString((void**)std::addressof(pSparseMemoryRequirements->formatProperties)) + '!');
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->imageMipTailFirstLod=" + std::to_string(pSparseMemoryRequirements->imageMipTailFirstLod) + '!');
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->imageMipTailSize=" + std::to_string(pSparseMemoryRequirements->imageMipTailSize) + '!');
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->imageMipTailOffset=" + std::to_string(pSparseMemoryRequirements->imageMipTailOffset) + '!');
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->imageMipTailStride=" + std::to_string(pSparseMemoryRequirements->imageMipTailStride) + '!');
}else winsockSendToUI(&ConnectSocket, "pSparseMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements_after(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSparseMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, VkBindSparseInfo* pBindInfo, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueBindSparse!");
}
#ifdef QUEUEBINDSPARSE_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueBindSparse_before(queue, bindInfoCount, pBindInfo, fence);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfo != VK_NULL_HANDLE && pBindInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->waitSemaphoreCount=" + std::to_string(pBindInfo->waitSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pWaitSemaphores=" + ptrToString((void**)std::addressof(pBindInfo->pWaitSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->bufferBindCount=" + std::to_string(pBindInfo->bufferBindCount) + '!');
if(pBindInfo->pBufferBinds != VK_NULL_HANDLE && pBindInfo->pBufferBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->buffer=" + ptrToString((void**)std::addressof(pBindInfo->pBufferBinds->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->bindCount=" + std::to_string(pBindInfo->pBufferBinds->bindCount) + '!');
if(pBindInfo->pBufferBinds->pBinds != VK_NULL_HANDLE && pBindInfo->pBufferBinds->pBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->pBinds->resourceOffset=" + std::to_string(pBindInfo->pBufferBinds->pBinds->resourceOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->pBinds->size=" + std::to_string(pBindInfo->pBufferBinds->pBinds->size) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->pBinds->memory=" + ptrToString((void**)std::addressof(pBindInfo->pBufferBinds->pBinds->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->pBinds->memoryOffset=" + std::to_string(pBindInfo->pBufferBinds->pBinds->memoryOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pBufferBinds->pBinds->flags=" + ptrToString((void**)std::addressof(pBindInfo->pBufferBinds->pBinds->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBinds=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pBufferBinds=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBindInfo->imageOpaqueBindCount=" + std::to_string(pBindInfo->imageOpaqueBindCount) + '!');
if(pBindInfo->pImageOpaqueBinds != VK_NULL_HANDLE && pBindInfo->pImageOpaqueBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->image=" + ptrToString((void**)std::addressof(pBindInfo->pImageOpaqueBinds->image)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->bindCount=" + std::to_string(pBindInfo->pImageOpaqueBinds->bindCount) + '!');
if(pBindInfo->pImageOpaqueBinds->pBinds != VK_NULL_HANDLE && pBindInfo->pImageOpaqueBinds->pBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->pBinds->resourceOffset=" + std::to_string(pBindInfo->pImageOpaqueBinds->pBinds->resourceOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->pBinds->size=" + std::to_string(pBindInfo->pImageOpaqueBinds->pBinds->size) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->pBinds->memory=" + ptrToString((void**)std::addressof(pBindInfo->pImageOpaqueBinds->pBinds->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->pBinds->memoryOffset=" + std::to_string(pBindInfo->pImageOpaqueBinds->pBinds->memoryOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageOpaqueBinds->pBinds->flags=" + ptrToString((void**)std::addressof(pBindInfo->pImageOpaqueBinds->pBinds->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBinds=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pImageOpaqueBinds=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBindInfo->imageBindCount=" + std::to_string(pBindInfo->imageBindCount) + '!');
if(pBindInfo->pImageBinds != VK_NULL_HANDLE && pBindInfo->pImageBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->image=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->image)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->bindCount=" + std::to_string(pBindInfo->pImageBinds->bindCount) + '!');
if(pBindInfo->pImageBinds->pBinds != VK_NULL_HANDLE && pBindInfo->pImageBinds->pBinds != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->subresource=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->pBinds->subresource)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->offset=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->pBinds->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->extent=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->pBinds->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->memory=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->pBinds->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->memoryOffset=" + std::to_string(pBindInfo->pImageBinds->pBinds->memoryOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pImageBinds->pBinds->flags=" + ptrToString((void**)std::addressof(pBindInfo->pImageBinds->pBinds->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBinds=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pImageBinds=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBindInfo->signalSemaphoreCount=" + std::to_string(pBindInfo->signalSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfo->pSignalSemaphores=" + ptrToString((void**)std::addressof(pBindInfo->pSignalSemaphores)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef QUEUEBINDSPARSE_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueBindSparse_after(queue, bindInfoCount, pBindInfo, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueBindSparse!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateFence(VkDevice device, VkFenceCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateFence!");
}
#ifdef CREATEFENCE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateFence_before(device, pCreateInfo, pAllocator, pFence);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateFence(device, pCreateInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFence=" + ptrToString((void**)std::addressof(pFence)) + '!');
}
#ifdef CREATEFENCE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateFence_after(device, pCreateInfo, pAllocator, pFence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateFence!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateFence(device, pCreateInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyFence(VkDevice device, VkFence fence, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyFence!");
}
#ifdef DESTROYFENCE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyFence_before(device, fence, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyFence(device, fence, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYFENCE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyFence_after(device, fence, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyFence!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyFence(device, fence, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ResetFences(VkDevice device, uint32_t fenceCount, VkFence* pFences) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetFences!");
}
#ifdef RESETFENCES_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetFences_before(device, fenceCount, pFences);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ResetFences(device, fenceCount, pFences);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"fenceCount=" + std::to_string(fenceCount) + '!');
winsockSendToUI(&ConnectSocket,"pFences=" + ptrToString((void**)std::addressof(pFences)) + '!');
}
#ifdef RESETFENCES_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetFences_after(device, fenceCount, pFences);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetFences!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ResetFences(device, fenceCount, pFences);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFenceStatus(VkDevice device, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFenceStatus!");
}
#ifdef GETFENCESTATUS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFenceStatus_before(device, fence);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFenceStatus(device, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef GETFENCESTATUS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFenceStatus_after(device, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFenceStatus!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFenceStatus(device, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WaitForFences(VkDevice device, uint32_t fenceCount, VkFence* pFences, VkBool32 waitAll, uint64_t timeout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWaitForFences!");
}
#ifdef WAITFORFENCES_BEFORE_EXEC_EXISTS
if(connected) {
layer_WaitForFences_before(device, fenceCount, pFences, waitAll, timeout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WaitForFences(device, fenceCount, pFences, waitAll, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"fenceCount=" + std::to_string(fenceCount) + '!');
winsockSendToUI(&ConnectSocket,"pFences=" + ptrToString((void**)std::addressof(pFences)) + '!');
winsockSendToUI(&ConnectSocket,"waitAll=" + bool_as_text(waitAll) + '!');
winsockSendToUI(&ConnectSocket,"timeout=" + std::to_string(timeout) + '!');
}
#ifdef WAITFORFENCES_AFTER_EXEC_EXISTS
if(connected) {
layer_WaitForFences_after(device, fenceCount, pFences, waitAll, timeout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWaitForFences!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WaitForFences(device, fenceCount, pFences, waitAll, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSemaphore(VkDevice device, VkSemaphoreCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSemaphore!");
}
#ifdef CREATESEMAPHORE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSemaphore_before(device, pCreateInfo, pAllocator, pSemaphore);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSemaphore=" + ptrToString((void**)std::addressof(pSemaphore)) + '!');
}
#ifdef CREATESEMAPHORE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSemaphore_after(device, pCreateInfo, pAllocator, pSemaphore);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSemaphore!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySemaphore(VkDevice device, VkSemaphore semaphore, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySemaphore!");
}
#ifdef DESTROYSEMAPHORE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySemaphore_before(device, semaphore, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySemaphore(device, semaphore, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"semaphore=" + ptrToString((void**)std::addressof(semaphore)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSEMAPHORE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySemaphore_after(device, semaphore, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySemaphore!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySemaphore(device, semaphore, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateEvent(VkDevice device, VkEventCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkEvent* pEvent) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateEvent!");
}
#ifdef CREATEEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateEvent_before(device, pCreateInfo, pAllocator, pEvent);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateEvent(device, pCreateInfo, pAllocator, pEvent);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pEvent=" + ptrToString((void**)std::addressof(pEvent)) + '!');
}
#ifdef CREATEEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateEvent_after(device, pCreateInfo, pAllocator, pEvent);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateEvent(device, pCreateInfo, pAllocator, pEvent);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyEvent(VkDevice device, VkEvent event, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyEvent!");
}
#ifdef DESTROYEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyEvent_before(device, event, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyEvent(device, event, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyEvent_after(device, event, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyEvent(device, event, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetEventStatus(VkDevice device, VkEvent event) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetEventStatus!");
}
#ifdef GETEVENTSTATUS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetEventStatus_before(device, event);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetEventStatus(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
}
#ifdef GETEVENTSTATUS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetEventStatus_after(device, event);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetEventStatus!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetEventStatus(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetEvent(VkDevice device, VkEvent event) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetEvent!");
}
#ifdef SETEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetEvent_before(device, event);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetEvent(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
}
#ifdef SETEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetEvent_after(device, event);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetEvent(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ResetEvent(VkDevice device, VkEvent event) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetEvent!");
}
#ifdef RESETEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetEvent_before(device, event);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ResetEvent(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
}
#ifdef RESETEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetEvent_after(device, event);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ResetEvent(device, event);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateQueryPool(VkDevice device, VkQueryPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateQueryPool!");
}
#ifdef CREATEQUERYPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateQueryPool_before(device, pCreateInfo, pAllocator, pQueryPool);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->queryCount=" + std::to_string(pCreateInfo->queryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pipelineStatistics=" + ptrToString((void**)std::addressof(pCreateInfo->pipelineStatistics)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pQueryPool=" + ptrToString((void**)std::addressof(pQueryPool)) + '!');
}
#ifdef CREATEQUERYPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateQueryPool_after(device, pCreateInfo, pAllocator, pQueryPool);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateQueryPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyQueryPool(VkDevice device, VkQueryPool queryPool, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyQueryPool!");
}
#ifdef DESTROYQUERYPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyQueryPool_before(device, queryPool, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyQueryPool(device, queryPool, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYQUERYPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyQueryPool_after(device, queryPool, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyQueryPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyQueryPool(device, queryPool, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetQueryPoolResults!");
}
#ifdef GETQUERYPOOLRESULTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetQueryPoolResults_before(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
winsockSendToUI(&ConnectSocket,"queryCount=" + std::to_string(queryCount) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef GETQUERYPOOLRESULTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetQueryPoolResults_after(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetQueryPoolResults!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetQueryPool!");
}
#ifdef RESETQUERYPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetQueryPool_before(device, queryPool, firstQuery, queryCount);
}
#endif 
device_dispatch[GetKey(device)].ResetQueryPool(device, queryPool, firstQuery, queryCount);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
winsockSendToUI(&ConnectSocket,"queryCount=" + std::to_string(queryCount) + '!');
}
#ifdef RESETQUERYPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetQueryPool_after(device, queryPool, firstQuery, queryCount);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetQueryPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].ResetQueryPool(device, queryPool, firstQuery, queryCount);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateBuffer(VkDevice device, VkBufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateBuffer!");
}
#ifdef CREATEBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateBuffer_before(device, pCreateInfo, pAllocator, pBuffer);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->size=" + std::to_string(pCreateInfo->size) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->usage=" + ptrToString((void**)std::addressof(pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->queueFamilyIndexCount=" + std::to_string(pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBuffer=" + ptrToString((void**)std::addressof(pBuffer)) + '!');
}
#ifdef CREATEBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateBuffer_after(device, pCreateInfo, pAllocator, pBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyBuffer(VkDevice device, VkBuffer buffer, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyBuffer!");
}
#ifdef DESTROYBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyBuffer_before(device, buffer, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyBuffer(device, buffer, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyBuffer_after(device, buffer, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyBuffer(device, buffer, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateBufferView(VkDevice device, VkBufferViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferView* pView) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateBufferView!");
}
#ifdef CREATEBUFFERVIEW_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateBufferView_before(device, pCreateInfo, pAllocator, pView);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateBufferView(device, pCreateInfo, pAllocator, pView);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->buffer=" + ptrToString((void**)std::addressof(pCreateInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->offset=" + std::to_string(pCreateInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->range=" + std::to_string(pCreateInfo->range) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pView=" + ptrToString((void**)std::addressof(pView)) + '!');
}
#ifdef CREATEBUFFERVIEW_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateBufferView_after(device, pCreateInfo, pAllocator, pView);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateBufferView!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateBufferView(device, pCreateInfo, pAllocator, pView);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyBufferView(VkDevice device, VkBufferView bufferView, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyBufferView!");
}
#ifdef DESTROYBUFFERVIEW_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyBufferView_before(device, bufferView, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyBufferView(device, bufferView, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bufferView=" + ptrToString((void**)std::addressof(bufferView)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYBUFFERVIEW_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyBufferView_after(device, bufferView, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyBufferView!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyBufferView(device, bufferView, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateImage(VkDevice device, VkImageCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImage* pImage) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateImage!");
}
#ifdef CREATEIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateImage_before(device, pCreateInfo, pAllocator, pImage);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateImage(device, pCreateInfo, pAllocator, pImage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->extent=" + ptrToString((void**)std::addressof(pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->mipLevels=" + std::to_string(pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->arrayLayers=" + std::to_string(pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->usage=" + ptrToString((void**)std::addressof(pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->queueFamilyIndexCount=" + std::to_string(pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pImage=" + ptrToString((void**)std::addressof(pImage)) + '!');
}
#ifdef CREATEIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateImage_after(device, pCreateInfo, pAllocator, pImage);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateImage(device, pCreateInfo, pAllocator, pImage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyImage(VkDevice device, VkImage image, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyImage!");
}
#ifdef DESTROYIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyImage_before(device, image, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyImage(device, image, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyImage_after(device, image, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyImage(device, image, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSubresourceLayout(VkDevice device, VkImage image, VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSubresourceLayout!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout_before(device, image, pSubresource, pLayout);
}
#endif 
device_dispatch[GetKey(device)].GetImageSubresourceLayout(device, image, pSubresource, pLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pSubresource != VK_NULL_HANDLE && pSubresource != NULL) {
winsockSendToUI(&ConnectSocket,"pSubresource->aspectMask=" + ptrToString((void**)std::addressof(pSubresource->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubresource->mipLevel=" + std::to_string(pSubresource->mipLevel) + '!');
winsockSendToUI(&ConnectSocket,"pSubresource->arrayLayer=" + std::to_string(pSubresource->arrayLayer) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubresource=VK_NULL_HANDLE!");
if(pLayout != VK_NULL_HANDLE && pLayout != NULL) {
winsockSendToUI(&ConnectSocket,"pLayout->offset=" + std::to_string(pLayout->offset) + '!');
winsockSendToUI(&ConnectSocket,"pLayout->size=" + std::to_string(pLayout->size) + '!');
winsockSendToUI(&ConnectSocket,"pLayout->rowPitch=" + std::to_string(pLayout->rowPitch) + '!');
winsockSendToUI(&ConnectSocket,"pLayout->arrayPitch=" + std::to_string(pLayout->arrayPitch) + '!');
winsockSendToUI(&ConnectSocket,"pLayout->depthPitch=" + std::to_string(pLayout->depthPitch) + '!');
}else winsockSendToUI(&ConnectSocket, "pLayout=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout_after(device, image, pSubresource, pLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSubresourceLayout!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSubresourceLayout(device, image, pSubresource, pLayout);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateImageView(VkDevice device, VkImageViewCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkImageView* pView) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateImageView!");
}
#ifdef CREATEIMAGEVIEW_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateImageView_before(device, pCreateInfo, pAllocator, pView);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateImageView(device, pCreateInfo, pAllocator, pView);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->image=" + ptrToString((void**)std::addressof(pCreateInfo->image)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->components=" + ptrToString((void**)std::addressof(pCreateInfo->components)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->subresourceRange=" + ptrToString((void**)std::addressof(pCreateInfo->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pView=" + ptrToString((void**)std::addressof(pView)) + '!');
}
#ifdef CREATEIMAGEVIEW_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateImageView_after(device, pCreateInfo, pAllocator, pView);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateImageView!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateImageView(device, pCreateInfo, pAllocator, pView);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyImageView(VkDevice device, VkImageView imageView, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyImageView!");
}
#ifdef DESTROYIMAGEVIEW_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyImageView_before(device, imageView, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyImageView(device, imageView, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"imageView=" + ptrToString((void**)std::addressof(imageView)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYIMAGEVIEW_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyImageView_after(device, imageView, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyImageView!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyImageView(device, imageView, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateShaderModule(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateShaderModule!");
}
#ifdef CREATESHADERMODULE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateShaderModule_before(device, pCreateInfo, pAllocator, pShaderModule);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->codeSize=" + std::to_string(pCreateInfo->codeSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pShaderModule=" + ptrToString((void**)std::addressof(pShaderModule)) + '!');
}
#ifdef CREATESHADERMODULE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateShaderModule_after(device, pCreateInfo, pAllocator, pShaderModule);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateShaderModule!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyShaderModule!");
}
#ifdef DESTROYSHADERMODULE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyShaderModule_before(device, shaderModule, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyShaderModule(device, shaderModule, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"shaderModule=" + ptrToString((void**)std::addressof(shaderModule)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSHADERMODULE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyShaderModule_after(device, shaderModule, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyShaderModule!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyShaderModule(device, shaderModule, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreatePipelineCache(VkDevice device, VkPipelineCacheCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreatePipelineCache!");
}
#ifdef CREATEPIPELINECACHE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreatePipelineCache_before(device, pCreateInfo, pAllocator, pPipelineCache);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->initialDataSize=" + std::to_string(pCreateInfo->initialDataSize) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->initialDataSize=" + std::to_string(pCreateInfo->initialDataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelineCache=" + ptrToString((void**)std::addressof(pPipelineCache)) + '!');
}
#ifdef CREATEPIPELINECACHE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreatePipelineCache_after(device, pCreateInfo, pAllocator, pPipelineCache);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreatePipelineCache!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyPipelineCache!");
}
#ifdef DESTROYPIPELINECACHE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyPipelineCache_before(device, pipelineCache, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyPipelineCache(device, pipelineCache, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYPIPELINECACHE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyPipelineCache_after(device, pipelineCache, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyPipelineCache!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyPipelineCache(device, pipelineCache, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineCacheData!");
}
#ifdef GETPIPELINECACHEDATA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineCacheData_before(device, pipelineCache, pDataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelineCacheData(device, pipelineCache, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"pDataSize=" + ptrToString((void**)std::addressof(pDataSize)) + '!');
}
#ifdef GETPIPELINECACHEDATA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineCacheData_after(device, pipelineCache, pDataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineCacheData!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelineCacheData(device, pipelineCache, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, VkPipelineCache* pSrcCaches) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkMergePipelineCaches!");
}
#ifdef MERGEPIPELINECACHES_BEFORE_EXEC_EXISTS
if(connected) {
layer_MergePipelineCaches_before(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif 
auto ret = device_dispatch[GetKey(device)].MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"dstCache=" + ptrToString((void**)std::addressof(dstCache)) + '!');
winsockSendToUI(&ConnectSocket,"srcCacheCount=" + std::to_string(srcCacheCount) + '!');
winsockSendToUI(&ConnectSocket,"pSrcCaches=" + ptrToString((void**)std::addressof(pSrcCaches)) + '!');
}
#ifdef MERGEPIPELINECACHES_AFTER_EXEC_EXISTS
if(connected) {
layer_MergePipelineCaches_after(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkMergePipelineCaches!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].MergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkGraphicsPipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateGraphicsPipelines!");
}
#ifdef CREATEGRAPHICSPIPELINES_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateGraphicsPipelines_before(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->stageCount=" + std::to_string(pCreateInfos->stageCount) + '!');
if(pCreateInfos->pStages != VK_NULL_HANDLE && pCreateInfos->pStages != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->module=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->module)) + '!');
if(pCreateInfos->pStages->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pStages->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->mapEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pStages=VK_NULL_HANDLE!");
if(pCreateInfos->pStages != VK_NULL_HANDLE && pCreateInfos->pStages != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->module=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->module)) + '!');
if(pCreateInfos->pStages->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pStages->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->mapEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pStages=VK_NULL_HANDLE!");
if(pCreateInfos->pVertexInputState != VK_NULL_HANDLE && pCreateInfos->pVertexInputState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pVertexInputState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->vertexBindingDescriptionCount=" + std::to_string(pCreateInfos->pVertexInputState->vertexBindingDescriptionCount) + '!');
if(pCreateInfos->pVertexInputState->pVertexBindingDescriptions != VK_NULL_HANDLE && pCreateInfos->pVertexInputState->pVertexBindingDescriptions != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->pVertexBindingDescriptions->binding=" + std::to_string(pCreateInfos->pVertexInputState->pVertexBindingDescriptions->binding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->pVertexBindingDescriptions->stride=" + std::to_string(pCreateInfos->pVertexInputState->pVertexBindingDescriptions->stride) + '!');
}else winsockSendToUI(&ConnectSocket, "pVertexBindingDescriptions=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->vertexAttributeDescriptionCount=" + std::to_string(pCreateInfos->pVertexInputState->vertexAttributeDescriptionCount) + '!');
if(pCreateInfos->pVertexInputState->pVertexAttributeDescriptions != VK_NULL_HANDLE && pCreateInfos->pVertexInputState->pVertexAttributeDescriptions != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->location=" + std::to_string(pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->location) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->binding=" + std::to_string(pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->binding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->offset=" + std::to_string(pCreateInfos->pVertexInputState->pVertexAttributeDescriptions->offset) + '!');
}else winsockSendToUI(&ConnectSocket, "pVertexAttributeDescriptions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pVertexInputState=VK_NULL_HANDLE!");
if(pCreateInfos->pInputAssemblyState != VK_NULL_HANDLE && pCreateInfos->pInputAssemblyState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pInputAssemblyState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pInputAssemblyState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pInputAssemblyState->primitiveRestartEnable=" + bool_as_text(pCreateInfos->pInputAssemblyState->primitiveRestartEnable) + '!');
}else winsockSendToUI(&ConnectSocket, "pInputAssemblyState=VK_NULL_HANDLE!");
if(pCreateInfos->pTessellationState != VK_NULL_HANDLE && pCreateInfos->pTessellationState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pTessellationState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pTessellationState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pTessellationState->patchControlPoints=" + std::to_string(pCreateInfos->pTessellationState->patchControlPoints) + '!');
}else winsockSendToUI(&ConnectSocket, "pTessellationState=VK_NULL_HANDLE!");
if(pCreateInfos->pViewportState != VK_NULL_HANDLE && pCreateInfos->pViewportState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pViewportState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->viewportCount=" + std::to_string(pCreateInfos->pViewportState->viewportCount) + '!');
if(pCreateInfos->pViewportState->pViewports != VK_NULL_HANDLE && pCreateInfos->pViewportState->pViewports != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->x=" + std::to_string(pCreateInfos->pViewportState->pViewports->x) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->y=" + std::to_string(pCreateInfos->pViewportState->pViewports->y) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->width=" + std::to_string(pCreateInfos->pViewportState->pViewports->width) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->height=" + std::to_string(pCreateInfos->pViewportState->pViewports->height) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->minDepth=" + std::to_string(pCreateInfos->pViewportState->pViewports->minDepth) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pViewports->maxDepth=" + std::to_string(pCreateInfos->pViewportState->pViewports->maxDepth) + '!');
}else winsockSendToUI(&ConnectSocket, "pViewports=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->scissorCount=" + std::to_string(pCreateInfos->pViewportState->scissorCount) + '!');
if(pCreateInfos->pViewportState->pScissors != VK_NULL_HANDLE && pCreateInfos->pViewportState->pScissors != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pScissors->offset=" + ptrToString((void**)std::addressof(pCreateInfos->pViewportState->pScissors->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pViewportState->pScissors->extent=" + ptrToString((void**)std::addressof(pCreateInfos->pViewportState->pScissors->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pScissors=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pViewportState=VK_NULL_HANDLE!");
if(pCreateInfos->pRasterizationState != VK_NULL_HANDLE && pCreateInfos->pRasterizationState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pRasterizationState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->depthClampEnable=" + bool_as_text(pCreateInfos->pRasterizationState->depthClampEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->rasterizerDiscardEnable=" + bool_as_text(pCreateInfos->pRasterizationState->rasterizerDiscardEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->cullMode=" + ptrToString((void**)std::addressof(pCreateInfos->pRasterizationState->cullMode)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->depthBiasEnable=" + bool_as_text(pCreateInfos->pRasterizationState->depthBiasEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->depthBiasConstantFactor=" + std::to_string(pCreateInfos->pRasterizationState->depthBiasConstantFactor) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->depthBiasClamp=" + std::to_string(pCreateInfos->pRasterizationState->depthBiasClamp) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->depthBiasSlopeFactor=" + std::to_string(pCreateInfos->pRasterizationState->depthBiasSlopeFactor) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pRasterizationState->lineWidth=" + std::to_string(pCreateInfos->pRasterizationState->lineWidth) + '!');
}else winsockSendToUI(&ConnectSocket, "pRasterizationState=VK_NULL_HANDLE!");
if(pCreateInfos->pMultisampleState != VK_NULL_HANDLE && pCreateInfos->pMultisampleState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pMultisampleState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->sampleShadingEnable=" + bool_as_text(pCreateInfos->pMultisampleState->sampleShadingEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->minSampleShading=" + std::to_string(pCreateInfos->pMultisampleState->minSampleShading) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->pSampleMask=" + ptrToString((void**)std::addressof(pCreateInfos->pMultisampleState->pSampleMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->alphaToCoverageEnable=" + bool_as_text(pCreateInfos->pMultisampleState->alphaToCoverageEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pMultisampleState->alphaToOneEnable=" + bool_as_text(pCreateInfos->pMultisampleState->alphaToOneEnable) + '!');
}else winsockSendToUI(&ConnectSocket, "pMultisampleState=VK_NULL_HANDLE!");
if(pCreateInfos->pDepthStencilState != VK_NULL_HANDLE && pCreateInfos->pDepthStencilState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pDepthStencilState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->depthTestEnable=" + bool_as_text(pCreateInfos->pDepthStencilState->depthTestEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->depthWriteEnable=" + bool_as_text(pCreateInfos->pDepthStencilState->depthWriteEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->depthBoundsTestEnable=" + bool_as_text(pCreateInfos->pDepthStencilState->depthBoundsTestEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->stencilTestEnable=" + bool_as_text(pCreateInfos->pDepthStencilState->stencilTestEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->front=" + ptrToString((void**)std::addressof(pCreateInfos->pDepthStencilState->front)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->back=" + ptrToString((void**)std::addressof(pCreateInfos->pDepthStencilState->back)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->minDepthBounds=" + std::to_string(pCreateInfos->pDepthStencilState->minDepthBounds) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDepthStencilState->maxDepthBounds=" + std::to_string(pCreateInfos->pDepthStencilState->maxDepthBounds) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthStencilState=VK_NULL_HANDLE!");
if(pCreateInfos->pColorBlendState != VK_NULL_HANDLE && pCreateInfos->pColorBlendState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pColorBlendState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->logicOpEnable=" + bool_as_text(pCreateInfos->pColorBlendState->logicOpEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->attachmentCount=" + std::to_string(pCreateInfos->pColorBlendState->attachmentCount) + '!');
if(pCreateInfos->pColorBlendState->pAttachments != VK_NULL_HANDLE && pCreateInfos->pColorBlendState->pAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->pAttachments->blendEnable=" + bool_as_text(pCreateInfos->pColorBlendState->pAttachments->blendEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->pAttachments->colorWriteMask=" + ptrToString((void**)std::addressof(pCreateInfos->pColorBlendState->pAttachments->colorWriteMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->pColorBlendState->blendConstants=" + std::to_string(pCreateInfos->pColorBlendState->blendConstants[0]) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorBlendState=VK_NULL_HANDLE!");
if(pCreateInfos->pDynamicState != VK_NULL_HANDLE && pCreateInfos->pDynamicState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pDynamicState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->dynamicStateCount=" + std::to_string(pCreateInfos->pDynamicState->dynamicStateCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->pDynamicStates=" + ptrToString((void**)std::addressof(pCreateInfos->pDynamicState->pDynamicStates)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDynamicState=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->layout=" + ptrToString((void**)std::addressof(pCreateInfos->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->renderPass=" + ptrToString((void**)std::addressof(pCreateInfos->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->subpass=" + std::to_string(pCreateInfos->subpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfos->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineIndex=" + std::to_string(pCreateInfos->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelines=" + ptrToString((void**)std::addressof(pPipelines)) + '!');
}
#ifdef CREATEGRAPHICSPIPELINES_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateGraphicsPipelines_after(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateGraphicsPipelines!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkComputePipelineCreateInfo* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateComputePipelines!");
}
#ifdef CREATECOMPUTEPIPELINES_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateComputePipelines_before(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->stage=" + ptrToString((void**)std::addressof(pCreateInfos->stage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->layout=" + ptrToString((void**)std::addressof(pCreateInfos->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfos->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineIndex=" + std::to_string(pCreateInfos->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelines=" + ptrToString((void**)std::addressof(pPipelines)) + '!');
}
#ifdef CREATECOMPUTEPIPELINES_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateComputePipelines_after(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateComputePipelines!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI!");
}
#ifdef GETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI_before(device, renderpass, pMaxWorkgroupSize);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"renderpass=" + ptrToString((void**)std::addressof(renderpass)) + '!');
if(pMaxWorkgroupSize != VK_NULL_HANDLE && pMaxWorkgroupSize != NULL) {
winsockSendToUI(&ConnectSocket,"pMaxWorkgroupSize->width=" + std::to_string(pMaxWorkgroupSize->width) + '!');
winsockSendToUI(&ConnectSocket,"pMaxWorkgroupSize->height=" + std::to_string(pMaxWorkgroupSize->height) + '!');
}else winsockSendToUI(&ConnectSocket, "pMaxWorkgroupSize=VK_NULL_HANDLE!");
}
#ifdef GETDEVICESUBPASSSHADINGMAXWORKGROUPSIZEHUAWEI_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI_after(device, renderpass, pMaxWorkgroupSize);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyPipeline(VkDevice device, VkPipeline pipeline, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyPipeline!");
}
#ifdef DESTROYPIPELINE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyPipeline_before(device, pipeline, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyPipeline(device, pipeline, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYPIPELINE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyPipeline_after(device, pipeline, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyPipeline!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyPipeline(device, pipeline, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreatePipelineLayout(VkDevice device, VkPipelineLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreatePipelineLayout!");
}
#ifdef CREATEPIPELINELAYOUT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreatePipelineLayout_before(device, pCreateInfo, pAllocator, pPipelineLayout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->setLayoutCount=" + std::to_string(pCreateInfo->setLayoutCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSetLayouts=" + ptrToString((void**)std::addressof(pCreateInfo->pSetLayouts)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pushConstantRangeCount=" + std::to_string(pCreateInfo->pushConstantRangeCount) + '!');
if(pCreateInfo->pPushConstantRanges != VK_NULL_HANDLE && pCreateInfo->pPushConstantRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pPushConstantRanges->stageFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pPushConstantRanges->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pPushConstantRanges->offset=" + std::to_string(pCreateInfo->pPushConstantRanges->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pPushConstantRanges->size=" + std::to_string(pCreateInfo->pPushConstantRanges->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pPushConstantRanges=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelineLayout=" + ptrToString((void**)std::addressof(pPipelineLayout)) + '!');
}
#ifdef CREATEPIPELINELAYOUT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreatePipelineLayout_after(device, pCreateInfo, pAllocator, pPipelineLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreatePipelineLayout!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyPipelineLayout!");
}
#ifdef DESTROYPIPELINELAYOUT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyPipelineLayout_before(device, pipelineLayout, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyPipelineLayout(device, pipelineLayout, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineLayout=" + ptrToString((void**)std::addressof(pipelineLayout)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYPIPELINELAYOUT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyPipelineLayout_after(device, pipelineLayout, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyPipelineLayout!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyPipelineLayout(device, pipelineLayout, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSampler(VkDevice device, VkSamplerCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSampler* pSampler) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSampler!");
}
#ifdef CREATESAMPLER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSampler_before(device, pCreateInfo, pAllocator, pSampler);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSampler(device, pCreateInfo, pAllocator, pSampler);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->mipLodBias=" + std::to_string(pCreateInfo->mipLodBias) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->anisotropyEnable=" + bool_as_text(pCreateInfo->anisotropyEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxAnisotropy=" + std::to_string(pCreateInfo->maxAnisotropy) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->compareEnable=" + bool_as_text(pCreateInfo->compareEnable) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->minLod=" + std::to_string(pCreateInfo->minLod) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxLod=" + std::to_string(pCreateInfo->maxLod) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->unnormalizedCoordinates=" + bool_as_text(pCreateInfo->unnormalizedCoordinates) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSampler=" + ptrToString((void**)std::addressof(pSampler)) + '!');
}
#ifdef CREATESAMPLER_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSampler_after(device, pCreateInfo, pAllocator, pSampler);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSampler!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSampler(device, pCreateInfo, pAllocator, pSampler);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySampler(VkDevice device, VkSampler sampler, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySampler!");
}
#ifdef DESTROYSAMPLER_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySampler_before(device, sampler, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySampler(device, sampler, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"sampler=" + ptrToString((void**)std::addressof(sampler)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSAMPLER_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySampler_after(device, sampler, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySampler!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySampler(device, sampler, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDescriptorSetLayout(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDescriptorSetLayout!");
}
#ifdef CREATEDESCRIPTORSETLAYOUT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorSetLayout_before(device, pCreateInfo, pAllocator, pSetLayout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->bindingCount=" + std::to_string(pCreateInfo->bindingCount) + '!');
if(pCreateInfo->pBindings != VK_NULL_HANDLE && pCreateInfo->pBindings != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->binding=" + std::to_string(pCreateInfo->pBindings->binding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->descriptorCount=" + std::to_string(pCreateInfo->pBindings->descriptorCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->stageFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->pImmutableSamplers=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->pImmutableSamplers)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindings=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSetLayout=" + ptrToString((void**)std::addressof(pSetLayout)) + '!');
}
#ifdef CREATEDESCRIPTORSETLAYOUT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorSetLayout_after(device, pCreateInfo, pAllocator, pSetLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDescriptorSetLayout!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDescriptorSetLayout!");
}
#ifdef DESTROYDESCRIPTORSETLAYOUT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorSetLayout_before(device, descriptorSetLayout, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSetLayout=" + ptrToString((void**)std::addressof(descriptorSetLayout)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDESCRIPTORSETLAYOUT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorSetLayout_after(device, descriptorSetLayout, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDescriptorSetLayout!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDescriptorPool(VkDevice device, VkDescriptorPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDescriptorPool!");
}
#ifdef CREATEDESCRIPTORPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorPool_before(device, pCreateInfo, pAllocator, pDescriptorPool);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxSets=" + std::to_string(pCreateInfo->maxSets) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->poolSizeCount=" + std::to_string(pCreateInfo->poolSizeCount) + '!');
if(pCreateInfo->pPoolSizes != VK_NULL_HANDLE && pCreateInfo->pPoolSizes != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pPoolSizes->descriptorCount=" + std::to_string(pCreateInfo->pPoolSizes->descriptorCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pPoolSizes=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorPool=" + ptrToString((void**)std::addressof(pDescriptorPool)) + '!');
}
#ifdef CREATEDESCRIPTORPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorPool_after(device, pCreateInfo, pAllocator, pDescriptorPool);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDescriptorPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDescriptorPool!");
}
#ifdef DESTROYDESCRIPTORPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorPool_before(device, descriptorPool, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyDescriptorPool(device, descriptorPool, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorPool=" + ptrToString((void**)std::addressof(descriptorPool)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDESCRIPTORPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorPool_after(device, descriptorPool, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDescriptorPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyDescriptorPool(device, descriptorPool, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetDescriptorPool!");
}
#ifdef RESETDESCRIPTORPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetDescriptorPool_before(device, descriptorPool, flags);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ResetDescriptorPool(device, descriptorPool, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorPool=" + ptrToString((void**)std::addressof(descriptorPool)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef RESETDESCRIPTORPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetDescriptorPool_after(device, descriptorPool, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetDescriptorPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ResetDescriptorPool(device, descriptorPool, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AllocateDescriptorSets(VkDevice device, VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAllocateDescriptorSets!");
}
#ifdef ALLOCATEDESCRIPTORSETS_BEFORE_EXEC_EXISTS
if(connected) {
layer_AllocateDescriptorSets_before(device, pAllocateInfo, pDescriptorSets);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAllocateInfo != VK_NULL_HANDLE && pAllocateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocateInfo->descriptorPool=" + ptrToString((void**)std::addressof(pAllocateInfo->descriptorPool)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocateInfo->descriptorSetCount=" + std::to_string(pAllocateInfo->descriptorSetCount) + '!');
winsockSendToUI(&ConnectSocket,"pAllocateInfo->pSetLayouts=" + ptrToString((void**)std::addressof(pAllocateInfo->pSetLayouts)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocateInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorSets=" + ptrToString((void**)std::addressof(pDescriptorSets)) + '!');
}
#ifdef ALLOCATEDESCRIPTORSETS_AFTER_EXEC_EXISTS
if(connected) {
layer_AllocateDescriptorSets_after(device, pAllocateInfo, pDescriptorSets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAllocateDescriptorSets!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkFreeDescriptorSets!");
}
#ifdef FREEDESCRIPTORSETS_BEFORE_EXEC_EXISTS
if(connected) {
layer_FreeDescriptorSets_before(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
#endif 
auto ret = device_dispatch[GetKey(device)].FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorPool=" + ptrToString((void**)std::addressof(descriptorPool)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSetCount=" + std::to_string(descriptorSetCount) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorSets=" + ptrToString((void**)std::addressof(pDescriptorSets)) + '!');
}
#ifdef FREEDESCRIPTORSETS_AFTER_EXEC_EXISTS
if(connected) {
layer_FreeDescriptorSets_after(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkFreeDescriptorSets!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].FreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, VkCopyDescriptorSet* pDescriptorCopies) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUpdateDescriptorSets!");
}
#ifdef UPDATEDESCRIPTORSETS_BEFORE_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSets_before(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
#endif 
device_dispatch[GetKey(device)].UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorWriteCount=" + std::to_string(descriptorWriteCount) + '!');
if(pDescriptorWrites != VK_NULL_HANDLE && pDescriptorWrites != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstSet=" + ptrToString((void**)std::addressof(pDescriptorWrites->dstSet)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstBinding=" + std::to_string(pDescriptorWrites->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstArrayElement=" + std::to_string(pDescriptorWrites->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->descriptorCount=" + std::to_string(pDescriptorWrites->descriptorCount) + '!');
if(pDescriptorWrites->pImageInfo != VK_NULL_HANDLE && pDescriptorWrites->pImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pImageInfo->sampler=" + ptrToString((void**)std::addressof(pDescriptorWrites->pImageInfo->sampler)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pImageInfo->imageView=" + ptrToString((void**)std::addressof(pDescriptorWrites->pImageInfo->imageView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageInfo=VK_NULL_HANDLE!");
if(pDescriptorWrites->pBufferInfo != VK_NULL_HANDLE && pDescriptorWrites->pBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->buffer=" + ptrToString((void**)std::addressof(pDescriptorWrites->pBufferInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->offset=" + std::to_string(pDescriptorWrites->pBufferInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->range=" + std::to_string(pDescriptorWrites->pBufferInfo->range) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pTexelBufferView=" + ptrToString((void**)std::addressof(pDescriptorWrites->pTexelBufferView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorWrites=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"descriptorCopyCount=" + std::to_string(descriptorCopyCount) + '!');
if(pDescriptorCopies != VK_NULL_HANDLE && pDescriptorCopies != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->srcSet=" + ptrToString((void**)std::addressof(pDescriptorCopies->srcSet)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->srcBinding=" + std::to_string(pDescriptorCopies->srcBinding) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->srcArrayElement=" + std::to_string(pDescriptorCopies->srcArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->dstSet=" + ptrToString((void**)std::addressof(pDescriptorCopies->dstSet)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->dstBinding=" + std::to_string(pDescriptorCopies->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->dstArrayElement=" + std::to_string(pDescriptorCopies->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorCopies->descriptorCount=" + std::to_string(pDescriptorCopies->descriptorCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorCopies=VK_NULL_HANDLE!");
}
#ifdef UPDATEDESCRIPTORSETS_AFTER_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSets_after(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUpdateDescriptorSets!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].UpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateFramebuffer(VkDevice device, VkFramebufferCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateFramebuffer!");
}
#ifdef CREATEFRAMEBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateFramebuffer_before(device, pCreateInfo, pAllocator, pFramebuffer);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->renderPass=" + ptrToString((void**)std::addressof(pCreateInfo->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->attachmentCount=" + std::to_string(pCreateInfo->attachmentCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pAttachments=" + ptrToString((void**)std::addressof(pCreateInfo->pAttachments)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->width=" + std::to_string(pCreateInfo->width) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->height=" + std::to_string(pCreateInfo->height) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->layers=" + std::to_string(pCreateInfo->layers) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFramebuffer=" + ptrToString((void**)std::addressof(pFramebuffer)) + '!');
}
#ifdef CREATEFRAMEBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateFramebuffer_after(device, pCreateInfo, pAllocator, pFramebuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateFramebuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyFramebuffer!");
}
#ifdef DESTROYFRAMEBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyFramebuffer_before(device, framebuffer, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyFramebuffer(device, framebuffer, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"framebuffer=" + ptrToString((void**)std::addressof(framebuffer)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYFRAMEBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyFramebuffer_after(device, framebuffer, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyFramebuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyFramebuffer(device, framebuffer, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateRenderPass(VkDevice device, VkRenderPassCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateRenderPass!");
}
#ifdef CREATERENDERPASS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass_before(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->attachmentCount=" + std::to_string(pCreateInfo->attachmentCount) + '!');
if(pCreateInfo->pAttachments != VK_NULL_HANDLE && pCreateInfo->pAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pAttachments->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pAttachments->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->subpassCount=" + std::to_string(pCreateInfo->subpassCount) + '!');
if(pCreateInfo->pSubpasses != VK_NULL_HANDLE && pCreateInfo->pSubpasses != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->inputAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->inputAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pInputAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pInputAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pInputAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pInputAttachments->attachment) + '!');
}else winsockSendToUI(&ConnectSocket, "pInputAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->colorAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->colorAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pColorAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pColorAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pColorAttachments->attachment) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pResolveAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pResolveAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pResolveAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pResolveAttachments->attachment) + '!');
}else winsockSendToUI(&ConnectSocket, "pResolveAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pDepthStencilAttachment != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pDepthStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment=" + std::to_string(pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthStencilAttachment=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->preserveAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->preserveAttachmentCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubpasses=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->dependencyCount=" + std::to_string(pCreateInfo->dependencyCount) + '!');
if(pCreateInfo->pDependencies != VK_NULL_HANDLE && pCreateInfo->pDependencies != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcSubpass=" + std::to_string(pCreateInfo->pDependencies->srcSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstSubpass=" + std::to_string(pCreateInfo->pDependencies->dstSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dependencyFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dependencyFlags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDependencies=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pRenderPass=" + ptrToString((void**)std::addressof(pRenderPass)) + '!');
}
#ifdef CREATERENDERPASS_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass_after(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateRenderPass!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyRenderPass(VkDevice device, VkRenderPass renderPass, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyRenderPass!");
}
#ifdef DESTROYRENDERPASS_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyRenderPass_before(device, renderPass, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyRenderPass(device, renderPass, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"renderPass=" + ptrToString((void**)std::addressof(renderPass)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYRENDERPASS_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyRenderPass_after(device, renderPass, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyRenderPass!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyRenderPass(device, renderPass, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRenderAreaGranularity!");
}
#ifdef GETRENDERAREAGRANULARITY_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRenderAreaGranularity_before(device, renderPass, pGranularity);
}
#endif 
device_dispatch[GetKey(device)].GetRenderAreaGranularity(device, renderPass, pGranularity);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"renderPass=" + ptrToString((void**)std::addressof(renderPass)) + '!');
if(pGranularity != VK_NULL_HANDLE && pGranularity != NULL) {
winsockSendToUI(&ConnectSocket,"pGranularity->width=" + std::to_string(pGranularity->width) + '!');
winsockSendToUI(&ConnectSocket,"pGranularity->height=" + std::to_string(pGranularity->height) + '!');
}else winsockSendToUI(&ConnectSocket, "pGranularity=VK_NULL_HANDLE!");
}
#ifdef GETRENDERAREAGRANULARITY_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRenderAreaGranularity_after(device, renderPass, pGranularity);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRenderAreaGranularity!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetRenderAreaGranularity(device, renderPass, pGranularity);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetRenderingAreaGranularityKHR(VkDevice device, VkRenderingAreaInfoKHR* pRenderingAreaInfo, VkExtent2D* pGranularity) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRenderingAreaGranularityKHR!");
}
#ifdef GETRENDERINGAREAGRANULARITYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRenderingAreaGranularityKHR_before(device, pRenderingAreaInfo, pGranularity);
}
#endif 
device_dispatch[GetKey(device)].GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pRenderingAreaInfo != VK_NULL_HANDLE && pRenderingAreaInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingAreaInfo->viewMask=" + std::to_string(pRenderingAreaInfo->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingAreaInfo->colorAttachmentCount=" + std::to_string(pRenderingAreaInfo->colorAttachmentCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingAreaInfo->pColorAttachmentFormats=" + ptrToString((void**)std::addressof(pRenderingAreaInfo->pColorAttachmentFormats)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRenderingAreaInfo=VK_NULL_HANDLE!");
if(pGranularity != VK_NULL_HANDLE && pGranularity != NULL) {
winsockSendToUI(&ConnectSocket,"pGranularity->width=" + std::to_string(pGranularity->width) + '!');
winsockSendToUI(&ConnectSocket,"pGranularity->height=" + std::to_string(pGranularity->height) + '!');
}else winsockSendToUI(&ConnectSocket, "pGranularity=VK_NULL_HANDLE!");
}
#ifdef GETRENDERINGAREAGRANULARITYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRenderingAreaGranularityKHR_after(device, pRenderingAreaInfo, pGranularity);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRenderingAreaGranularityKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateCommandPool(VkDevice device, VkCommandPoolCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateCommandPool!");
}
#ifdef CREATECOMMANDPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateCommandPool_before(device, pCreateInfo, pAllocator, pCommandPool);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->queueFamilyIndex=" + std::to_string(pCreateInfo->queueFamilyIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCommandPool=" + ptrToString((void**)std::addressof(pCommandPool)) + '!');
}
#ifdef CREATECOMMANDPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateCommandPool_after(device, pCreateInfo, pAllocator, pCommandPool);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateCommandPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyCommandPool(VkDevice device, VkCommandPool commandPool, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyCommandPool!");
}
#ifdef DESTROYCOMMANDPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyCommandPool_before(device, commandPool, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyCommandPool(device, commandPool, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"commandPool=" + ptrToString((void**)std::addressof(commandPool)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYCOMMANDPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyCommandPool_after(device, commandPool, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyCommandPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyCommandPool(device, commandPool, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetCommandPool!");
}
#ifdef RESETCOMMANDPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetCommandPool_before(device, commandPool, flags);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ResetCommandPool(device, commandPool, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"commandPool=" + ptrToString((void**)std::addressof(commandPool)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef RESETCOMMANDPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetCommandPool_after(device, commandPool, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetCommandPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ResetCommandPool(device, commandPool, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AllocateCommandBuffers(VkDevice device, VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAllocateCommandBuffers!");
}
#ifdef ALLOCATECOMMANDBUFFERS_BEFORE_EXEC_EXISTS
if(connected) {
layer_AllocateCommandBuffers_before(device, pAllocateInfo, pCommandBuffers);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAllocateInfo != VK_NULL_HANDLE && pAllocateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocateInfo->commandPool=" + ptrToString((void**)std::addressof(pAllocateInfo->commandPool)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocateInfo->commandBufferCount=" + std::to_string(pAllocateInfo->commandBufferCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocateInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCommandBuffers=" + ptrToString((void**)std::addressof(pCommandBuffers)) + '!');
}
#ifdef ALLOCATECOMMANDBUFFERS_AFTER_EXEC_EXISTS
if(connected) {
layer_AllocateCommandBuffers_after(device, pAllocateInfo, pCommandBuffers);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAllocateCommandBuffers!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkFreeCommandBuffers!");
}
#ifdef FREECOMMANDBUFFERS_BEFORE_EXEC_EXISTS
if(connected) {
layer_FreeCommandBuffers_before(device, commandPool, commandBufferCount, pCommandBuffers);
}
#endif 
device_dispatch[GetKey(device)].FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"commandPool=" + ptrToString((void**)std::addressof(commandPool)) + '!');
winsockSendToUI(&ConnectSocket,"commandBufferCount=" + std::to_string(commandBufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pCommandBuffers=" + ptrToString((void**)std::addressof(pCommandBuffers)) + '!');
}
#ifdef FREECOMMANDBUFFERS_AFTER_EXEC_EXISTS
if(connected) {
layer_FreeCommandBuffers_after(device, commandPool, commandBufferCount, pCommandBuffers);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkFreeCommandBuffers!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].FreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BeginCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo* pBeginInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBeginCommandBuffer!");
}
#ifdef BEGINCOMMANDBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_BeginCommandBuffer_before(commandBuffer, pBeginInfo);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].BeginCommandBuffer(commandBuffer, pBeginInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBeginInfo != VK_NULL_HANDLE && pBeginInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBeginInfo->flags=" + ptrToString((void**)std::addressof(pBeginInfo->flags)) + '!');
if(pBeginInfo->pInheritanceInfo != VK_NULL_HANDLE && pBeginInfo->pInheritanceInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->renderPass=" + ptrToString((void**)std::addressof(pBeginInfo->pInheritanceInfo->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->subpass=" + std::to_string(pBeginInfo->pInheritanceInfo->subpass) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->framebuffer=" + ptrToString((void**)std::addressof(pBeginInfo->pInheritanceInfo->framebuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->occlusionQueryEnable=" + bool_as_text(pBeginInfo->pInheritanceInfo->occlusionQueryEnable) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->queryFlags=" + ptrToString((void**)std::addressof(pBeginInfo->pInheritanceInfo->queryFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pInheritanceInfo->pipelineStatistics=" + ptrToString((void**)std::addressof(pBeginInfo->pInheritanceInfo->pipelineStatistics)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInheritanceInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pBeginInfo=VK_NULL_HANDLE!");
}
#ifdef BEGINCOMMANDBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_BeginCommandBuffer_after(commandBuffer, pBeginInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBeginCommandBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].BeginCommandBuffer(commandBuffer, pBeginInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_EndCommandBuffer(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkEndCommandBuffer!");
}
#ifdef ENDCOMMANDBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_EndCommandBuffer_before(commandBuffer);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].EndCommandBuffer(commandBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef ENDCOMMANDBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_EndCommandBuffer_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkEndCommandBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].EndCommandBuffer(commandBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetCommandBuffer!");
}
#ifdef RESETCOMMANDBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetCommandBuffer_before(commandBuffer, flags);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].ResetCommandBuffer(commandBuffer, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef RESETCOMMANDBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetCommandBuffer_after(commandBuffer, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetCommandBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].ResetCommandBuffer(commandBuffer, flags);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindPipeline!");
}
#ifdef CMDBINDPIPELINE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindPipeline_before(commandBuffer, pipelineBindPoint, pipeline);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
}
#ifdef CMDBINDPIPELINE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindPipeline_after(commandBuffer, pipelineBindPoint, pipeline);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindPipeline!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetAttachmentFeedbackLoopEnableEXT!");
}
#ifdef CMDSETATTACHMENTFEEDBACKLOOPENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetAttachmentFeedbackLoopEnableEXT_before(commandBuffer, aspectMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"aspectMask=" + ptrToString((void**)std::addressof(aspectMask)) + '!');
}
#ifdef CMDSETATTACHMENTFEEDBACKLOOPENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetAttachmentFeedbackLoopEnableEXT_after(commandBuffer, aspectMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetAttachmentFeedbackLoopEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport* pViewports) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewport!");
}
#ifdef CMDSETVIEWPORT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewport_before(commandBuffer, firstViewport, viewportCount, pViewports);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstViewport=" + std::to_string(firstViewport) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pViewports != VK_NULL_HANDLE && pViewports != NULL) {
winsockSendToUI(&ConnectSocket,"pViewports->x=" + std::to_string(pViewports->x) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->y=" + std::to_string(pViewports->y) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->width=" + std::to_string(pViewports->width) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->height=" + std::to_string(pViewports->height) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->minDepth=" + std::to_string(pViewports->minDepth) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->maxDepth=" + std::to_string(pViewports->maxDepth) + '!');
}else winsockSendToUI(&ConnectSocket, "pViewports=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewport_after(commandBuffer, firstViewport, viewportCount, pViewports);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewport!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D* pScissors) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetScissor!");
}
#ifdef CMDSETSCISSOR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetScissor_before(commandBuffer, firstScissor, scissorCount, pScissors);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstScissor=" + std::to_string(firstScissor) + '!');
winsockSendToUI(&ConnectSocket,"scissorCount=" + std::to_string(scissorCount) + '!');
if(pScissors != VK_NULL_HANDLE && pScissors != NULL) {
winsockSendToUI(&ConnectSocket,"pScissors->offset=" + ptrToString((void**)std::addressof(pScissors->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pScissors->extent=" + ptrToString((void**)std::addressof(pScissors->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pScissors=VK_NULL_HANDLE!");
}
#ifdef CMDSETSCISSOR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetScissor_after(commandBuffer, firstScissor, scissorCount, pScissors);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetScissor!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLineWidth!");
}
#ifdef CMDSETLINEWIDTH_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLineWidth_before(commandBuffer, lineWidth);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLineWidth(commandBuffer, lineWidth);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"lineWidth=" + std::to_string(lineWidth) + '!');
}
#ifdef CMDSETLINEWIDTH_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLineWidth_after(commandBuffer, lineWidth);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLineWidth!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLineWidth(commandBuffer, lineWidth);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBias!");
}
#ifdef CMDSETDEPTHBIAS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBias_before(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthBiasConstantFactor=" + std::to_string(depthBiasConstantFactor) + '!');
winsockSendToUI(&ConnectSocket,"depthBiasClamp=" + std::to_string(depthBiasClamp) + '!');
winsockSendToUI(&ConnectSocket,"depthBiasSlopeFactor=" + std::to_string(depthBiasSlopeFactor) + '!');
}
#ifdef CMDSETDEPTHBIAS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBias_after(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBias!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetBlendConstants(VkCommandBuffer commandBuffer, float* blendConstants) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetBlendConstants!");
}
#ifdef CMDSETBLENDCONSTANTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetBlendConstants_before(commandBuffer, blendConstants);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetBlendConstants(commandBuffer, blendConstants);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"blendConstants=" + ptrToString((void**)std::addressof(blendConstants[0])) + '!');
}
#ifdef CMDSETBLENDCONSTANTS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetBlendConstants_after(commandBuffer, blendConstants);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetBlendConstants!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetBlendConstants(commandBuffer, blendConstants);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBounds!");
}
#ifdef CMDSETDEPTHBOUNDS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBounds_before(commandBuffer, minDepthBounds, maxDepthBounds);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"minDepthBounds=" + std::to_string(minDepthBounds) + '!');
winsockSendToUI(&ConnectSocket,"maxDepthBounds=" + std::to_string(maxDepthBounds) + '!');
}
#ifdef CMDSETDEPTHBOUNDS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBounds_after(commandBuffer, minDepthBounds, maxDepthBounds);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBounds!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilCompareMask!");
}
#ifdef CMDSETSTENCILCOMPAREMASK_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilCompareMask_before(commandBuffer, faceMask, compareMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"faceMask=" + ptrToString((void**)std::addressof(faceMask)) + '!');
winsockSendToUI(&ConnectSocket,"compareMask=" + std::to_string(compareMask) + '!');
}
#ifdef CMDSETSTENCILCOMPAREMASK_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilCompareMask_after(commandBuffer, faceMask, compareMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilCompareMask!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilWriteMask!");
}
#ifdef CMDSETSTENCILWRITEMASK_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilWriteMask_before(commandBuffer, faceMask, writeMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"faceMask=" + ptrToString((void**)std::addressof(faceMask)) + '!');
winsockSendToUI(&ConnectSocket,"writeMask=" + std::to_string(writeMask) + '!');
}
#ifdef CMDSETSTENCILWRITEMASK_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilWriteMask_after(commandBuffer, faceMask, writeMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilWriteMask!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilReference!");
}
#ifdef CMDSETSTENCILREFERENCE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilReference_before(commandBuffer, faceMask, reference);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilReference(commandBuffer, faceMask, reference);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"faceMask=" + ptrToString((void**)std::addressof(faceMask)) + '!');
winsockSendToUI(&ConnectSocket,"reference=" + std::to_string(reference) + '!');
}
#ifdef CMDSETSTENCILREFERENCE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilReference_after(commandBuffer, faceMask, reference);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilReference!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilReference(commandBuffer, faceMask, reference);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t* pDynamicOffsets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindDescriptorSets!");
}
#ifdef CMDBINDDESCRIPTORSETS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorSets_before(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"firstSet=" + std::to_string(firstSet) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSetCount=" + std::to_string(descriptorSetCount) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorSets=" + ptrToString((void**)std::addressof(pDescriptorSets)) + '!');
winsockSendToUI(&ConnectSocket,"dynamicOffsetCount=" + std::to_string(dynamicOffsetCount) + '!');
}
#ifdef CMDBINDDESCRIPTORSETS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorSets_after(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindDescriptorSets!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindIndexBuffer!");
}
#ifdef CMDBINDINDEXBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindIndexBuffer_before(commandBuffer, buffer, offset, indexType);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
}
#ifdef CMDBINDINDEXBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindIndexBuffer_after(commandBuffer, buffer, offset, indexType);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindIndexBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindVertexBuffers!");
}
#ifdef CMDBINDVERTEXBUFFERS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers_before(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstBinding=" + std::to_string(firstBinding) + '!');
winsockSendToUI(&ConnectSocket,"bindingCount=" + std::to_string(bindingCount) + '!');
winsockSendToUI(&ConnectSocket,"pBuffers=" + ptrToString((void**)std::addressof(pBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pOffsets=" + ptrToString((void**)std::addressof(pOffsets)) + '!');
}
#ifdef CMDBINDVERTEXBUFFERS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers_after(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindVertexBuffers!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDraw!");
}
#ifdef CMDDRAW_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDraw_before(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"vertexCount=" + std::to_string(vertexCount) + '!');
winsockSendToUI(&ConnectSocket,"instanceCount=" + std::to_string(instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"firstVertex=" + std::to_string(firstVertex) + '!');
winsockSendToUI(&ConnectSocket,"firstInstance=" + std::to_string(firstInstance) + '!');
}
#ifdef CMDDRAW_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDraw_after(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDraw!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndexed!");
}
#ifdef CMDDRAWINDEXED_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexed_before(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"indexCount=" + std::to_string(indexCount) + '!');
winsockSendToUI(&ConnectSocket,"instanceCount=" + std::to_string(instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"firstIndex=" + std::to_string(firstIndex) + '!');
winsockSendToUI(&ConnectSocket,"vertexOffset=" + std::to_string(vertexOffset) + '!');
winsockSendToUI(&ConnectSocket,"firstInstance=" + std::to_string(firstInstance) + '!');
}
#ifdef CMDDRAWINDEXED_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexed_after(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndexed!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMultiEXT!");
}
#ifdef CMDDRAWMULTIEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMultiEXT_before(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
if(pVertexInfo != VK_NULL_HANDLE && pVertexInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pVertexInfo->firstVertex=" + std::to_string(pVertexInfo->firstVertex) + '!');
winsockSendToUI(&ConnectSocket,"pVertexInfo->vertexCount=" + std::to_string(pVertexInfo->vertexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pVertexInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"instanceCount=" + std::to_string(instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"firstInstance=" + std::to_string(firstInstance) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWMULTIEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMultiEXT_after(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMultiEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, int32_t* pVertexOffset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMultiIndexedEXT!");
}
#ifdef CMDDRAWMULTIINDEXEDEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMultiIndexedEXT_before(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
if(pIndexInfo != VK_NULL_HANDLE && pIndexInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pIndexInfo->firstIndex=" + std::to_string(pIndexInfo->firstIndex) + '!');
winsockSendToUI(&ConnectSocket,"pIndexInfo->indexCount=" + std::to_string(pIndexInfo->indexCount) + '!');
winsockSendToUI(&ConnectSocket,"pIndexInfo->vertexOffset=" + std::to_string(pIndexInfo->vertexOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pIndexInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"instanceCount=" + std::to_string(instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"firstInstance=" + std::to_string(firstInstance) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
winsockSendToUI(&ConnectSocket,"pVertexOffset=" + ptrToString((void**)std::addressof(pVertexOffset)) + '!');
}
#ifdef CMDDRAWMULTIINDEXEDEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMultiIndexedEXT_after(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMultiIndexedEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndirect!");
}
#ifdef CMDDRAWINDIRECT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirect_before(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDIRECT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirect_after(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndirect!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndexedIndirect!");
}
#ifdef CMDDRAWINDEXEDINDIRECT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirect_before(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDEXEDINDIRECT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirect_after(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndexedIndirect!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatch!");
}
#ifdef CMDDISPATCH_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatch_before(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"groupCountX=" + std::to_string(groupCountX) + '!');
winsockSendToUI(&ConnectSocket,"groupCountY=" + std::to_string(groupCountY) + '!');
winsockSendToUI(&ConnectSocket,"groupCountZ=" + std::to_string(groupCountZ) + '!');
}
#ifdef CMDDISPATCH_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatch_after(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatch!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchIndirect!");
}
#ifdef CMDDISPATCHINDIRECT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchIndirect_before(commandBuffer, buffer, offset);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchIndirect(commandBuffer, buffer, offset);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
}
#ifdef CMDDISPATCHINDIRECT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchIndirect_after(commandBuffer, buffer, offset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchIndirect!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchIndirect(commandBuffer, buffer, offset);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSubpassShadingHUAWEI!");
}
#ifdef CMDSUBPASSSHADINGHUAWEI_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSubpassShadingHUAWEI_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSubpassShadingHUAWEI(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSUBPASSSHADINGHUAWEI_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSubpassShadingHUAWEI_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSubpassShadingHUAWEI!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSubpassShadingHUAWEI(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawClusterHUAWEI!");
}
#ifdef CMDDRAWCLUSTERHUAWEI_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawClusterHUAWEI_before(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"groupCountX=" + std::to_string(groupCountX) + '!');
winsockSendToUI(&ConnectSocket,"groupCountY=" + std::to_string(groupCountY) + '!');
winsockSendToUI(&ConnectSocket,"groupCountZ=" + std::to_string(groupCountZ) + '!');
}
#ifdef CMDDRAWCLUSTERHUAWEI_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawClusterHUAWEI_after(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawClusterHUAWEI!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawClusterIndirectHUAWEI!");
}
#ifdef CMDDRAWCLUSTERINDIRECTHUAWEI_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawClusterIndirectHUAWEI_before(commandBuffer, buffer, offset);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
}
#ifdef CMDDRAWCLUSTERINDIRECTHUAWEI_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawClusterIndirectHUAWEI_after(commandBuffer, buffer, offset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawClusterIndirectHUAWEI!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdUpdatePipelineIndirectBufferNV!");
}
#ifdef CMDUPDATEPIPELINEINDIRECTBUFFERNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdUpdatePipelineIndirectBufferNV_before(commandBuffer, pipelineBindPoint, pipeline);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
}
#ifdef CMDUPDATEPIPELINEINDIRECTBUFFERNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdUpdatePipelineIndirectBufferNV_after(commandBuffer, pipelineBindPoint, pipeline);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdUpdatePipelineIndirectBufferNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy* pRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBuffer!");
}
#ifdef CMDCOPYBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer_before(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcBuffer=" + ptrToString((void**)std::addressof(srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->srcOffset=" + std::to_string(pRegions->srcOffset) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstOffset=" + std::to_string(pRegions->dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->size=" + std::to_string(pRegions->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer_after(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy* pRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImage!");
}
#ifdef CMDCOPYIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage_before(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcImage=" + ptrToString((void**)std::addressof(srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"dstImage=" + ptrToString((void**)std::addressof(dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->srcOffset=" + ptrToString((void**)std::addressof(pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstOffset=" + ptrToString((void**)std::addressof(pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->extent=" + ptrToString((void**)std::addressof(pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage_after(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit* pRegions, VkFilter filter) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBlitImage!");
}
#ifdef CMDBLITIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage_before(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcImage=" + ptrToString((void**)std::addressof(srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"dstImage=" + ptrToString((void**)std::addressof(dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->srcOffsets=" + ptrToString((void**)std::addressof(pRegions->srcOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstOffsets=" + ptrToString((void**)std::addressof(pRegions->dstOffsets)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDBLITIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage_after(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBlitImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy* pRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBufferToImage!");
}
#ifdef CMDCOPYBUFFERTOIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage_before(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcBuffer=" + ptrToString((void**)std::addressof(srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstImage=" + ptrToString((void**)std::addressof(dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->bufferOffset=" + std::to_string(pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->bufferRowLength=" + std::to_string(pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->bufferImageHeight=" + std::to_string(pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageOffset=" + ptrToString((void**)std::addressof(pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageExtent=" + ptrToString((void**)std::addressof(pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFERTOIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage_after(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBufferToImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy* pRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImageToBuffer!");
}
#ifdef CMDCOPYIMAGETOBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer_before(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcImage=" + ptrToString((void**)std::addressof(srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->bufferOffset=" + std::to_string(pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->bufferRowLength=" + std::to_string(pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->bufferImageHeight=" + std::to_string(pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageOffset=" + ptrToString((void**)std::addressof(pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->imageExtent=" + ptrToString((void**)std::addressof(pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGETOBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer_after(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImageToBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMemoryIndirectNV!");
}
#ifdef CMDCOPYMEMORYINDIRECTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryIndirectNV_before(commandBuffer, copyBufferAddress, copyCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"copyBufferAddress=" + ptrToString((void**)std::addressof(copyBufferAddress)) + '!');
winsockSendToUI(&ConnectSocket,"copyCount=" + std::to_string(copyCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDCOPYMEMORYINDIRECTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryIndirectNV_after(commandBuffer, copyBufferAddress, copyCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMemoryIndirectNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, VkImageSubresourceLayers* pImageSubresources) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMemoryToImageIndirectNV!");
}
#ifdef CMDCOPYMEMORYTOIMAGEINDIRECTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToImageIndirectNV_before(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"copyBufferAddress=" + ptrToString((void**)std::addressof(copyBufferAddress)) + '!');
winsockSendToUI(&ConnectSocket,"copyCount=" + std::to_string(copyCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
winsockSendToUI(&ConnectSocket,"dstImage=" + ptrToString((void**)std::addressof(dstImage)) + '!');
if(pImageSubresources != VK_NULL_HANDLE && pImageSubresources != NULL) {
winsockSendToUI(&ConnectSocket,"pImageSubresources->aspectMask=" + ptrToString((void**)std::addressof(pImageSubresources->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pImageSubresources->mipLevel=" + std::to_string(pImageSubresources->mipLevel) + '!');
winsockSendToUI(&ConnectSocket,"pImageSubresources->baseArrayLayer=" + std::to_string(pImageSubresources->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pImageSubresources->layerCount=" + std::to_string(pImageSubresources->layerCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageSubresources=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYMEMORYTOIMAGEINDIRECTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToImageIndirectNV_after(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMemoryToImageIndirectNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdUpdateBuffer!");
}
#ifdef CMDUPDATEBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdUpdateBuffer_before(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstOffset=" + std::to_string(dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef CMDUPDATEBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdUpdateBuffer_after(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdUpdateBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdFillBuffer!");
}
#ifdef CMDFILLBUFFER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdFillBuffer_before(commandBuffer, dstBuffer, dstOffset, size, data);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstOffset=" + std::to_string(dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"size=" + std::to_string(size) + '!');
winsockSendToUI(&ConnectSocket,"data=" + std::to_string(data) + '!');
}
#ifdef CMDFILLBUFFER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdFillBuffer_after(commandBuffer, dstBuffer, dstOffset, size, data);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdFillBuffer!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue* pColor, uint32_t rangeCount, VkImageSubresourceRange* pRanges) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdClearColorImage!");
}
#ifdef CMDCLEARCOLORIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdClearColorImage_before(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
winsockSendToUI(&ConnectSocket,"pColor=" + ptrToString((void**)std::addressof(pColor)) + '!');
winsockSendToUI(&ConnectSocket,"rangeCount=" + std::to_string(rangeCount) + '!');
if(pRanges != VK_NULL_HANDLE && pRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pRanges->aspectMask=" + ptrToString((void**)std::addressof(pRanges->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->baseMipLevel=" + std::to_string(pRanges->baseMipLevel) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->levelCount=" + std::to_string(pRanges->levelCount) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->baseArrayLayer=" + std::to_string(pRanges->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->layerCount=" + std::to_string(pRanges->layerCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pRanges=VK_NULL_HANDLE!");
}
#ifdef CMDCLEARCOLORIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdClearColorImage_after(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdClearColorImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange* pRanges) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdClearDepthStencilImage!");
}
#ifdef CMDCLEARDEPTHSTENCILIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdClearDepthStencilImage_before(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pDepthStencil != VK_NULL_HANDLE && pDepthStencil != NULL) {
winsockSendToUI(&ConnectSocket,"pDepthStencil->depth=" + std::to_string(pDepthStencil->depth) + '!');
winsockSendToUI(&ConnectSocket,"pDepthStencil->stencil=" + std::to_string(pDepthStencil->stencil) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthStencil=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"rangeCount=" + std::to_string(rangeCount) + '!');
if(pRanges != VK_NULL_HANDLE && pRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pRanges->aspectMask=" + ptrToString((void**)std::addressof(pRanges->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->baseMipLevel=" + std::to_string(pRanges->baseMipLevel) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->levelCount=" + std::to_string(pRanges->levelCount) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->baseArrayLayer=" + std::to_string(pRanges->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pRanges->layerCount=" + std::to_string(pRanges->layerCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pRanges=VK_NULL_HANDLE!");
}
#ifdef CMDCLEARDEPTHSTENCILIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdClearDepthStencilImage_after(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdClearDepthStencilImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment* pAttachments, uint32_t rectCount, VkClearRect* pRects) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdClearAttachments!");
}
#ifdef CMDCLEARATTACHMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdClearAttachments_before(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
if(pAttachments != VK_NULL_HANDLE && pAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pAttachments->aspectMask=" + ptrToString((void**)std::addressof(pAttachments->aspectMask)) + '!');
winsockSendToUI(&ConnectSocket,"pAttachments->colorAttachment=" + std::to_string(pAttachments->colorAttachment) + '!');
winsockSendToUI(&ConnectSocket,"pAttachments->clearValue=" + ptrToString((void**)std::addressof(pAttachments->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"rectCount=" + std::to_string(rectCount) + '!');
if(pRects != VK_NULL_HANDLE && pRects != NULL) {
winsockSendToUI(&ConnectSocket,"pRects->rect=" + ptrToString((void**)std::addressof(pRects->rect)) + '!');
winsockSendToUI(&ConnectSocket,"pRects->baseArrayLayer=" + std::to_string(pRects->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pRects->layerCount=" + std::to_string(pRects->layerCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pRects=VK_NULL_HANDLE!");
}
#ifdef CMDCLEARATTACHMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdClearAttachments_after(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdClearAttachments!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve* pRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResolveImage!");
}
#ifdef CMDRESOLVEIMAGE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage_before(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcImage=" + ptrToString((void**)std::addressof(srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"dstImage=" + ptrToString((void**)std::addressof(dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"regionCount=" + std::to_string(regionCount) + '!');
if(pRegions != VK_NULL_HANDLE && pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->srcOffset=" + ptrToString((void**)std::addressof(pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->dstOffset=" + ptrToString((void**)std::addressof(pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pRegions->extent=" + ptrToString((void**)std::addressof(pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}
#ifdef CMDRESOLVEIMAGE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage_after(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResolveImage!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetEvent!");
}
#ifdef CMDSETEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent_before(commandBuffer, event, stageMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetEvent(commandBuffer, event, stageMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
winsockSendToUI(&ConnectSocket,"stageMask=" + ptrToString((void**)std::addressof(stageMask)) + '!');
}
#ifdef CMDSETEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent_after(commandBuffer, event, stageMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetEvent(commandBuffer, event, stageMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResetEvent!");
}
#ifdef CMDRESETEVENT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent_before(commandBuffer, event, stageMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResetEvent(commandBuffer, event, stageMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
winsockSendToUI(&ConnectSocket,"stageMask=" + ptrToString((void**)std::addressof(stageMask)) + '!');
}
#ifdef CMDRESETEVENT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent_after(commandBuffer, event, stageMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResetEvent!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResetEvent(commandBuffer, event, stageMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWaitEvents!");
}
#ifdef CMDWAITEVENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents_before(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"eventCount=" + std::to_string(eventCount) + '!');
winsockSendToUI(&ConnectSocket,"pEvents=" + ptrToString((void**)std::addressof(pEvents)) + '!');
winsockSendToUI(&ConnectSocket,"srcStageMask=" + ptrToString((void**)std::addressof(srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"dstStageMask=" + ptrToString((void**)std::addressof(dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"memoryBarrierCount=" + std::to_string(memoryBarrierCount) + '!');
if(pMemoryBarriers != VK_NULL_HANDLE && pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"bufferMemoryBarrierCount=" + std::to_string(bufferMemoryBarrierCount) + '!');
if(pBufferMemoryBarriers != VK_NULL_HANDLE && pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->offset=" + std::to_string(pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->size=" + std::to_string(pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"imageMemoryBarrierCount=" + std::to_string(imageMemoryBarrierCount) + '!');
if(pImageMemoryBarriers != VK_NULL_HANDLE && pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}
#ifdef CMDWAITEVENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents_after(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWaitEvents!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier* pImageMemoryBarriers) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPipelineBarrier!");
}
#ifdef CMDPIPELINEBARRIER_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier_before(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"srcStageMask=" + ptrToString((void**)std::addressof(srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"dstStageMask=" + ptrToString((void**)std::addressof(dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"dependencyFlags=" + ptrToString((void**)std::addressof(dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"memoryBarrierCount=" + std::to_string(memoryBarrierCount) + '!');
if(pMemoryBarriers != VK_NULL_HANDLE && pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"bufferMemoryBarrierCount=" + std::to_string(bufferMemoryBarrierCount) + '!');
if(pBufferMemoryBarriers != VK_NULL_HANDLE && pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->offset=" + std::to_string(pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pBufferMemoryBarriers->size=" + std::to_string(pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"imageMemoryBarrierCount=" + std::to_string(imageMemoryBarrierCount) + '!');
if(pImageMemoryBarriers != VK_NULL_HANDLE && pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}
#ifdef CMDPIPELINEBARRIER_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier_after(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPipelineBarrier!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginQuery!");
}
#ifdef CMDBEGINQUERY_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginQuery_before(commandBuffer, queryPool, query, flags);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginQuery(commandBuffer, queryPool, query, flags);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef CMDBEGINQUERY_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginQuery_after(commandBuffer, queryPool, query, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginQuery!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginQuery(commandBuffer, queryPool, query, flags);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndQuery!");
}
#ifdef CMDENDQUERY_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndQuery_before(commandBuffer, queryPool, query);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndQuery(commandBuffer, queryPool, query);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
}
#ifdef CMDENDQUERY_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndQuery_after(commandBuffer, queryPool, query);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndQuery!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndQuery(commandBuffer, queryPool, query);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginConditionalRenderingEXT!");
}
#ifdef CMDBEGINCONDITIONALRENDERINGEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginConditionalRenderingEXT_before(commandBuffer, pConditionalRenderingBegin);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pConditionalRenderingBegin != VK_NULL_HANDLE && pConditionalRenderingBegin != NULL) {
winsockSendToUI(&ConnectSocket,"pConditionalRenderingBegin->buffer=" + ptrToString((void**)std::addressof(pConditionalRenderingBegin->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pConditionalRenderingBegin->offset=" + std::to_string(pConditionalRenderingBegin->offset) + '!');
winsockSendToUI(&ConnectSocket,"pConditionalRenderingBegin->flags=" + ptrToString((void**)std::addressof(pConditionalRenderingBegin->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pConditionalRenderingBegin=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINCONDITIONALRENDERINGEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginConditionalRenderingEXT_after(commandBuffer, pConditionalRenderingBegin);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginConditionalRenderingEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndConditionalRenderingEXT!");
}
#ifdef CMDENDCONDITIONALRENDERINGEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndConditionalRenderingEXT_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndConditionalRenderingEXT(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDENDCONDITIONALRENDERINGEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndConditionalRenderingEXT_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndConditionalRenderingEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndConditionalRenderingEXT(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResetQueryPool!");
}
#ifdef CMDRESETQUERYPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResetQueryPool_before(commandBuffer, queryPool, firstQuery, queryCount);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
winsockSendToUI(&ConnectSocket,"queryCount=" + std::to_string(queryCount) + '!');
}
#ifdef CMDRESETQUERYPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResetQueryPool_after(commandBuffer, queryPool, firstQuery, queryCount);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResetQueryPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteTimestamp!");
}
#ifdef CMDWRITETIMESTAMP_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp_before(commandBuffer, pipelineStage, queryPool, query);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
}
#ifdef CMDWRITETIMESTAMP_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp_after(commandBuffer, pipelineStage, queryPool, query);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteTimestamp!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyQueryPoolResults!");
}
#ifdef CMDCOPYQUERYPOOLRESULTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyQueryPoolResults_before(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
winsockSendToUI(&ConnectSocket,"queryCount=" + std::to_string(queryCount) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstOffset=" + std::to_string(dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef CMDCOPYQUERYPOOLRESULTS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyQueryPoolResults_after(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyQueryPoolResults!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void* pValues) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushConstants!");
}
#ifdef CMDPUSHCONSTANTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushConstants_before(commandBuffer, layout, stageFlags, offset, size, pValues);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"stageFlags=" + ptrToString((void**)std::addressof(stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"size=" + std::to_string(size) + '!');
}
#ifdef CMDPUSHCONSTANTS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushConstants_after(commandBuffer, layout, stageFlags, offset, size, pValues);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushConstants!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginRenderPass(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginRenderPass!");
}
#ifdef CMDBEGINRENDERPASS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass_before(commandBuffer, pRenderPassBegin, contents);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRenderPassBegin != VK_NULL_HANDLE && pRenderPassBegin != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderPass=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->framebuffer=" + ptrToString((void**)std::addressof(pRenderPassBegin->framebuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderArea=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->clearValueCount=" + std::to_string(pRenderPassBegin->clearValueCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->pClearValues=" + ptrToString((void**)std::addressof(pRenderPassBegin->pClearValues)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRenderPassBegin=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINRENDERPASS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass_after(commandBuffer, pRenderPassBegin, contents);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginRenderPass!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdNextSubpass!");
}
#ifdef CMDNEXTSUBPASS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass_before(commandBuffer, contents);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass(commandBuffer, contents);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDNEXTSUBPASS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass_after(commandBuffer, contents);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdNextSubpass!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass(commandBuffer, contents);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndRenderPass(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndRenderPass!");
}
#ifdef CMDENDRENDERPASS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDENDRENDERPASS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndRenderPass!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer* pCommandBuffers) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdExecuteCommands!");
}
#ifdef CMDEXECUTECOMMANDS_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdExecuteCommands_before(commandBuffer, commandBufferCount, pCommandBuffers);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"commandBufferCount=" + std::to_string(commandBufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pCommandBuffers=" + ptrToString((void**)std::addressof(pCommandBuffers)) + '!');
}
#ifdef CMDEXECUTECOMMANDS_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdExecuteCommands_after(commandBuffer, commandBufferCount, pCommandBuffers);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdExecuteCommands!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, VkSwapchainCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSharedSwapchainsKHR!");
}
#ifdef CREATESHAREDSWAPCHAINSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSharedSwapchainsKHR_before(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchainCount=" + std::to_string(swapchainCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->surface=" + ptrToString((void**)std::addressof(pCreateInfos->surface)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->minImageCount=" + std::to_string(pCreateInfos->minImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->imageExtent=" + ptrToString((void**)std::addressof(pCreateInfos->imageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->imageArrayLayers=" + std::to_string(pCreateInfos->imageArrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->imageUsage=" + ptrToString((void**)std::addressof(pCreateInfos->imageUsage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->queueFamilyIndexCount=" + std::to_string(pCreateInfos->queueFamilyIndexCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->clipped=" + bool_as_text(pCreateInfos->clipped) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->oldSwapchain=" + ptrToString((void**)std::addressof(pCreateInfos->oldSwapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->oldSwapchain=" + ptrToString((void**)std::addressof(pCreateInfos->oldSwapchain)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSwapchains=" + ptrToString((void**)std::addressof(pSwapchains)) + '!');
}
#ifdef CREATESHAREDSWAPCHAINSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSharedSwapchainsKHR_after(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSharedSwapchainsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSwapchainKHR(VkDevice device, VkSwapchainCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSwapchainKHR!");
}
#ifdef CREATESWAPCHAINKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSwapchainKHR_before(device, pCreateInfo, pAllocator, pSwapchain);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->surface=" + ptrToString((void**)std::addressof(pCreateInfo->surface)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->minImageCount=" + std::to_string(pCreateInfo->minImageCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->imageExtent=" + ptrToString((void**)std::addressof(pCreateInfo->imageExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->imageArrayLayers=" + std::to_string(pCreateInfo->imageArrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->imageUsage=" + ptrToString((void**)std::addressof(pCreateInfo->imageUsage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->queueFamilyIndexCount=" + std::to_string(pCreateInfo->queueFamilyIndexCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->clipped=" + bool_as_text(pCreateInfo->clipped) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->oldSwapchain=" + ptrToString((void**)std::addressof(pCreateInfo->oldSwapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->oldSwapchain=" + ptrToString((void**)std::addressof(pCreateInfo->oldSwapchain)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSwapchain=" + ptrToString((void**)std::addressof(pSwapchain)) + '!');
}
#ifdef CREATESWAPCHAINKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSwapchainKHR_after(device, pCreateInfo, pAllocator, pSwapchain);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSwapchainKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySwapchainKHR!");
}
#ifdef DESTROYSWAPCHAINKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySwapchainKHR_before(device, swapchain, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySwapchainKHR(device, swapchain, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSWAPCHAINKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySwapchainKHR_after(device, swapchain, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySwapchainKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySwapchainKHR(device, swapchain, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSwapchainImagesKHR!");
}
#ifdef GETSWAPCHAINIMAGESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSwapchainImagesKHR_before(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pSwapchainImages=" + ptrToString((void**)std::addressof(pSwapchainImages)) + '!');
}
#ifdef GETSWAPCHAINIMAGESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSwapchainImagesKHR_after(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSwapchainImagesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireNextImageKHR!");
}
#ifdef ACQUIRENEXTIMAGEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireNextImageKHR_before(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"timeout=" + std::to_string(timeout) + '!');
winsockSendToUI(&ConnectSocket,"semaphore=" + ptrToString((void**)std::addressof(semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef ACQUIRENEXTIMAGEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireNextImageKHR_after(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireNextImageKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueuePresentKHR(VkQueue queue, VkPresentInfoKHR* pPresentInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueuePresentKHR!");
}
#ifdef QUEUEPRESENTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueuePresentKHR_before(queue, pPresentInfo);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueuePresentKHR(queue, pPresentInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pPresentInfo != VK_NULL_HANDLE && pPresentInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPresentInfo->waitSemaphoreCount=" + std::to_string(pPresentInfo->waitSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pPresentInfo->pWaitSemaphores=" + ptrToString((void**)std::addressof(pPresentInfo->pWaitSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"pPresentInfo->swapchainCount=" + std::to_string(pPresentInfo->swapchainCount) + '!');
winsockSendToUI(&ConnectSocket,"pPresentInfo->pSwapchains=" + ptrToString((void**)std::addressof(pPresentInfo->pSwapchains)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPresentInfo=VK_NULL_HANDLE!");
}
#ifdef QUEUEPRESENTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_QueuePresentKHR_after(queue, pPresentInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueuePresentKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueuePresentKHR(queue, pPresentInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_DebugMarkerSetObjectNameEXT(VkDevice device, VkDebugMarkerObjectNameInfoEXT* pNameInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDebugMarkerSetObjectNameEXT!");
}
#ifdef DEBUGMARKERSETOBJECTNAMEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DebugMarkerSetObjectNameEXT_before(device, pNameInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].DebugMarkerSetObjectNameEXT(device, pNameInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pNameInfo != VK_NULL_HANDLE && pNameInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pNameInfo->object=" + std::to_string(pNameInfo->object) + '!');
}else winsockSendToUI(&ConnectSocket, "pNameInfo=VK_NULL_HANDLE!");
}
#ifdef DEBUGMARKERSETOBJECTNAMEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DebugMarkerSetObjectNameEXT_after(device, pNameInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDebugMarkerSetObjectNameEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].DebugMarkerSetObjectNameEXT(device, pNameInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_DebugMarkerSetObjectTagEXT(VkDevice device, VkDebugMarkerObjectTagInfoEXT* pTagInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDebugMarkerSetObjectTagEXT!");
}
#ifdef DEBUGMARKERSETOBJECTTAGEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DebugMarkerSetObjectTagEXT_before(device, pTagInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].DebugMarkerSetObjectTagEXT(device, pTagInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pTagInfo != VK_NULL_HANDLE && pTagInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pTagInfo->object=" + std::to_string(pTagInfo->object) + '!');
winsockSendToUI(&ConnectSocket,"pTagInfo->tagName=" + std::to_string(pTagInfo->tagName) + '!');
winsockSendToUI(&ConnectSocket,"pTagInfo->tagSize=" + std::to_string(pTagInfo->tagSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pTagInfo=VK_NULL_HANDLE!");
}
#ifdef DEBUGMARKERSETOBJECTTAGEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DebugMarkerSetObjectTagEXT_after(device, pTagInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDebugMarkerSetObjectTagEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].DebugMarkerSetObjectTagEXT(device, pTagInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDebugMarkerBeginEXT!");
}
#ifdef CMDDEBUGMARKERBEGINEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerBeginEXT_before(commandBuffer, pMarkerInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pMarkerInfo != VK_NULL_HANDLE && pMarkerInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef CMDDEBUGMARKERBEGINEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerBeginEXT_after(commandBuffer, pMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDebugMarkerBeginEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDebugMarkerEndEXT!");
}
#ifdef CMDDEBUGMARKERENDEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerEndEXT_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerEndEXT(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDDEBUGMARKERENDEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerEndEXT_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDebugMarkerEndEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerEndEXT(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDebugMarkerInsertEXT!");
}
#ifdef CMDDEBUGMARKERINSERTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerInsertEXT_before(commandBuffer, pMarkerInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pMarkerInfo != VK_NULL_HANDLE && pMarkerInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef CMDDEBUGMARKERINSERTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDebugMarkerInsertEXT_after(commandBuffer, pMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDebugMarkerInsertEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
}
}

#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryWin32HandleNV!");
}
#ifdef GETMEMORYWIN32HANDLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandleNV_before(device, memory, handleType, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandleNV(device, memory, handleType, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"handleType=" + ptrToString((void**)std::addressof(handleType)) + '!');
winsockSendToUI(&ConnectSocket,"pHandle=" + ptrToString((void**)std::addressof(pHandle)) + '!');
}
#ifdef GETMEMORYWIN32HANDLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandleNV_after(device, memory, handleType, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryWin32HandleNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandleNV(device, memory, handleType, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdExecuteGeneratedCommandsNV!");
}
#ifdef CMDEXECUTEGENERATEDCOMMANDSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdExecuteGeneratedCommandsNV_before(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"isPreprocessed=" + bool_as_text(isPreprocessed) + '!');
if(pGeneratedCommandsInfo != VK_NULL_HANDLE && pGeneratedCommandsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pipeline=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->indirectCommandsLayout=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->indirectCommandsLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->streamCount=" + std::to_string(pGeneratedCommandsInfo->streamCount) + '!');
if(pGeneratedCommandsInfo->pStreams != VK_NULL_HANDLE && pGeneratedCommandsInfo->pStreams != NULL) {
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pStreams->buffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->pStreams->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pStreams->offset=" + std::to_string(pGeneratedCommandsInfo->pStreams->offset) + '!');
}else winsockSendToUI(&ConnectSocket, "pStreams=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCount=" + std::to_string(pGeneratedCommandsInfo->sequencesCount) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->preprocessBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessOffset=" + std::to_string(pGeneratedCommandsInfo->preprocessOffset) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessSize=" + std::to_string(pGeneratedCommandsInfo->preprocessSize) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCountBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->sequencesCountBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCountOffset=" + std::to_string(pGeneratedCommandsInfo->sequencesCountOffset) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesIndexBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->sequencesIndexBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesIndexOffset=" + std::to_string(pGeneratedCommandsInfo->sequencesIndexOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeneratedCommandsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDEXECUTEGENERATEDCOMMANDSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdExecuteGeneratedCommandsNV_after(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdExecuteGeneratedCommandsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPreprocessGeneratedCommandsNV!");
}
#ifdef CMDPREPROCESSGENERATEDCOMMANDSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPreprocessGeneratedCommandsNV_before(commandBuffer, pGeneratedCommandsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pGeneratedCommandsInfo != VK_NULL_HANDLE && pGeneratedCommandsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pipeline=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->indirectCommandsLayout=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->indirectCommandsLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->streamCount=" + std::to_string(pGeneratedCommandsInfo->streamCount) + '!');
if(pGeneratedCommandsInfo->pStreams != VK_NULL_HANDLE && pGeneratedCommandsInfo->pStreams != NULL) {
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pStreams->buffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->pStreams->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->pStreams->offset=" + std::to_string(pGeneratedCommandsInfo->pStreams->offset) + '!');
}else winsockSendToUI(&ConnectSocket, "pStreams=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCount=" + std::to_string(pGeneratedCommandsInfo->sequencesCount) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->preprocessBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessOffset=" + std::to_string(pGeneratedCommandsInfo->preprocessOffset) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->preprocessSize=" + std::to_string(pGeneratedCommandsInfo->preprocessSize) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCountBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->sequencesCountBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesCountOffset=" + std::to_string(pGeneratedCommandsInfo->sequencesCountOffset) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesIndexBuffer=" + ptrToString((void**)std::addressof(pGeneratedCommandsInfo->sequencesIndexBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pGeneratedCommandsInfo->sequencesIndexOffset=" + std::to_string(pGeneratedCommandsInfo->sequencesIndexOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeneratedCommandsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPREPROCESSGENERATEDCOMMANDSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPreprocessGeneratedCommandsNV_after(commandBuffer, pGeneratedCommandsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPreprocessGeneratedCommandsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindPipelineShaderGroupNV!");
}
#ifdef CMDBINDPIPELINESHADERGROUPNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindPipelineShaderGroupNV_before(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"groupIndex=" + std::to_string(groupIndex) + '!');
}
#ifdef CMDBINDPIPELINESHADERGROUPNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindPipelineShaderGroupNV_after(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindPipelineShaderGroupNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetGeneratedCommandsMemoryRequirementsNV!");
}
#ifdef GETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetGeneratedCommandsMemoryRequirementsNV_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pipeline=" + ptrToString((void**)std::addressof(pInfo->pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->indirectCommandsLayout=" + ptrToString((void**)std::addressof(pInfo->indirectCommandsLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->maxSequencesCount=" + std::to_string(pInfo->maxSequencesCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETGENERATEDCOMMANDSMEMORYREQUIREMENTSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetGeneratedCommandsMemoryRequirementsNV_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetGeneratedCommandsMemoryRequirementsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNV* pIndirectCommandsLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateIndirectCommandsLayoutNV!");
}
#ifdef CREATEINDIRECTCOMMANDSLAYOUTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateIndirectCommandsLayoutNV_before(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->tokenCount=" + std::to_string(pCreateInfo->tokenCount) + '!');
if(pCreateInfo->pTokens != VK_NULL_HANDLE && pCreateInfo->pTokens != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->stream=" + std::to_string(pCreateInfo->pTokens->stream) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->offset=" + std::to_string(pCreateInfo->pTokens->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->vertexBindingUnit=" + std::to_string(pCreateInfo->pTokens->vertexBindingUnit) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->vertexDynamicStride=" + bool_as_text(pCreateInfo->pTokens->vertexDynamicStride) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->pushconstantPipelineLayout=" + ptrToString((void**)std::addressof(pCreateInfo->pTokens->pushconstantPipelineLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->pushconstantShaderStageFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pTokens->pushconstantShaderStageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->pushconstantOffset=" + std::to_string(pCreateInfo->pTokens->pushconstantOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->pushconstantSize=" + std::to_string(pCreateInfo->pTokens->pushconstantSize) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->indirectStateFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pTokens->indirectStateFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->indexTypeCount=" + std::to_string(pCreateInfo->pTokens->indexTypeCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pTokens->pIndexTypes=" + ptrToString((void**)std::addressof(pCreateInfo->pTokens->pIndexTypes)) + '!');
}else winsockSendToUI(&ConnectSocket, "pTokens=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->streamCount=" + std::to_string(pCreateInfo->streamCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pIndirectCommandsLayout=" + ptrToString((void**)std::addressof(pIndirectCommandsLayout)) + '!');
}
#ifdef CREATEINDIRECTCOMMANDSLAYOUTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateIndirectCommandsLayoutNV_after(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateIndirectCommandsLayoutNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyIndirectCommandsLayoutNV!");
}
#ifdef DESTROYINDIRECTCOMMANDSLAYOUTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyIndirectCommandsLayoutNV_before(device, indirectCommandsLayout, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"indirectCommandsLayout=" + ptrToString((void**)std::addressof(indirectCommandsLayout)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYINDIRECTCOMMANDSLAYOUTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyIndirectCommandsLayoutNV_after(device, indirectCommandsLayout, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyIndirectCommandsLayoutNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, VkWriteDescriptorSet* pDescriptorWrites) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushDescriptorSetKHR!");
}
#ifdef CMDPUSHDESCRIPTORSETKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetKHR_before(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"set=" + std::to_string(set) + '!');
winsockSendToUI(&ConnectSocket,"descriptorWriteCount=" + std::to_string(descriptorWriteCount) + '!');
if(pDescriptorWrites != VK_NULL_HANDLE && pDescriptorWrites != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstSet=" + ptrToString((void**)std::addressof(pDescriptorWrites->dstSet)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstBinding=" + std::to_string(pDescriptorWrites->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->dstArrayElement=" + std::to_string(pDescriptorWrites->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->descriptorCount=" + std::to_string(pDescriptorWrites->descriptorCount) + '!');
if(pDescriptorWrites->pImageInfo != VK_NULL_HANDLE && pDescriptorWrites->pImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pImageInfo->sampler=" + ptrToString((void**)std::addressof(pDescriptorWrites->pImageInfo->sampler)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pImageInfo->imageView=" + ptrToString((void**)std::addressof(pDescriptorWrites->pImageInfo->imageView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageInfo=VK_NULL_HANDLE!");
if(pDescriptorWrites->pBufferInfo != VK_NULL_HANDLE && pDescriptorWrites->pBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->buffer=" + ptrToString((void**)std::addressof(pDescriptorWrites->pBufferInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->offset=" + std::to_string(pDescriptorWrites->pBufferInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pBufferInfo->range=" + std::to_string(pDescriptorWrites->pBufferInfo->range) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorWrites->pTexelBufferView=" + ptrToString((void**)std::addressof(pDescriptorWrites->pTexelBufferView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorWrites=VK_NULL_HANDLE!");
}
#ifdef CMDPUSHDESCRIPTORSETKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetKHR_after(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushDescriptorSetKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkTrimCommandPool!");
}
#ifdef TRIMCOMMANDPOOL_BEFORE_EXEC_EXISTS
if(connected) {
layer_TrimCommandPool_before(device, commandPool, flags);
}
#endif 
device_dispatch[GetKey(device)].TrimCommandPool(device, commandPool, flags);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"commandPool=" + ptrToString((void**)std::addressof(commandPool)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef TRIMCOMMANDPOOL_AFTER_EXEC_EXISTS
if(connected) {
layer_TrimCommandPool_after(device, commandPool, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkTrimCommandPool!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].TrimCommandPool(device, commandPool, flags);
}
}

#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryWin32HandleKHR(VkDevice device, VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryWin32HandleKHR!");
}
#ifdef GETMEMORYWIN32HANDLEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandleKHR_before(device, pGetWin32HandleInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetWin32HandleInfo != VK_NULL_HANDLE && pGetWin32HandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetWin32HandleInfo->memory=" + ptrToString((void**)std::addressof(pGetWin32HandleInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetWin32HandleInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pHandle=" + ptrToString((void**)std::addressof(pHandle)) + '!');
}
#ifdef GETMEMORYWIN32HANDLEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandleKHR_after(device, pGetWin32HandleInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryWin32HandleKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryWin32HandlePropertiesKHR!");
}
#ifdef GETMEMORYWIN32HANDLEPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandlePropertiesKHR_before(device, handleType, handle, pMemoryWin32HandleProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"handle=" + ptrToString((void**)std::addressof(handle)) + '!');
if(pMemoryWin32HandleProperties != VK_NULL_HANDLE && pMemoryWin32HandleProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryWin32HandleProperties->memoryTypeBits=" + std::to_string(pMemoryWin32HandleProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryWin32HandleProperties=VK_NULL_HANDLE!");
}
#ifdef GETMEMORYWIN32HANDLEPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryWin32HandlePropertiesKHR_after(device, handleType, handle, pMemoryWin32HandleProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryWin32HandlePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryFdKHR(VkDevice device, VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryFdKHR!");
}
#ifdef GETMEMORYFDKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryFdKHR_before(device, pGetFdInfo, pFd);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetFdInfo != VK_NULL_HANDLE && pGetFdInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetFdInfo->memory=" + ptrToString((void**)std::addressof(pGetFdInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetFdInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFd=" + ptrToString((void**)std::addressof(pFd)) + '!');
}
#ifdef GETMEMORYFDKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryFdKHR_after(device, pGetFdInfo, pFd);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryFdKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryFdPropertiesKHR!");
}
#ifdef GETMEMORYFDPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryFdPropertiesKHR_before(device, handleType, fd, pMemoryFdProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"fd=" + std::to_string(fd) + '!');
if(pMemoryFdProperties != VK_NULL_HANDLE && pMemoryFdProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryFdProperties->memoryTypeBits=" + std::to_string(pMemoryFdProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryFdProperties=VK_NULL_HANDLE!");
}
#ifdef GETMEMORYFDPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryFdPropertiesKHR_after(device, handleType, fd, pMemoryFdProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryFdPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryZirconHandleFUCHSIA(VkDevice device, VkMemoryGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryZirconHandleFUCHSIA!");
}
#ifdef GETMEMORYZIRCONHANDLEFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryZirconHandleFUCHSIA_before(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetZirconHandleInfo != VK_NULL_HANDLE && pGetZirconHandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetZirconHandleInfo->memory=" + ptrToString((void**)std::addressof(pGetZirconHandleInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetZirconHandleInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pZirconHandle=" + ptrToString((void**)std::addressof(pZirconHandle)) + '!');
}
#ifdef GETMEMORYZIRCONHANDLEFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryZirconHandleFUCHSIA_after(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryZirconHandleFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA* pMemoryZirconHandleProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryZirconHandlePropertiesFUCHSIA!");
}
#ifdef GETMEMORYZIRCONHANDLEPROPERTIESFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryZirconHandlePropertiesFUCHSIA_before(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"zirconHandle=" + ptrToString((void**)std::addressof(zirconHandle)) + '!');
if(pMemoryZirconHandleProperties != VK_NULL_HANDLE && pMemoryZirconHandleProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryZirconHandleProperties->memoryTypeBits=" + std::to_string(pMemoryZirconHandleProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryZirconHandleProperties=VK_NULL_HANDLE!");
}
#ifdef GETMEMORYZIRCONHANDLEPROPERTIESFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryZirconHandlePropertiesFUCHSIA_after(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryZirconHandlePropertiesFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, pMemoryZirconHandleProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryRemoteAddressNV(VkDevice device, VkMemoryGetRemoteAddressInfoNV* pMemoryGetRemoteAddressInfo, VkRemoteAddressNV* pAddress) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryRemoteAddressNV!");
}
#ifdef GETMEMORYREMOTEADDRESSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryRemoteAddressNV_before(device, pMemoryGetRemoteAddressInfo, pAddress);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pMemoryGetRemoteAddressInfo != VK_NULL_HANDLE && pMemoryGetRemoteAddressInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryGetRemoteAddressInfo->memory=" + ptrToString((void**)std::addressof(pMemoryGetRemoteAddressInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryGetRemoteAddressInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pAddress=" + ptrToString((void**)std::addressof(pAddress)) + '!');
}
#ifdef GETMEMORYREMOTEADDRESSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryRemoteAddressNV_after(device, pMemoryGetRemoteAddressInfo, pAddress);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryRemoteAddressNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemorySciBufNV(VkDevice device, VkMemoryGetSciBufInfoNV* pGetSciBufInfo, NvSciBufObj* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemorySciBufNV!");
}
#ifdef GETMEMORYSCIBUFNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemorySciBufNV_before(device, pGetSciBufInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemorySciBufNV(device, pGetSciBufInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetSciBufInfo != VK_NULL_HANDLE && pGetSciBufInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetSciBufInfo->memory=" + ptrToString((void**)std::addressof(pGetSciBufInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetSciBufInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pHandle=" + ptrToString((void**)std::addressof(pHandle)) + '!');
}
#ifdef GETMEMORYSCIBUFNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemorySciBufNV_after(device, pGetSciBufInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemorySciBufNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemorySciBufNV(device, pGetSciBufInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreWin32HandleKHR(VkDevice device, VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreWin32HandleKHR!");
}
#ifdef GETSEMAPHOREWIN32HANDLEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreWin32HandleKHR_before(device, pGetWin32HandleInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetWin32HandleInfo != VK_NULL_HANDLE && pGetWin32HandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetWin32HandleInfo->semaphore=" + ptrToString((void**)std::addressof(pGetWin32HandleInfo->semaphore)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetWin32HandleInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pHandle=" + ptrToString((void**)std::addressof(pHandle)) + '!');
}
#ifdef GETSEMAPHOREWIN32HANDLEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreWin32HandleKHR_after(device, pGetWin32HandleInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreWin32HandleKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportSemaphoreWin32HandleKHR(VkDevice device, VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportSemaphoreWin32HandleKHR!");
}
#ifdef IMPORTSEMAPHOREWIN32HANDLEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreWin32HandleKHR_before(device, pImportSemaphoreWin32HandleInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportSemaphoreWin32HandleInfo != VK_NULL_HANDLE && pImportSemaphoreWin32HandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportSemaphoreWin32HandleInfo->semaphore=" + ptrToString((void**)std::addressof(pImportSemaphoreWin32HandleInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreWin32HandleInfo->flags=" + ptrToString((void**)std::addressof(pImportSemaphoreWin32HandleInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreWin32HandleInfo->handle=" + ptrToString((void**)std::addressof(pImportSemaphoreWin32HandleInfo->handle)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreWin32HandleInfo->name=" + ptrToString((void**)std::addressof(pImportSemaphoreWin32HandleInfo->name)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportSemaphoreWin32HandleInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTSEMAPHOREWIN32HANDLEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreWin32HandleKHR_after(device, pImportSemaphoreWin32HandleInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportSemaphoreWin32HandleKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreFdKHR(VkDevice device, VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreFdKHR!");
}
#ifdef GETSEMAPHOREFDKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreFdKHR_before(device, pGetFdInfo, pFd);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetFdInfo != VK_NULL_HANDLE && pGetFdInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetFdInfo->semaphore=" + ptrToString((void**)std::addressof(pGetFdInfo->semaphore)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetFdInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFd=" + ptrToString((void**)std::addressof(pFd)) + '!');
}
#ifdef GETSEMAPHOREFDKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreFdKHR_after(device, pGetFdInfo, pFd);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreFdKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportSemaphoreFdKHR(VkDevice device, VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportSemaphoreFdKHR!");
}
#ifdef IMPORTSEMAPHOREFDKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreFdKHR_before(device, pImportSemaphoreFdInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportSemaphoreFdInfo != VK_NULL_HANDLE && pImportSemaphoreFdInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportSemaphoreFdInfo->semaphore=" + ptrToString((void**)std::addressof(pImportSemaphoreFdInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreFdInfo->flags=" + ptrToString((void**)std::addressof(pImportSemaphoreFdInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreFdInfo->fd=" + std::to_string(pImportSemaphoreFdInfo->fd) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportSemaphoreFdInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTSEMAPHOREFDKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreFdKHR_after(device, pImportSemaphoreFdInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportSemaphoreFdKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreZirconHandleFUCHSIA(VkDevice device, VkSemaphoreGetZirconHandleInfoFUCHSIA* pGetZirconHandleInfo, zx_handle_t* pZirconHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreZirconHandleFUCHSIA!");
}
#ifdef GETSEMAPHOREZIRCONHANDLEFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreZirconHandleFUCHSIA_before(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetZirconHandleInfo != VK_NULL_HANDLE && pGetZirconHandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetZirconHandleInfo->semaphore=" + ptrToString((void**)std::addressof(pGetZirconHandleInfo->semaphore)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetZirconHandleInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pZirconHandle=" + ptrToString((void**)std::addressof(pZirconHandle)) + '!');
}
#ifdef GETSEMAPHOREZIRCONHANDLEFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreZirconHandleFUCHSIA_after(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreZirconHandleFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, VkImportSemaphoreZirconHandleInfoFUCHSIA* pImportSemaphoreZirconHandleInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportSemaphoreZirconHandleFUCHSIA!");
}
#ifdef IMPORTSEMAPHOREZIRCONHANDLEFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreZirconHandleFUCHSIA_before(device, pImportSemaphoreZirconHandleInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportSemaphoreZirconHandleInfo != VK_NULL_HANDLE && pImportSemaphoreZirconHandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportSemaphoreZirconHandleInfo->semaphore=" + ptrToString((void**)std::addressof(pImportSemaphoreZirconHandleInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreZirconHandleInfo->flags=" + ptrToString((void**)std::addressof(pImportSemaphoreZirconHandleInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImportSemaphoreZirconHandleInfo->zirconHandle=" + ptrToString((void**)std::addressof(pImportSemaphoreZirconHandleInfo->zirconHandle)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportSemaphoreZirconHandleInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTSEMAPHOREZIRCONHANDLEFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreZirconHandleFUCHSIA_after(device, pImportSemaphoreZirconHandleInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportSemaphoreZirconHandleFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFenceWin32HandleKHR(VkDevice device, VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFenceWin32HandleKHR!");
}
#ifdef GETFENCEWIN32HANDLEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFenceWin32HandleKHR_before(device, pGetWin32HandleInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetWin32HandleInfo != VK_NULL_HANDLE && pGetWin32HandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetWin32HandleInfo->fence=" + ptrToString((void**)std::addressof(pGetWin32HandleInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetWin32HandleInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pHandle=" + ptrToString((void**)std::addressof(pHandle)) + '!');
}
#ifdef GETFENCEWIN32HANDLEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFenceWin32HandleKHR_after(device, pGetWin32HandleInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFenceWin32HandleKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportFenceWin32HandleKHR(VkDevice device, VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportFenceWin32HandleKHR!");
}
#ifdef IMPORTFENCEWIN32HANDLEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportFenceWin32HandleKHR_before(device, pImportFenceWin32HandleInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportFenceWin32HandleInfo != VK_NULL_HANDLE && pImportFenceWin32HandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportFenceWin32HandleInfo->fence=" + ptrToString((void**)std::addressof(pImportFenceWin32HandleInfo->fence)) + '!');
winsockSendToUI(&ConnectSocket,"pImportFenceWin32HandleInfo->flags=" + ptrToString((void**)std::addressof(pImportFenceWin32HandleInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImportFenceWin32HandleInfo->handle=" + ptrToString((void**)std::addressof(pImportFenceWin32HandleInfo->handle)) + '!');
winsockSendToUI(&ConnectSocket,"pImportFenceWin32HandleInfo->name=" + ptrToString((void**)std::addressof(pImportFenceWin32HandleInfo->name)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportFenceWin32HandleInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTFENCEWIN32HANDLEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportFenceWin32HandleKHR_after(device, pImportFenceWin32HandleInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportFenceWin32HandleKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFenceFdKHR(VkDevice device, VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFenceFdKHR!");
}
#ifdef GETFENCEFDKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFenceFdKHR_before(device, pGetFdInfo, pFd);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFenceFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetFdInfo != VK_NULL_HANDLE && pGetFdInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetFdInfo->fence=" + ptrToString((void**)std::addressof(pGetFdInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetFdInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFd=" + ptrToString((void**)std::addressof(pFd)) + '!');
}
#ifdef GETFENCEFDKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFenceFdKHR_after(device, pGetFdInfo, pFd);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFenceFdKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFenceFdKHR(device, pGetFdInfo, pFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportFenceFdKHR(VkDevice device, VkImportFenceFdInfoKHR* pImportFenceFdInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportFenceFdKHR!");
}
#ifdef IMPORTFENCEFDKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportFenceFdKHR_before(device, pImportFenceFdInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportFenceFdKHR(device, pImportFenceFdInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportFenceFdInfo != VK_NULL_HANDLE && pImportFenceFdInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportFenceFdInfo->fence=" + ptrToString((void**)std::addressof(pImportFenceFdInfo->fence)) + '!');
winsockSendToUI(&ConnectSocket,"pImportFenceFdInfo->flags=" + ptrToString((void**)std::addressof(pImportFenceFdInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImportFenceFdInfo->fd=" + std::to_string(pImportFenceFdInfo->fd) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportFenceFdInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTFENCEFDKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportFenceFdKHR_after(device, pImportFenceFdInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportFenceFdKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportFenceFdKHR(device, pImportFenceFdInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFenceSciSyncFenceNV(VkDevice device, VkFenceGetSciSyncInfoNV* pGetSciSyncHandleInfo, void* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFenceSciSyncFenceNV!");
}
#ifdef GETFENCESCISYNCFENCENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFenceSciSyncFenceNV_before(device, pGetSciSyncHandleInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFenceSciSyncFenceNV(device, pGetSciSyncHandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetSciSyncHandleInfo != VK_NULL_HANDLE && pGetSciSyncHandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetSciSyncHandleInfo->fence=" + ptrToString((void**)std::addressof(pGetSciSyncHandleInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetSciSyncHandleInfo=VK_NULL_HANDLE!");
}
#ifdef GETFENCESCISYNCFENCENV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFenceSciSyncFenceNV_after(device, pGetSciSyncHandleInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFenceSciSyncFenceNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFenceSciSyncFenceNV(device, pGetSciSyncHandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFenceSciSyncObjNV(VkDevice device, VkFenceGetSciSyncInfoNV* pGetSciSyncHandleInfo, void* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFenceSciSyncObjNV!");
}
#ifdef GETFENCESCISYNCOBJNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFenceSciSyncObjNV_before(device, pGetSciSyncHandleInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFenceSciSyncObjNV(device, pGetSciSyncHandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetSciSyncHandleInfo != VK_NULL_HANDLE && pGetSciSyncHandleInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetSciSyncHandleInfo->fence=" + ptrToString((void**)std::addressof(pGetSciSyncHandleInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetSciSyncHandleInfo=VK_NULL_HANDLE!");
}
#ifdef GETFENCESCISYNCOBJNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFenceSciSyncObjNV_after(device, pGetSciSyncHandleInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFenceSciSyncObjNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFenceSciSyncObjNV(device, pGetSciSyncHandleInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportFenceSciSyncFenceNV(VkDevice device, VkImportFenceSciSyncInfoNV* pImportFenceSciSyncInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportFenceSciSyncFenceNV!");
}
#ifdef IMPORTFENCESCISYNCFENCENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportFenceSciSyncFenceNV_before(device, pImportFenceSciSyncInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportFenceSciSyncFenceNV(device, pImportFenceSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportFenceSciSyncInfo != VK_NULL_HANDLE && pImportFenceSciSyncInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportFenceSciSyncInfo->fence=" + ptrToString((void**)std::addressof(pImportFenceSciSyncInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportFenceSciSyncInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTFENCESCISYNCFENCENV_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportFenceSciSyncFenceNV_after(device, pImportFenceSciSyncInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportFenceSciSyncFenceNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportFenceSciSyncFenceNV(device, pImportFenceSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportFenceSciSyncObjNV(VkDevice device, VkImportFenceSciSyncInfoNV* pImportFenceSciSyncInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportFenceSciSyncObjNV!");
}
#ifdef IMPORTFENCESCISYNCOBJNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportFenceSciSyncObjNV_before(device, pImportFenceSciSyncInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportFenceSciSyncObjNV(device, pImportFenceSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportFenceSciSyncInfo != VK_NULL_HANDLE && pImportFenceSciSyncInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportFenceSciSyncInfo->fence=" + ptrToString((void**)std::addressof(pImportFenceSciSyncInfo->fence)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportFenceSciSyncInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTFENCESCISYNCOBJNV_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportFenceSciSyncObjNV_after(device, pImportFenceSciSyncInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportFenceSciSyncObjNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportFenceSciSyncObjNV(device, pImportFenceSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreSciSyncObjNV(VkDevice device, VkSemaphoreGetSciSyncInfoNV* pGetSciSyncInfo, void* pHandle) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreSciSyncObjNV!");
}
#ifdef GETSEMAPHORESCISYNCOBJNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreSciSyncObjNV_before(device, pGetSciSyncInfo, pHandle);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreSciSyncObjNV(device, pGetSciSyncInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pGetSciSyncInfo != VK_NULL_HANDLE && pGetSciSyncInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pGetSciSyncInfo->semaphore=" + ptrToString((void**)std::addressof(pGetSciSyncInfo->semaphore)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGetSciSyncInfo=VK_NULL_HANDLE!");
}
#ifdef GETSEMAPHORESCISYNCOBJNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreSciSyncObjNV_after(device, pGetSciSyncInfo, pHandle);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreSciSyncObjNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreSciSyncObjNV(device, pGetSciSyncInfo, pHandle);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ImportSemaphoreSciSyncObjNV(VkDevice device, VkImportSemaphoreSciSyncInfoNV* pImportSemaphoreSciSyncInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkImportSemaphoreSciSyncObjNV!");
}
#ifdef IMPORTSEMAPHORESCISYNCOBJNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreSciSyncObjNV_before(device, pImportSemaphoreSciSyncInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreSciSyncObjNV(device, pImportSemaphoreSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pImportSemaphoreSciSyncInfo != VK_NULL_HANDLE && pImportSemaphoreSciSyncInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImportSemaphoreSciSyncInfo->semaphore=" + ptrToString((void**)std::addressof(pImportSemaphoreSciSyncInfo->semaphore)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImportSemaphoreSciSyncInfo=VK_NULL_HANDLE!");
}
#ifdef IMPORTSEMAPHORESCISYNCOBJNV_AFTER_EXEC_EXISTS
if(connected) {
layer_ImportSemaphoreSciSyncObjNV_after(device, pImportSemaphoreSciSyncInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkImportSemaphoreSciSyncObjNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ImportSemaphoreSciSyncObjNV(device, pImportSemaphoreSciSyncInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSemaphoreSciSyncPoolNV(VkDevice device, VkSemaphoreSciSyncPoolCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSemaphoreSciSyncPoolNV* pSemaphorePool) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSemaphoreSciSyncPoolNV!");
}
#ifdef CREATESEMAPHORESCISYNCPOOLNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSemaphoreSciSyncPoolNV_before(device, pCreateInfo, pAllocator, pSemaphorePool);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSemaphoreSciSyncPoolNV(device, pCreateInfo, pAllocator, pSemaphorePool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->handle=" + ptrToString((void**)std::addressof(pCreateInfo->handle)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSemaphorePool=" + ptrToString((void**)std::addressof(pSemaphorePool)) + '!');
}
#ifdef CREATESEMAPHORESCISYNCPOOLNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSemaphoreSciSyncPoolNV_after(device, pCreateInfo, pAllocator, pSemaphorePool);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSemaphoreSciSyncPoolNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSemaphoreSciSyncPoolNV(device, pCreateInfo, pAllocator, pSemaphorePool);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_SCI)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySemaphoreSciSyncPoolNV(VkDevice device, VkSemaphoreSciSyncPoolNV semaphorePool, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySemaphoreSciSyncPoolNV!");
}
#ifdef DESTROYSEMAPHORESCISYNCPOOLNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySemaphoreSciSyncPoolNV_before(device, semaphorePool, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySemaphoreSciSyncPoolNV(device, semaphorePool, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"semaphorePool=" + ptrToString((void**)std::addressof(semaphorePool)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSEMAPHORESCISYNCPOOLNV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySemaphoreSciSyncPoolNV_after(device, semaphorePool, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySemaphoreSciSyncPoolNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySemaphoreSciSyncPoolNV(device, semaphorePool, pAllocator);
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, VkDisplayPowerInfoEXT* pDisplayPowerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDisplayPowerControlEXT!");
}
#ifdef DISPLAYPOWERCONTROLEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DisplayPowerControlEXT_before(device, display, pDisplayPowerInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].DisplayPowerControlEXT(device, display, pDisplayPowerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
if(pDisplayPowerInfo != VK_NULL_HANDLE && pDisplayPowerInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pDisplayPowerInfo=VK_NULL_HANDLE!");
}
#ifdef DISPLAYPOWERCONTROLEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DisplayPowerControlEXT_after(device, display, pDisplayPowerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDisplayPowerControlEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].DisplayPowerControlEXT(device, display, pDisplayPowerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_RegisterDeviceEventEXT(VkDevice device, VkDeviceEventInfoEXT* pDeviceEventInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkRegisterDeviceEventEXT!");
}
#ifdef REGISTERDEVICEEVENTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_RegisterDeviceEventEXT_before(device, pDeviceEventInfo, pAllocator, pFence);
}
#endif 
auto ret = device_dispatch[GetKey(device)].RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pDeviceEventInfo != VK_NULL_HANDLE && pDeviceEventInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pDeviceEventInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFence=" + ptrToString((void**)std::addressof(pFence)) + '!');
}
#ifdef REGISTERDEVICEEVENTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_RegisterDeviceEventEXT_after(device, pDeviceEventInfo, pAllocator, pFence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkRegisterDeviceEventEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].RegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, VkDisplayEventInfoEXT* pDisplayEventInfo, VkAllocationCallbacks* pAllocator, VkFence* pFence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkRegisterDisplayEventEXT!");
}
#ifdef REGISTERDISPLAYEVENTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_RegisterDisplayEventEXT_before(device, display, pDisplayEventInfo, pAllocator, pFence);
}
#endif 
auto ret = device_dispatch[GetKey(device)].RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"display=" + ptrToString((void**)std::addressof(display)) + '!');
if(pDisplayEventInfo != VK_NULL_HANDLE && pDisplayEventInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pDisplayEventInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFence=" + ptrToString((void**)std::addressof(pFence)) + '!');
}
#ifdef REGISTERDISPLAYEVENTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_RegisterDisplayEventEXT_after(device, display, pDisplayEventInfo, pAllocator, pFence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkRegisterDisplayEventEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].RegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSwapchainCounterEXT!");
}
#ifdef GETSWAPCHAINCOUNTEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSwapchainCounterEXT_before(device, swapchain, counter, pCounterValue);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pCounterValue=" + ptrToString((void**)std::addressof(pCounterValue)) + '!');
}
#ifdef GETSWAPCHAINCOUNTEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSwapchainCounterEXT_after(device, swapchain, counter, pCounterValue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSwapchainCounterEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceGroupPeerMemoryFeatures!");
}
#ifdef GETDEVICEGROUPPEERMEMORYFEATURES_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPeerMemoryFeatures_before(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"heapIndex=" + std::to_string(heapIndex) + '!');
winsockSendToUI(&ConnectSocket,"localDeviceIndex=" + std::to_string(localDeviceIndex) + '!');
winsockSendToUI(&ConnectSocket,"remoteDeviceIndex=" + std::to_string(remoteDeviceIndex) + '!');
winsockSendToUI(&ConnectSocket,"pPeerMemoryFeatures=" + ptrToString((void**)std::addressof(pPeerMemoryFeatures)) + '!');
}
#ifdef GETDEVICEGROUPPEERMEMORYFEATURES_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPeerMemoryFeatures_after(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceGroupPeerMemoryFeatures!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, VkBindBufferMemoryInfo* pBindInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindBufferMemory2!");
}
#ifdef BINDBUFFERMEMORY2_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory2_before(device, bindInfoCount, pBindInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindBufferMemory2(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfos != VK_NULL_HANDLE && pBindInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfos->buffer=" + ptrToString((void**)std::addressof(pBindInfos->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memory=" + ptrToString((void**)std::addressof(pBindInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memoryOffset=" + std::to_string(pBindInfos->memoryOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfos=VK_NULL_HANDLE!");
}
#ifdef BINDBUFFERMEMORY2_AFTER_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory2_after(device, bindInfoCount, pBindInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindBufferMemory2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindBufferMemory2(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindImageMemory2(VkDevice device, uint32_t bindInfoCount, VkBindImageMemoryInfo* pBindInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindImageMemory2!");
}
#ifdef BINDIMAGEMEMORY2_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindImageMemory2_before(device, bindInfoCount, pBindInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindImageMemory2(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfos != VK_NULL_HANDLE && pBindInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfos->image=" + ptrToString((void**)std::addressof(pBindInfos->image)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memory=" + ptrToString((void**)std::addressof(pBindInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memoryOffset=" + std::to_string(pBindInfos->memoryOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfos=VK_NULL_HANDLE!");
}
#ifdef BINDIMAGEMEMORY2_AFTER_EXEC_EXISTS
if(connected) {
layer_BindImageMemory2_after(device, bindInfoCount, pBindInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindImageMemory2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindImageMemory2(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDeviceMask!");
}
#ifdef CMDSETDEVICEMASK_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDeviceMask_before(commandBuffer, deviceMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDeviceMask(commandBuffer, deviceMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"deviceMask=" + std::to_string(deviceMask) + '!');
}
#ifdef CMDSETDEVICEMASK_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDeviceMask_after(commandBuffer, deviceMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDeviceMask!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDeviceMask(commandBuffer, deviceMask);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceGroupPresentCapabilitiesKHR!");
}
#ifdef GETDEVICEGROUPPRESENTCAPABILITIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPresentCapabilitiesKHR_before(device, pDeviceGroupPresentCapabilities);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pDeviceGroupPresentCapabilities != VK_NULL_HANDLE && pDeviceGroupPresentCapabilities != NULL) {
winsockSendToUI(&ConnectSocket,"pDeviceGroupPresentCapabilities->modes=" + ptrToString((void**)std::addressof(pDeviceGroupPresentCapabilities->modes)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDeviceGroupPresentCapabilities=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEGROUPPRESENTCAPABILITIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPresentCapabilitiesKHR_after(device, pDeviceGroupPresentCapabilities);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceGroupPresentCapabilitiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceGroupSurfacePresentModesKHR!");
}
#ifdef GETDEVICEGROUPSURFACEPRESENTMODESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupSurfacePresentModesKHR_before(device, surface, pModes);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"surface=" + ptrToString((void**)std::addressof(surface)) + '!');
winsockSendToUI(&ConnectSocket,"pModes=" + ptrToString((void**)std::addressof(pModes)) + '!');
}
#ifdef GETDEVICEGROUPSURFACEPRESENTMODESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupSurfacePresentModesKHR_after(device, surface, pModes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceGroupSurfacePresentModesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireNextImage2KHR(VkDevice device, VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireNextImage2KHR!");
}
#ifdef ACQUIRENEXTIMAGE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireNextImage2KHR_before(device, pAcquireInfo, pImageIndex);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAcquireInfo != VK_NULL_HANDLE && pAcquireInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pAcquireInfo->swapchain=" + ptrToString((void**)std::addressof(pAcquireInfo->swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pAcquireInfo->timeout=" + std::to_string(pAcquireInfo->timeout) + '!');
winsockSendToUI(&ConnectSocket,"pAcquireInfo->semaphore=" + ptrToString((void**)std::addressof(pAcquireInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pAcquireInfo->fence=" + ptrToString((void**)std::addressof(pAcquireInfo->fence)) + '!');
winsockSendToUI(&ConnectSocket,"pAcquireInfo->deviceMask=" + std::to_string(pAcquireInfo->deviceMask) + '!');
}else winsockSendToUI(&ConnectSocket, "pAcquireInfo=VK_NULL_HANDLE!");
}
#ifdef ACQUIRENEXTIMAGE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireNextImage2KHR_after(device, pAcquireInfo, pImageIndex);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireNextImage2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchBase!");
}
#ifdef CMDDISPATCHBASE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchBase_before(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupX=" + std::to_string(baseGroupX) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupY=" + std::to_string(baseGroupY) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupZ=" + std::to_string(baseGroupZ) + '!');
winsockSendToUI(&ConnectSocket,"groupCountX=" + std::to_string(groupCountX) + '!');
winsockSendToUI(&ConnectSocket,"groupCountY=" + std::to_string(groupCountY) + '!');
winsockSendToUI(&ConnectSocket,"groupCountZ=" + std::to_string(groupCountZ) + '!');
}
#ifdef CMDDISPATCHBASE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchBase_after(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchBase!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDescriptorUpdateTemplate!");
}
#ifdef CREATEDESCRIPTORUPDATETEMPLATE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorUpdateTemplate_before(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->descriptorUpdateEntryCount=" + std::to_string(pCreateInfo->descriptorUpdateEntryCount) + '!');
if(pCreateInfo->pDescriptorUpdateEntries != VK_NULL_HANDLE && pCreateInfo->pDescriptorUpdateEntries != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->dstBinding=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->dstArrayElement=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->descriptorCount=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->descriptorCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->offset=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->stride=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->stride) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorUpdateEntries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->descriptorSetLayout=" + ptrToString((void**)std::addressof(pCreateInfo->descriptorSetLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pipelineLayout=" + ptrToString((void**)std::addressof(pCreateInfo->pipelineLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->set=" + std::to_string(pCreateInfo->set) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorUpdateTemplate=" + ptrToString((void**)std::addressof(pDescriptorUpdateTemplate)) + '!');
}
#ifdef CREATEDESCRIPTORUPDATETEMPLATE_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorUpdateTemplate_after(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDescriptorUpdateTemplate!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDescriptorUpdateTemplate!");
}
#ifdef DESTROYDESCRIPTORUPDATETEMPLATE_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorUpdateTemplate_before(device, descriptorUpdateTemplate, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(descriptorUpdateTemplate)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDESCRIPTORUPDATETEMPLATE_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorUpdateTemplate_after(device, descriptorUpdateTemplate, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDescriptorUpdateTemplate!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUpdateDescriptorSetWithTemplate!");
}
#ifdef UPDATEDESCRIPTORSETWITHTEMPLATE_BEFORE_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSetWithTemplate_before(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif 
device_dispatch[GetKey(device)].UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSet=" + ptrToString((void**)std::addressof(descriptorSet)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(descriptorUpdateTemplate)) + '!');
}
#ifdef UPDATEDESCRIPTORSETWITHTEMPLATE_AFTER_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSetWithTemplate_after(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUpdateDescriptorSetWithTemplate!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].UpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushDescriptorSetWithTemplateKHR!");
}
#ifdef CMDPUSHDESCRIPTORSETWITHTEMPLATEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetWithTemplateKHR_before(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(descriptorUpdateTemplate)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"set=" + std::to_string(set) + '!');
}
#ifdef CMDPUSHDESCRIPTORSETWITHTEMPLATEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetWithTemplateKHR_after(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushDescriptorSetWithTemplateKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, VkSwapchainKHR* pSwapchains, VkHdrMetadataEXT* pMetadata) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetHdrMetadataEXT!");
}
#ifdef SETHDRMETADATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetHdrMetadataEXT_before(device, swapchainCount, pSwapchains, pMetadata);
}
#endif 
device_dispatch[GetKey(device)].SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchainCount=" + std::to_string(swapchainCount) + '!');
winsockSendToUI(&ConnectSocket,"pSwapchains=" + ptrToString((void**)std::addressof(pSwapchains)) + '!');
if(pMetadata != VK_NULL_HANDLE && pMetadata != NULL) {
winsockSendToUI(&ConnectSocket,"pMetadata->displayPrimaryRed=" + ptrToString((void**)std::addressof(pMetadata->displayPrimaryRed)) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->displayPrimaryGreen=" + ptrToString((void**)std::addressof(pMetadata->displayPrimaryGreen)) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->displayPrimaryBlue=" + ptrToString((void**)std::addressof(pMetadata->displayPrimaryBlue)) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->whitePoint=" + ptrToString((void**)std::addressof(pMetadata->whitePoint)) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->maxLuminance=" + std::to_string(pMetadata->maxLuminance) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->minLuminance=" + std::to_string(pMetadata->minLuminance) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->maxContentLightLevel=" + std::to_string(pMetadata->maxContentLightLevel) + '!');
winsockSendToUI(&ConnectSocket,"pMetadata->maxFrameAverageLightLevel=" + std::to_string(pMetadata->maxFrameAverageLightLevel) + '!');
}else winsockSendToUI(&ConnectSocket, "pMetadata=VK_NULL_HANDLE!");
}
#ifdef SETHDRMETADATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetHdrMetadataEXT_after(device, swapchainCount, pSwapchains, pMetadata);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetHdrMetadataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].SetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSwapchainStatusKHR!");
}
#ifdef GETSWAPCHAINSTATUSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSwapchainStatusKHR_before(device, swapchain);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSwapchainStatusKHR(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
}
#ifdef GETSWAPCHAINSTATUSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSwapchainStatusKHR_after(device, swapchain);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSwapchainStatusKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSwapchainStatusKHR(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRefreshCycleDurationGOOGLE!");
}
#ifdef GETREFRESHCYCLEDURATIONGOOGLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRefreshCycleDurationGOOGLE_before(device, swapchain, pDisplayTimingProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pDisplayTimingProperties != VK_NULL_HANDLE && pDisplayTimingProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pDisplayTimingProperties->refreshDuration=" + std::to_string(pDisplayTimingProperties->refreshDuration) + '!');
}else winsockSendToUI(&ConnectSocket, "pDisplayTimingProperties=VK_NULL_HANDLE!");
}
#ifdef GETREFRESHCYCLEDURATIONGOOGLE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRefreshCycleDurationGOOGLE_after(device, swapchain, pDisplayTimingProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRefreshCycleDurationGOOGLE!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPastPresentationTimingGOOGLE!");
}
#ifdef GETPASTPRESENTATIONTIMINGGOOGLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPastPresentationTimingGOOGLE_before(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pPresentationTimings != VK_NULL_HANDLE && pPresentationTimings != NULL) {
winsockSendToUI(&ConnectSocket,"pPresentationTimings->presentID=" + std::to_string(pPresentationTimings->presentID) + '!');
winsockSendToUI(&ConnectSocket,"pPresentationTimings->desiredPresentTime=" + std::to_string(pPresentationTimings->desiredPresentTime) + '!');
winsockSendToUI(&ConnectSocket,"pPresentationTimings->actualPresentTime=" + std::to_string(pPresentationTimings->actualPresentTime) + '!');
winsockSendToUI(&ConnectSocket,"pPresentationTimings->earliestPresentTime=" + std::to_string(pPresentationTimings->earliestPresentTime) + '!');
winsockSendToUI(&ConnectSocket,"pPresentationTimings->presentMargin=" + std::to_string(pPresentationTimings->presentMargin) + '!');
}else winsockSendToUI(&ConnectSocket, "pPresentationTimings=VK_NULL_HANDLE!");
}
#ifdef GETPASTPRESENTATIONTIMINGGOOGLE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPastPresentationTimingGOOGLE_after(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPastPresentationTimingGOOGLE!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewportWScalingNV* pViewportWScalings) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportWScalingNV!");
}
#ifdef CMDSETVIEWPORTWSCALINGNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWScalingNV_before(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstViewport=" + std::to_string(firstViewport) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pViewportWScalings != VK_NULL_HANDLE && pViewportWScalings != NULL) {
winsockSendToUI(&ConnectSocket,"pViewportWScalings->xcoeff=" + std::to_string(pViewportWScalings->xcoeff) + '!');
winsockSendToUI(&ConnectSocket,"pViewportWScalings->ycoeff=" + std::to_string(pViewportWScalings->ycoeff) + '!');
}else winsockSendToUI(&ConnectSocket, "pViewportWScalings=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORTWSCALINGNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWScalingNV_after(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportWScalingNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, VkRect2D* pDiscardRectangles) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDiscardRectangleEXT!");
}
#ifdef CMDSETDISCARDRECTANGLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleEXT_before(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstDiscardRectangle=" + std::to_string(firstDiscardRectangle) + '!');
winsockSendToUI(&ConnectSocket,"discardRectangleCount=" + std::to_string(discardRectangleCount) + '!');
if(pDiscardRectangles != VK_NULL_HANDLE && pDiscardRectangles != NULL) {
winsockSendToUI(&ConnectSocket,"pDiscardRectangles->offset=" + ptrToString((void**)std::addressof(pDiscardRectangles->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pDiscardRectangles->extent=" + ptrToString((void**)std::addressof(pDiscardRectangles->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDiscardRectangles=VK_NULL_HANDLE!");
}
#ifdef CMDSETDISCARDRECTANGLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleEXT_after(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDiscardRectangleEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDiscardRectangleEnableEXT!");
}
#ifdef CMDSETDISCARDRECTANGLEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleEnableEXT_before(commandBuffer, discardRectangleEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"discardRectangleEnable=" + bool_as_text(discardRectangleEnable) + '!');
}
#ifdef CMDSETDISCARDRECTANGLEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleEnableEXT_after(commandBuffer, discardRectangleEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDiscardRectangleEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDiscardRectangleModeEXT!");
}
#ifdef CMDSETDISCARDRECTANGLEMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleModeEXT_before(commandBuffer, discardRectangleMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETDISCARDRECTANGLEMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDiscardRectangleModeEXT_after(commandBuffer, discardRectangleMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDiscardRectangleModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetSampleLocationsEXT!");
}
#ifdef CMDSETSAMPLELOCATIONSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleLocationsEXT_before(commandBuffer, pSampleLocationsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSampleLocationsInfo != VK_NULL_HANDLE && pSampleLocationsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSampleLocationsInfo->sampleLocationGridSize=" + ptrToString((void**)std::addressof(pSampleLocationsInfo->sampleLocationGridSize)) + '!');
winsockSendToUI(&ConnectSocket,"pSampleLocationsInfo->sampleLocationsCount=" + std::to_string(pSampleLocationsInfo->sampleLocationsCount) + '!');
if(pSampleLocationsInfo->pSampleLocations != VK_NULL_HANDLE && pSampleLocationsInfo->pSampleLocations != NULL) {
winsockSendToUI(&ConnectSocket,"pSampleLocationsInfo->pSampleLocations->x=" + std::to_string(pSampleLocationsInfo->pSampleLocations->x) + '!');
winsockSendToUI(&ConnectSocket,"pSampleLocationsInfo->pSampleLocations->y=" + std::to_string(pSampleLocationsInfo->pSampleLocations->y) + '!');
}else winsockSendToUI(&ConnectSocket, "pSampleLocations=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pSampleLocationsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETSAMPLELOCATIONSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleLocationsEXT_after(commandBuffer, pSampleLocationsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetSampleLocationsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetBufferMemoryRequirements2(VkDevice device, VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferMemoryRequirements2!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements2_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements2_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferMemoryRequirements2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageMemoryRequirements2(VkDevice device, VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageMemoryRequirements2!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements2_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->image=" + ptrToString((void**)std::addressof(pInfo->image)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements2_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageMemoryRequirements2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSparseMemoryRequirements2(VkDevice device, VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSparseMemoryRequirements2!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements2_before(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->image=" + ptrToString((void**)std::addressof(pInfo->image)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pSparseMemoryRequirements != VK_NULL_HANDLE && pSparseMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pSparseMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSparseMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements2_after(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSparseMemoryRequirements2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceBufferMemoryRequirements(VkDevice device, VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceBufferMemoryRequirements!");
}
#ifdef GETDEVICEBUFFERMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceBufferMemoryRequirements_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->size=" + std::to_string(pInfo->pCreateInfo->size) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEBUFFERMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceBufferMemoryRequirements_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceBufferMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceImageMemoryRequirements(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceImageMemoryRequirements!");
}
#ifdef GETDEVICEIMAGEMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageMemoryRequirements_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->extent=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->mipLevels=" + std::to_string(pInfo->pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->arrayLayers=" + std::to_string(pInfo->pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEIMAGEMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageMemoryRequirements_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceImageMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceImageSparseMemoryRequirements(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceImageSparseMemoryRequirements!");
}
#ifdef GETDEVICEIMAGESPARSEMEMORYREQUIREMENTS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSparseMemoryRequirements_before(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->extent=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->mipLevels=" + std::to_string(pInfo->pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->arrayLayers=" + std::to_string(pInfo->pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pSparseMemoryRequirements != VK_NULL_HANDLE && pSparseMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pSparseMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSparseMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEIMAGESPARSEMEMORYREQUIREMENTS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSparseMemoryRequirements_after(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceImageSparseMemoryRequirements!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversionCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSamplerYcbcrConversion!");
}
#ifdef CREATESAMPLERYCBCRCONVERSION_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSamplerYcbcrConversion_before(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->components=" + ptrToString((void**)std::addressof(pCreateInfo->components)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->forceExplicitReconstruction=" + bool_as_text(pCreateInfo->forceExplicitReconstruction) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pYcbcrConversion=" + ptrToString((void**)std::addressof(pYcbcrConversion)) + '!');
}
#ifdef CREATESAMPLERYCBCRCONVERSION_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSamplerYcbcrConversion_after(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSamplerYcbcrConversion!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySamplerYcbcrConversion!");
}
#ifdef DESTROYSAMPLERYCBCRCONVERSION_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySamplerYcbcrConversion_before(device, ycbcrConversion, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"ycbcrConversion=" + ptrToString((void**)std::addressof(ycbcrConversion)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSAMPLERYCBCRCONVERSION_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySamplerYcbcrConversion_after(device, ycbcrConversion, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySamplerYcbcrConversion!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceQueue2(VkDevice device, VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceQueue2!");
}
#ifdef GETDEVICEQUEUE2_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceQueue2_before(device, pQueueInfo, pQueue);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceQueue2(device, pQueueInfo, pQueue);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pQueueInfo != VK_NULL_HANDLE && pQueueInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pQueueInfo->flags=" + ptrToString((void**)std::addressof(pQueueInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pQueueInfo->queueFamilyIndex=" + std::to_string(pQueueInfo->queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pQueueInfo->queueIndex=" + std::to_string(pQueueInfo->queueIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pQueueInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pQueue=" + ptrToString((void**)std::addressof(pQueue)) + '!');
}
#ifdef GETDEVICEQUEUE2_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceQueue2_after(device, pQueueInfo, pQueue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceQueue2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceQueue2(device, pQueueInfo, pQueue);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateValidationCacheEXT(VkDevice device, VkValidationCacheCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateValidationCacheEXT!");
}
#ifdef CREATEVALIDATIONCACHEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateValidationCacheEXT_before(device, pCreateInfo, pAllocator, pValidationCache);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->initialDataSize=" + std::to_string(pCreateInfo->initialDataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pValidationCache=" + ptrToString((void**)std::addressof(pValidationCache)) + '!');
}
#ifdef CREATEVALIDATIONCACHEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateValidationCacheEXT_after(device, pCreateInfo, pAllocator, pValidationCache);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateValidationCacheEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyValidationCacheEXT!");
}
#ifdef DESTROYVALIDATIONCACHEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyValidationCacheEXT_before(device, validationCache, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyValidationCacheEXT(device, validationCache, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"validationCache=" + ptrToString((void**)std::addressof(validationCache)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYVALIDATIONCACHEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyValidationCacheEXT_after(device, validationCache, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyValidationCacheEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyValidationCacheEXT(device, validationCache, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetValidationCacheDataEXT!");
}
#ifdef GETVALIDATIONCACHEDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetValidationCacheDataEXT_before(device, validationCache, pDataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"validationCache=" + ptrToString((void**)std::addressof(validationCache)) + '!');
winsockSendToUI(&ConnectSocket,"pDataSize=" + ptrToString((void**)std::addressof(pDataSize)) + '!');
}
#ifdef GETVALIDATIONCACHEDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetValidationCacheDataEXT_after(device, validationCache, pDataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetValidationCacheDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, VkValidationCacheEXT* pSrcCaches) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkMergeValidationCachesEXT!");
}
#ifdef MERGEVALIDATIONCACHESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_MergeValidationCachesEXT_before(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif 
auto ret = device_dispatch[GetKey(device)].MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"dstCache=" + ptrToString((void**)std::addressof(dstCache)) + '!');
winsockSendToUI(&ConnectSocket,"srcCacheCount=" + std::to_string(srcCacheCount) + '!');
winsockSendToUI(&ConnectSocket,"pSrcCaches=" + ptrToString((void**)std::addressof(pSrcCaches)) + '!');
}
#ifdef MERGEVALIDATIONCACHESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_MergeValidationCachesEXT_after(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkMergeValidationCachesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].MergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetLayoutSupport(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetLayoutSupport!");
}
#ifdef GETDESCRIPTORSETLAYOUTSUPPORT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSupport_before(device, pCreateInfo, pSupport);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->bindingCount=" + std::to_string(pCreateInfo->bindingCount) + '!');
if(pCreateInfo->pBindings != VK_NULL_HANDLE && pCreateInfo->pBindings != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->binding=" + std::to_string(pCreateInfo->pBindings->binding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->descriptorCount=" + std::to_string(pCreateInfo->pBindings->descriptorCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->stageFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->pImmutableSamplers=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->pImmutableSamplers)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindings=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pSupport != VK_NULL_HANDLE && pSupport != NULL) {
winsockSendToUI(&ConnectSocket,"pSupport->supported=" + bool_as_text(pSupport->supported) + '!');
}else winsockSendToUI(&ConnectSocket, "pSupport=VK_NULL_HANDLE!");
}
#ifdef GETDESCRIPTORSETLAYOUTSUPPORT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSupport_after(device, pCreateInfo, pSupport);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetLayoutSupport!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
}
}

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSwapchainGrallocUsageANDROID(VkDevice device, VkFormat format, VkImageUsageFlags imageUsage, int* grallocUsage) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSwapchainGrallocUsageANDROID!");
}
#ifdef GETSWAPCHAINGRALLOCUSAGEANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSwapchainGrallocUsageANDROID_before(device, format, imageUsage, grallocUsage);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"imageUsage=" + ptrToString((void**)std::addressof(imageUsage)) + '!');
winsockSendToUI(&ConnectSocket,"grallocUsage=" + ptrToString((void**)std::addressof(grallocUsage)) + '!');
}
#ifdef GETSWAPCHAINGRALLOCUSAGEANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSwapchainGrallocUsageANDROID_after(device, format, imageUsage, grallocUsage);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSwapchainGrallocUsageANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSwapchainGrallocUsage2ANDROID(VkDevice device, VkFormat format, VkImageUsageFlags imageUsage, VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage, uint64_t* grallocProducerUsage) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSwapchainGrallocUsage2ANDROID!");
}
#ifdef GETSWAPCHAINGRALLOCUSAGE2ANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSwapchainGrallocUsage2ANDROID_before(device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSwapchainGrallocUsage2ANDROID(device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"imageUsage=" + ptrToString((void**)std::addressof(imageUsage)) + '!');
winsockSendToUI(&ConnectSocket,"swapchainImageUsage=" + ptrToString((void**)std::addressof(swapchainImageUsage)) + '!');
winsockSendToUI(&ConnectSocket,"grallocConsumerUsage=" + ptrToString((void**)std::addressof(grallocConsumerUsage)) + '!');
winsockSendToUI(&ConnectSocket,"grallocProducerUsage=" + ptrToString((void**)std::addressof(grallocProducerUsage)) + '!');
}
#ifdef GETSWAPCHAINGRALLOCUSAGE2ANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSwapchainGrallocUsage2ANDROID_after(device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSwapchainGrallocUsage2ANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSwapchainGrallocUsage2ANDROID(device, format, imageUsage, swapchainImageUsage, grallocConsumerUsage, grallocProducerUsage);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireImageANDROID(VkDevice device, VkImage image, int nativeFenceFd, VkSemaphore semaphore, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireImageANDROID!");
}
#ifdef ACQUIREIMAGEANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireImageANDROID_before(device, image, nativeFenceFd, semaphore, fence);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
winsockSendToUI(&ConnectSocket,"nativeFenceFd=" + std::to_string(nativeFenceFd) + '!');
winsockSendToUI(&ConnectSocket,"semaphore=" + ptrToString((void**)std::addressof(semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef ACQUIREIMAGEANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireImageANDROID_after(device, image, nativeFenceFd, semaphore, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireImageANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueSignalReleaseImageANDROID(VkQueue queue, uint32_t waitSemaphoreCount, VkSemaphore* pWaitSemaphores, VkImage image, int* pNativeFenceFd) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueSignalReleaseImageANDROID!");
}
#ifdef QUEUESIGNALRELEASEIMAGEANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueSignalReleaseImageANDROID_before(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"waitSemaphoreCount=" + std::to_string(waitSemaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pWaitSemaphores=" + ptrToString((void**)std::addressof(pWaitSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
winsockSendToUI(&ConnectSocket,"pNativeFenceFd=" + ptrToString((void**)std::addressof(pNativeFenceFd)) + '!');
}
#ifdef QUEUESIGNALRELEASEIMAGEANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueSignalReleaseImageANDROID_after(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueSignalReleaseImageANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetShaderInfoAMD!");
}
#ifdef GETSHADERINFOAMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetShaderInfoAMD_before(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pInfoSize=" + ptrToString((void**)std::addressof(pInfoSize)) + '!');
}
#ifdef GETSHADERINFOAMD_AFTER_EXEC_EXISTS
if(connected) {
layer_GetShaderInfoAMD_after(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetShaderInfoAMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetLocalDimmingAMD!");
}
#ifdef SETLOCALDIMMINGAMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetLocalDimmingAMD_before(device, swapChain, localDimmingEnable);
}
#endif 
device_dispatch[GetKey(device)].SetLocalDimmingAMD(device, swapChain, localDimmingEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapChain=" + ptrToString((void**)std::addressof(swapChain)) + '!');
winsockSendToUI(&ConnectSocket,"localDimmingEnable=" + bool_as_text(localDimmingEnable) + '!');
}
#ifdef SETLOCALDIMMINGAMD_AFTER_EXEC_EXISTS
if(connected) {
layer_SetLocalDimmingAMD_after(device, swapChain, localDimmingEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetLocalDimmingAMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].SetLocalDimmingAMD(device, swapChain, localDimmingEnable);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetCalibratedTimestampsKHR!");
}
#ifdef GETCALIBRATEDTIMESTAMPSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetCalibratedTimestampsKHR_before(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"timestampCount=" + std::to_string(timestampCount) + '!');
if(pTimestampInfos != VK_NULL_HANDLE && pTimestampInfos != NULL) {
}else winsockSendToUI(&ConnectSocket, "pTimestampInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pTimestamps=" + ptrToString((void**)std::addressof(pTimestamps)) + '!');
winsockSendToUI(&ConnectSocket,"pMaxDeviation=" + ptrToString((void**)std::addressof(pMaxDeviation)) + '!');
}
#ifdef GETCALIBRATEDTIMESTAMPSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetCalibratedTimestampsKHR_after(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetCalibratedTimestampsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetDebugUtilsObjectNameEXT(VkDevice device, VkDebugUtilsObjectNameInfoEXT* pNameInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetDebugUtilsObjectNameEXT!");
}
#ifdef SETDEBUGUTILSOBJECTNAMEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetDebugUtilsObjectNameEXT_before(device, pNameInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetDebugUtilsObjectNameEXT(device, pNameInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pNameInfo != VK_NULL_HANDLE && pNameInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pNameInfo->objectHandle=" + std::to_string(pNameInfo->objectHandle) + '!');
}else winsockSendToUI(&ConnectSocket, "pNameInfo=VK_NULL_HANDLE!");
}
#ifdef SETDEBUGUTILSOBJECTNAMEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetDebugUtilsObjectNameEXT_after(device, pNameInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetDebugUtilsObjectNameEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetDebugUtilsObjectNameEXT(device, pNameInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetDebugUtilsObjectTagEXT(VkDevice device, VkDebugUtilsObjectTagInfoEXT* pTagInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetDebugUtilsObjectTagEXT!");
}
#ifdef SETDEBUGUTILSOBJECTTAGEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetDebugUtilsObjectTagEXT_before(device, pTagInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetDebugUtilsObjectTagEXT(device, pTagInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pTagInfo != VK_NULL_HANDLE && pTagInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pTagInfo->objectHandle=" + std::to_string(pTagInfo->objectHandle) + '!');
winsockSendToUI(&ConnectSocket,"pTagInfo->tagName=" + std::to_string(pTagInfo->tagName) + '!');
winsockSendToUI(&ConnectSocket,"pTagInfo->tagSize=" + std::to_string(pTagInfo->tagSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pTagInfo=VK_NULL_HANDLE!");
}
#ifdef SETDEBUGUTILSOBJECTTAGEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetDebugUtilsObjectTagEXT_after(device, pTagInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetDebugUtilsObjectTagEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetDebugUtilsObjectTagEXT(device, pTagInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_QueueBeginDebugUtilsLabelEXT(VkQueue queue, VkDebugUtilsLabelEXT* pLabelInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueBeginDebugUtilsLabelEXT!");
}
#ifdef QUEUEBEGINDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueBeginDebugUtilsLabelEXT_before(queue, pLabelInfo);
}
#endif 
device_dispatch[GetKey(queue)].QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pLabelInfo != VK_NULL_HANDLE && pLabelInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pLabelInfo=VK_NULL_HANDLE!");
}
#ifdef QUEUEBEGINDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueBeginDebugUtilsLabelEXT_after(queue, pLabelInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueBeginDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].QueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_QueueEndDebugUtilsLabelEXT(VkQueue queue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueEndDebugUtilsLabelEXT!");
}
#ifdef QUEUEENDDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueEndDebugUtilsLabelEXT_before(queue);
}
#endif 
device_dispatch[GetKey(queue)].QueueEndDebugUtilsLabelEXT(queue);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
}
#ifdef QUEUEENDDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueEndDebugUtilsLabelEXT_after(queue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueEndDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].QueueEndDebugUtilsLabelEXT(queue);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_QueueInsertDebugUtilsLabelEXT(VkQueue queue, VkDebugUtilsLabelEXT* pLabelInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueInsertDebugUtilsLabelEXT!");
}
#ifdef QUEUEINSERTDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueInsertDebugUtilsLabelEXT_before(queue, pLabelInfo);
}
#endif 
device_dispatch[GetKey(queue)].QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pLabelInfo != VK_NULL_HANDLE && pLabelInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pLabelInfo=VK_NULL_HANDLE!");
}
#ifdef QUEUEINSERTDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueInsertDebugUtilsLabelEXT_after(queue, pLabelInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueInsertDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].QueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT* pLabelInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginDebugUtilsLabelEXT!");
}
#ifdef CMDBEGINDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginDebugUtilsLabelEXT_before(commandBuffer, pLabelInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pLabelInfo != VK_NULL_HANDLE && pLabelInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pLabelInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginDebugUtilsLabelEXT_after(commandBuffer, pLabelInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndDebugUtilsLabelEXT!");
}
#ifdef CMDENDDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndDebugUtilsLabelEXT_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndDebugUtilsLabelEXT(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDENDDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndDebugUtilsLabelEXT_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndDebugUtilsLabelEXT(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT* pLabelInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdInsertDebugUtilsLabelEXT!");
}
#ifdef CMDINSERTDEBUGUTILSLABELEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdInsertDebugUtilsLabelEXT_before(commandBuffer, pLabelInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pLabelInfo != VK_NULL_HANDLE && pLabelInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pLabelInfo=VK_NULL_HANDLE!");
}
#ifdef CMDINSERTDEBUGUTILSLABELEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdInsertDebugUtilsLabelEXT_after(commandBuffer, pLabelInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdInsertDebugUtilsLabelEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryHostPointerPropertiesEXT!");
}
#ifdef GETMEMORYHOSTPOINTERPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryHostPointerPropertiesEXT_before(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pMemoryHostPointerProperties != VK_NULL_HANDLE && pMemoryHostPointerProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryHostPointerProperties->memoryTypeBits=" + std::to_string(pMemoryHostPointerProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryHostPointerProperties=VK_NULL_HANDLE!");
}
#ifdef GETMEMORYHOSTPOINTERPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryHostPointerPropertiesEXT_after(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryHostPointerPropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteBufferMarkerAMD!");
}
#ifdef CMDWRITEBUFFERMARKERAMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteBufferMarkerAMD_before(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstOffset=" + std::to_string(dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"marker=" + std::to_string(marker) + '!');
}
#ifdef CMDWRITEBUFFERMARKERAMD_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteBufferMarkerAMD_after(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteBufferMarkerAMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateRenderPass2(VkDevice device, VkRenderPassCreateInfo2* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateRenderPass2!");
}
#ifdef CREATERENDERPASS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass2_before(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->attachmentCount=" + std::to_string(pCreateInfo->attachmentCount) + '!');
if(pCreateInfo->pAttachments != VK_NULL_HANDLE && pCreateInfo->pAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pAttachments->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pAttachments->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->subpassCount=" + std::to_string(pCreateInfo->subpassCount) + '!');
if(pCreateInfo->pSubpasses != VK_NULL_HANDLE && pCreateInfo->pSubpasses != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->viewMask=" + std::to_string(pCreateInfo->pSubpasses->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->inputAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->inputAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pInputAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pInputAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pInputAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pInputAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pInputAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pInputAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInputAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->colorAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->colorAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pColorAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pColorAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pColorAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pColorAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pColorAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pResolveAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pResolveAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pResolveAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pResolveAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pResolveAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pResolveAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pResolveAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pDepthStencilAttachment != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pDepthStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment=" + std::to_string(pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pDepthStencilAttachment->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pDepthStencilAttachment->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthStencilAttachment=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->preserveAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->preserveAttachmentCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubpasses=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->dependencyCount=" + std::to_string(pCreateInfo->dependencyCount) + '!');
if(pCreateInfo->pDependencies != VK_NULL_HANDLE && pCreateInfo->pDependencies != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcSubpass=" + std::to_string(pCreateInfo->pDependencies->srcSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstSubpass=" + std::to_string(pCreateInfo->pDependencies->dstSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dependencyFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->viewOffset=" + std::to_string(pCreateInfo->pDependencies->viewOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pDependencies=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->correlatedViewMaskCount=" + std::to_string(pCreateInfo->correlatedViewMaskCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pRenderPass=" + ptrToString((void**)std::addressof(pRenderPass)) + '!');
}
#ifdef CREATERENDERPASS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass2_after(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateRenderPass2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginRenderPass2(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassBeginInfo* pSubpassBeginInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginRenderPass2!");
}
#ifdef CMDBEGINRENDERPASS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass2_before(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRenderPassBegin != VK_NULL_HANDLE && pRenderPassBegin != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderPass=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->framebuffer=" + ptrToString((void**)std::addressof(pRenderPassBegin->framebuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderArea=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->clearValueCount=" + std::to_string(pRenderPassBegin->clearValueCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->pClearValues=" + ptrToString((void**)std::addressof(pRenderPassBegin->pClearValues)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRenderPassBegin=VK_NULL_HANDLE!");
if(pSubpassBeginInfo != VK_NULL_HANDLE && pSubpassBeginInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassBeginInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINRENDERPASS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass2_after(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginRenderPass2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdNextSubpass2(VkCommandBuffer commandBuffer, VkSubpassBeginInfo* pSubpassBeginInfo, VkSubpassEndInfo* pSubpassEndInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdNextSubpass2!");
}
#ifdef CMDNEXTSUBPASS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass2_before(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSubpassBeginInfo != VK_NULL_HANDLE && pSubpassBeginInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassBeginInfo=VK_NULL_HANDLE!");
if(pSubpassEndInfo != VK_NULL_HANDLE && pSubpassEndInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassEndInfo=VK_NULL_HANDLE!");
}
#ifdef CMDNEXTSUBPASS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass2_after(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdNextSubpass2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndRenderPass2(VkCommandBuffer commandBuffer, VkSubpassEndInfo* pSubpassEndInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndRenderPass2!");
}
#ifdef CMDENDRENDERPASS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass2_before(commandBuffer, pSubpassEndInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSubpassEndInfo != VK_NULL_HANDLE && pSubpassEndInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassEndInfo=VK_NULL_HANDLE!");
}
#ifdef CMDENDRENDERPASS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass2_after(commandBuffer, pSubpassEndInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndRenderPass2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t* pValue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreCounterValue!");
}
#ifdef GETSEMAPHORECOUNTERVALUE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreCounterValue_before(device, semaphore, pValue);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreCounterValue(device, semaphore, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"semaphore=" + ptrToString((void**)std::addressof(semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pValue=" + ptrToString((void**)std::addressof(pValue)) + '!');
}
#ifdef GETSEMAPHORECOUNTERVALUE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreCounterValue_after(device, semaphore, pValue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreCounterValue!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreCounterValue(device, semaphore, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WaitSemaphores(VkDevice device, VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWaitSemaphores!");
}
#ifdef WAITSEMAPHORES_BEFORE_EXEC_EXISTS
if(connected) {
layer_WaitSemaphores_before(device, pWaitInfo, timeout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WaitSemaphores(device, pWaitInfo, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pWaitInfo != VK_NULL_HANDLE && pWaitInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pWaitInfo->flags=" + ptrToString((void**)std::addressof(pWaitInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->semaphoreCount=" + std::to_string(pWaitInfo->semaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->pSemaphores=" + ptrToString((void**)std::addressof(pWaitInfo->pSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->pValues=" + ptrToString((void**)std::addressof(pWaitInfo->pValues)) + '!');
}else winsockSendToUI(&ConnectSocket, "pWaitInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"timeout=" + std::to_string(timeout) + '!');
}
#ifdef WAITSEMAPHORES_AFTER_EXEC_EXISTS
if(connected) {
layer_WaitSemaphores_after(device, pWaitInfo, timeout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWaitSemaphores!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WaitSemaphores(device, pWaitInfo, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SignalSemaphore(VkDevice device, VkSemaphoreSignalInfo* pSignalInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSignalSemaphore!");
}
#ifdef SIGNALSEMAPHORE_BEFORE_EXEC_EXISTS
if(connected) {
layer_SignalSemaphore_before(device, pSignalInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SignalSemaphore(device, pSignalInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pSignalInfo != VK_NULL_HANDLE && pSignalInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSignalInfo->semaphore=" + ptrToString((void**)std::addressof(pSignalInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSignalInfo->value=" + std::to_string(pSignalInfo->value) + '!');
}else winsockSendToUI(&ConnectSocket, "pSignalInfo=VK_NULL_HANDLE!");
}
#ifdef SIGNALSEMAPHORE_AFTER_EXEC_EXISTS
if(connected) {
layer_SignalSemaphore_after(device, pSignalInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSignalSemaphore!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SignalSemaphore(device, pSignalInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAndroidHardwareBufferPropertiesANDROID!");
}
#ifdef GETANDROIDHARDWAREBUFFERPROPERTIESANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAndroidHardwareBufferPropertiesANDROID_before(device, buffer, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->allocationSize=" + std::to_string(pProperties->allocationSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->memoryTypeBits=" + std::to_string(pProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETANDROIDHARDWAREBUFFERPROPERTIESANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAndroidHardwareBufferPropertiesANDROID_after(device, buffer, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAndroidHardwareBufferPropertiesANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetMemoryAndroidHardwareBufferANDROID(VkDevice device, VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, AHardwareBuffer* pBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMemoryAndroidHardwareBufferANDROID!");
}
#ifdef GETMEMORYANDROIDHARDWAREBUFFERANDROID_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMemoryAndroidHardwareBufferANDROID_before(device, pInfo, pBuffer);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->memory=" + ptrToString((void**)std::addressof(pInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBuffer=" + ptrToString((void**)std::addressof(pBuffer)) + '!');
}
#ifdef GETMEMORYANDROIDHARDWAREBUFFERANDROID_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMemoryAndroidHardwareBufferANDROID_after(device, pInfo, pBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMemoryAndroidHardwareBufferANDROID!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndirectCount!");
}
#ifdef CMDDRAWINDIRECTCOUNT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCount_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDIRECTCOUNT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCount_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndirectCount!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndexedIndirectCount!");
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCount_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCount_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndexedIndirectCount!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCheckpointNV(VkCommandBuffer commandBuffer, void* pCheckpointMarker) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCheckpointNV!");
}
#ifdef CMDSETCHECKPOINTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCheckpointNV_before(commandBuffer, pCheckpointMarker);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETCHECKPOINTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCheckpointNV_after(commandBuffer, pCheckpointMarker);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCheckpointNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetQueueCheckpointDataNV(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetQueueCheckpointDataNV!");
}
#ifdef GETQUEUECHECKPOINTDATANV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetQueueCheckpointDataNV_before(queue, pCheckpointDataCount, pCheckpointData);
}
#endif 
device_dispatch[GetKey(queue)].GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pCheckpointData != VK_NULL_HANDLE && pCheckpointData != NULL) {
}else winsockSendToUI(&ConnectSocket, "pCheckpointData=VK_NULL_HANDLE!");
}
#ifdef GETQUEUECHECKPOINTDATANV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetQueueCheckpointDataNV_after(queue, pCheckpointDataCount, pCheckpointData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetQueueCheckpointDataNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].GetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets, VkDeviceSize* pSizes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindTransformFeedbackBuffersEXT!");
}
#ifdef CMDBINDTRANSFORMFEEDBACKBUFFERSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindTransformFeedbackBuffersEXT_before(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstBinding=" + std::to_string(firstBinding) + '!');
winsockSendToUI(&ConnectSocket,"bindingCount=" + std::to_string(bindingCount) + '!');
winsockSendToUI(&ConnectSocket,"pBuffers=" + ptrToString((void**)std::addressof(pBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pOffsets=" + ptrToString((void**)std::addressof(pOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pSizes=" + ptrToString((void**)std::addressof(pSizes)) + '!');
}
#ifdef CMDBINDTRANSFORMFEEDBACKBUFFERSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindTransformFeedbackBuffersEXT_after(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindTransformFeedbackBuffersEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, VkBuffer* pCounterBuffers, VkDeviceSize* pCounterBufferOffsets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginTransformFeedbackEXT!");
}
#ifdef CMDBEGINTRANSFORMFEEDBACKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginTransformFeedbackEXT_before(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstCounterBuffer=" + std::to_string(firstCounterBuffer) + '!');
winsockSendToUI(&ConnectSocket,"counterBufferCount=" + std::to_string(counterBufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pCounterBuffers=" + ptrToString((void**)std::addressof(pCounterBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pCounterBufferOffsets=" + ptrToString((void**)std::addressof(pCounterBufferOffsets)) + '!');
}
#ifdef CMDBEGINTRANSFORMFEEDBACKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginTransformFeedbackEXT_after(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginTransformFeedbackEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, VkBuffer* pCounterBuffers, VkDeviceSize* pCounterBufferOffsets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndTransformFeedbackEXT!");
}
#ifdef CMDENDTRANSFORMFEEDBACKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndTransformFeedbackEXT_before(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstCounterBuffer=" + std::to_string(firstCounterBuffer) + '!');
winsockSendToUI(&ConnectSocket,"counterBufferCount=" + std::to_string(counterBufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pCounterBuffers=" + ptrToString((void**)std::addressof(pCounterBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pCounterBufferOffsets=" + ptrToString((void**)std::addressof(pCounterBufferOffsets)) + '!');
}
#ifdef CMDENDTRANSFORMFEEDBACKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndTransformFeedbackEXT_after(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndTransformFeedbackEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginQueryIndexedEXT!");
}
#ifdef CMDBEGINQUERYINDEXEDEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginQueryIndexedEXT_before(commandBuffer, queryPool, query, flags, index);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
winsockSendToUI(&ConnectSocket,"index=" + std::to_string(index) + '!');
}
#ifdef CMDBEGINQUERYINDEXEDEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginQueryIndexedEXT_after(commandBuffer, queryPool, query, flags, index);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginQueryIndexedEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndQueryIndexedEXT!");
}
#ifdef CMDENDQUERYINDEXEDEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndQueryIndexedEXT_before(commandBuffer, queryPool, query, index);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
winsockSendToUI(&ConnectSocket,"index=" + std::to_string(index) + '!');
}
#ifdef CMDENDQUERYINDEXEDEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndQueryIndexedEXT_after(commandBuffer, queryPool, query, index);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndQueryIndexedEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndirectByteCountEXT!");
}
#ifdef CMDDRAWINDIRECTBYTECOUNTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectByteCountEXT_before(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"instanceCount=" + std::to_string(instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"firstInstance=" + std::to_string(firstInstance) + '!');
winsockSendToUI(&ConnectSocket,"counterBuffer=" + ptrToString((void**)std::addressof(counterBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"counterBufferOffset=" + std::to_string(counterBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"counterOffset=" + std::to_string(counterOffset) + '!');
winsockSendToUI(&ConnectSocket,"vertexStride=" + std::to_string(vertexStride) + '!');
}
#ifdef CMDDRAWINDIRECTBYTECOUNTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectByteCountEXT_after(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndirectByteCountEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, VkRect2D* pExclusiveScissors) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetExclusiveScissorNV!");
}
#ifdef CMDSETEXCLUSIVESCISSORNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetExclusiveScissorNV_before(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstExclusiveScissor=" + std::to_string(firstExclusiveScissor) + '!');
winsockSendToUI(&ConnectSocket,"exclusiveScissorCount=" + std::to_string(exclusiveScissorCount) + '!');
if(pExclusiveScissors != VK_NULL_HANDLE && pExclusiveScissors != NULL) {
winsockSendToUI(&ConnectSocket,"pExclusiveScissors->offset=" + ptrToString((void**)std::addressof(pExclusiveScissors->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pExclusiveScissors->extent=" + ptrToString((void**)std::addressof(pExclusiveScissors->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pExclusiveScissors=VK_NULL_HANDLE!");
}
#ifdef CMDSETEXCLUSIVESCISSORNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetExclusiveScissorNV_after(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetExclusiveScissorNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, VkBool32* pExclusiveScissorEnables) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetExclusiveScissorEnableNV!");
}
#ifdef CMDSETEXCLUSIVESCISSORENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetExclusiveScissorEnableNV_before(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstExclusiveScissor=" + std::to_string(firstExclusiveScissor) + '!');
winsockSendToUI(&ConnectSocket,"exclusiveScissorCount=" + std::to_string(exclusiveScissorCount) + '!');
winsockSendToUI(&ConnectSocket,"pExclusiveScissorEnables=" + ptrToString((void**)std::addressof(pExclusiveScissorEnables)) + '!');
}
#ifdef CMDSETEXCLUSIVESCISSORENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetExclusiveScissorEnableNV_after(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetExclusiveScissorEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindShadingRateImageNV!");
}
#ifdef CMDBINDSHADINGRATEIMAGENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindShadingRateImageNV_before(commandBuffer, imageView, imageLayout);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"imageView=" + ptrToString((void**)std::addressof(imageView)) + '!');
}
#ifdef CMDBINDSHADINGRATEIMAGENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindShadingRateImageNV_after(commandBuffer, imageView, imageLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindShadingRateImageNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkShadingRatePaletteNV* pShadingRatePalettes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportShadingRatePaletteNV!");
}
#ifdef CMDSETVIEWPORTSHADINGRATEPALETTENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportShadingRatePaletteNV_before(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstViewport=" + std::to_string(firstViewport) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pShadingRatePalettes != VK_NULL_HANDLE && pShadingRatePalettes != NULL) {
winsockSendToUI(&ConnectSocket,"pShadingRatePalettes->shadingRatePaletteEntryCount=" + std::to_string(pShadingRatePalettes->shadingRatePaletteEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pShadingRatePalettes->pShadingRatePaletteEntries=" + ptrToString((void**)std::addressof(pShadingRatePalettes->pShadingRatePaletteEntries)) + '!');
}else winsockSendToUI(&ConnectSocket, "pShadingRatePalettes=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORTSHADINGRATEPALETTENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportShadingRatePaletteNV_after(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportShadingRatePaletteNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, VkCoarseSampleOrderCustomNV* pCustomSampleOrders) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoarseSampleOrderNV!");
}
#ifdef CMDSETCOARSESAMPLEORDERNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoarseSampleOrderNV_before(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"customSampleOrderCount=" + std::to_string(customSampleOrderCount) + '!');
if(pCustomSampleOrders != VK_NULL_HANDLE && pCustomSampleOrders != NULL) {
winsockSendToUI(&ConnectSocket,"pCustomSampleOrders->sampleCount=" + std::to_string(pCustomSampleOrders->sampleCount) + '!');
winsockSendToUI(&ConnectSocket,"pCustomSampleOrders->sampleLocationCount=" + std::to_string(pCustomSampleOrders->sampleLocationCount) + '!');
if(pCustomSampleOrders->pSampleLocations != VK_NULL_HANDLE && pCustomSampleOrders->pSampleLocations != NULL) {
winsockSendToUI(&ConnectSocket,"pCustomSampleOrders->pSampleLocations->pixelX=" + std::to_string(pCustomSampleOrders->pSampleLocations->pixelX) + '!');
winsockSendToUI(&ConnectSocket,"pCustomSampleOrders->pSampleLocations->pixelY=" + std::to_string(pCustomSampleOrders->pSampleLocations->pixelY) + '!');
winsockSendToUI(&ConnectSocket,"pCustomSampleOrders->pSampleLocations->sample=" + std::to_string(pCustomSampleOrders->pSampleLocations->sample) + '!');
}else winsockSendToUI(&ConnectSocket, "pSampleLocations=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCustomSampleOrders=VK_NULL_HANDLE!");
}
#ifdef CMDSETCOARSESAMPLEORDERNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoarseSampleOrderNV_after(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoarseSampleOrderNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksNV!");
}
#ifdef CMDDRAWMESHTASKSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksNV_before(commandBuffer, taskCount, firstTask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"taskCount=" + std::to_string(taskCount) + '!');
winsockSendToUI(&ConnectSocket,"firstTask=" + std::to_string(firstTask) + '!');
}
#ifdef CMDDRAWMESHTASKSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksNV_after(commandBuffer, taskCount, firstTask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksIndirectNV!");
}
#ifdef CMDDRAWMESHTASKSINDIRECTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectNV_before(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWMESHTASKSINDIRECTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectNV_after(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksIndirectNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksIndirectCountNV!");
}
#ifdef CMDDRAWMESHTASKSINDIRECTCOUNTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectCountNV_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWMESHTASKSINDIRECTCOUNTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectCountNV_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksIndirectCountNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksEXT!");
}
#ifdef CMDDRAWMESHTASKSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksEXT_before(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"groupCountX=" + std::to_string(groupCountX) + '!');
winsockSendToUI(&ConnectSocket,"groupCountY=" + std::to_string(groupCountY) + '!');
winsockSendToUI(&ConnectSocket,"groupCountZ=" + std::to_string(groupCountZ) + '!');
}
#ifdef CMDDRAWMESHTASKSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksEXT_after(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksIndirectEXT!");
}
#ifdef CMDDRAWMESHTASKSINDIRECTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectEXT_before(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"drawCount=" + std::to_string(drawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWMESHTASKSINDIRECTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectEXT_after(commandBuffer, buffer, offset, drawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksIndirectEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawMeshTasksIndirectCountEXT!");
}
#ifdef CMDDRAWMESHTASKSINDIRECTCOUNTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectCountEXT_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWMESHTASKSINDIRECTCOUNTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawMeshTasksIndirectCountEXT_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawMeshTasksIndirectCountEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCompileDeferredNV!");
}
#ifdef COMPILEDEFERREDNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CompileDeferredNV_before(device, pipeline, shader);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CompileDeferredNV(device, pipeline, shader);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"shader=" + std::to_string(shader) + '!');
}
#ifdef COMPILEDEFERREDNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CompileDeferredNV_after(device, pipeline, shader);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCompileDeferredNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CompileDeferredNV(device, pipeline, shader);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateAccelerationStructureNV(VkDevice device, VkAccelerationStructureCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateAccelerationStructureNV!");
}
#ifdef CREATEACCELERATIONSTRUCTURENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateAccelerationStructureNV_before(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->compactedSize=" + std::to_string(pCreateInfo->compactedSize) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->info=" + ptrToString((void**)std::addressof(pCreateInfo->info)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pAccelerationStructure=" + ptrToString((void**)std::addressof(pAccelerationStructure)) + '!');
}
#ifdef CREATEACCELERATIONSTRUCTURENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateAccelerationStructureNV_after(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateAccelerationStructureNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindInvocationMaskHUAWEI!");
}
#ifdef CMDBINDINVOCATIONMASKHUAWEI_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindInvocationMaskHUAWEI_before(commandBuffer, imageView, imageLayout);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"imageView=" + ptrToString((void**)std::addressof(imageView)) + '!');
}
#ifdef CMDBINDINVOCATIONMASKHUAWEI_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindInvocationMaskHUAWEI_after(commandBuffer, imageView, imageLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindInvocationMaskHUAWEI!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyAccelerationStructureKHR!");
}
#ifdef DESTROYACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyAccelerationStructureKHR_before(device, accelerationStructure, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructure=" + ptrToString((void**)std::addressof(accelerationStructure)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyAccelerationStructureKHR_after(device, accelerationStructure, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyAccelerationStructureNV!");
}
#ifdef DESTROYACCELERATIONSTRUCTURENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyAccelerationStructureNV_before(device, accelerationStructure, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructure=" + ptrToString((void**)std::addressof(accelerationStructure)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYACCELERATIONSTRUCTURENV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyAccelerationStructureNV_after(device, accelerationStructure, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyAccelerationStructureNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetAccelerationStructureMemoryRequirementsNV(VkDevice device, VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAccelerationStructureMemoryRequirementsNV!");
}
#ifdef GETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureMemoryRequirementsNV_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->accelerationStructure=" + ptrToString((void**)std::addressof(pInfo->accelerationStructure)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETACCELERATIONSTRUCTUREMEMORYREQUIREMENTSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureMemoryRequirementsNV_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAccelerationStructureMemoryRequirementsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, VkBindAccelerationStructureMemoryInfoNV* pBindInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindAccelerationStructureMemoryNV!");
}
#ifdef BINDACCELERATIONSTRUCTUREMEMORYNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindAccelerationStructureMemoryNV_before(device, bindInfoCount, pBindInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfos != VK_NULL_HANDLE && pBindInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfos->accelerationStructure=" + ptrToString((void**)std::addressof(pBindInfos->accelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memory=" + ptrToString((void**)std::addressof(pBindInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memoryOffset=" + std::to_string(pBindInfos->memoryOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->deviceIndexCount=" + std::to_string(pBindInfos->deviceIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfos=VK_NULL_HANDLE!");
}
#ifdef BINDACCELERATIONSTRUCTUREMEMORYNV_AFTER_EXEC_EXISTS
if(connected) {
layer_BindAccelerationStructureMemoryNV_after(device, bindInfoCount, pBindInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindAccelerationStructureMemoryNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyAccelerationStructureNV!");
}
#ifdef CMDCOPYACCELERATIONSTRUCTURENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureNV_before(commandBuffer, dst, src, mode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dst=" + ptrToString((void**)std::addressof(dst)) + '!');
winsockSendToUI(&ConnectSocket,"src=" + ptrToString((void**)std::addressof(src)) + '!');
}
#ifdef CMDCOPYACCELERATIONSTRUCTURENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureNV_after(commandBuffer, dst, src, mode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyAccelerationStructureNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, VkCopyAccelerationStructureInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyAccelerationStructureKHR!");
}
#ifdef CMDCOPYACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureKHR_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureKHR_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyAccelerationStructureInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyAccelerationStructureKHR!");
}
#ifdef COPYACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyAccelerationStructureKHR_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyAccelerationStructureKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyAccelerationStructureKHR_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyAccelerationStructureKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyAccelerationStructureToMemoryKHR!");
}
#ifdef CMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureToMemoryKHR_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYACCELERATIONSTRUCTURETOMEMORYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyAccelerationStructureToMemoryKHR_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyAccelerationStructureToMemoryKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyAccelerationStructureToMemoryKHR!");
}
#ifdef COPYACCELERATIONSTRUCTURETOMEMORYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyAccelerationStructureToMemoryKHR_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYACCELERATIONSTRUCTURETOMEMORYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyAccelerationStructureToMemoryKHR_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyAccelerationStructureToMemoryKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMemoryToAccelerationStructureKHR!");
}
#ifdef CMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToAccelerationStructureKHR_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYMEMORYTOACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToAccelerationStructureKHR_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMemoryToAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyMemoryToAccelerationStructureKHR!");
}
#ifdef COPYMEMORYTOACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToAccelerationStructureKHR_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYMEMORYTOACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToAccelerationStructureKHR_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyMemoryToAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteAccelerationStructuresPropertiesKHR!");
}
#ifdef CMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteAccelerationStructuresPropertiesKHR_before(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructureCount=" + std::to_string(accelerationStructureCount) + '!');
winsockSendToUI(&ConnectSocket,"pAccelerationStructures=" + ptrToString((void**)std::addressof(pAccelerationStructures)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
}
#ifdef CMDWRITEACCELERATIONSTRUCTURESPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteAccelerationStructuresPropertiesKHR_after(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteAccelerationStructuresPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteAccelerationStructuresPropertiesNV!");
}
#ifdef CMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteAccelerationStructuresPropertiesNV_before(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructureCount=" + std::to_string(accelerationStructureCount) + '!');
winsockSendToUI(&ConnectSocket,"pAccelerationStructures=" + ptrToString((void**)std::addressof(pAccelerationStructures)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
}
#ifdef CMDWRITEACCELERATIONSTRUCTURESPROPERTIESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteAccelerationStructuresPropertiesNV_after(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteAccelerationStructuresPropertiesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBuildAccelerationStructureNV!");
}
#ifdef CMDBUILDACCELERATIONSTRUCTURENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructureNV_before(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->type=" + ptrToString((void**)std::addressof(pInfo->type)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->flags=" + ptrToString((void**)std::addressof(pInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->instanceCount=" + std::to_string(pInfo->instanceCount) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->geometryCount=" + std::to_string(pInfo->geometryCount) + '!');
if(pInfo->pGeometries != VK_NULL_HANDLE && pInfo->pGeometries != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pGeometries->geometry=" + ptrToString((void**)std::addressof(pInfo->pGeometries->geometry)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pGeometries->flags=" + ptrToString((void**)std::addressof(pInfo->pGeometries->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeometries=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"instanceData=" + ptrToString((void**)std::addressof(instanceData)) + '!');
winsockSendToUI(&ConnectSocket,"instanceOffset=" + std::to_string(instanceOffset) + '!');
winsockSendToUI(&ConnectSocket,"update=" + bool_as_text(update) + '!');
winsockSendToUI(&ConnectSocket,"dst=" + ptrToString((void**)std::addressof(dst)) + '!');
winsockSendToUI(&ConnectSocket,"src=" + ptrToString((void**)std::addressof(src)) + '!');
winsockSendToUI(&ConnectSocket,"scratch=" + ptrToString((void**)std::addressof(scratch)) + '!');
winsockSendToUI(&ConnectSocket,"scratchOffset=" + std::to_string(scratchOffset) + '!');
}
#ifdef CMDBUILDACCELERATIONSTRUCTURENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructureNV_after(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBuildAccelerationStructureNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, size_t dataSize, void* pData, size_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWriteAccelerationStructuresPropertiesKHR!");
}
#ifdef WRITEACCELERATIONSTRUCTURESPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_WriteAccelerationStructuresPropertiesKHR_before(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructureCount=" + std::to_string(accelerationStructureCount) + '!');
winsockSendToUI(&ConnectSocket,"pAccelerationStructures=" + ptrToString((void**)std::addressof(pAccelerationStructures)) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef WRITEACCELERATIONSTRUCTURESPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_WriteAccelerationStructuresPropertiesKHR_after(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWriteAccelerationStructuresPropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdTraceRaysKHR(VkCommandBuffer commandBuffer, VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdTraceRaysKHR!");
}
#ifdef CMDTRACERAYSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysKHR_before(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRaygenShaderBindingTable != VK_NULL_HANDLE && pRaygenShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pRaygenShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->stride=" + std::to_string(pRaygenShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->size=" + std::to_string(pRaygenShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pRaygenShaderBindingTable=VK_NULL_HANDLE!");
if(pMissShaderBindingTable != VK_NULL_HANDLE && pMissShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pMissShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->stride=" + std::to_string(pMissShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->size=" + std::to_string(pMissShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMissShaderBindingTable=VK_NULL_HANDLE!");
if(pHitShaderBindingTable != VK_NULL_HANDLE && pHitShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pHitShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->stride=" + std::to_string(pHitShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->size=" + std::to_string(pHitShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pHitShaderBindingTable=VK_NULL_HANDLE!");
if(pCallableShaderBindingTable != VK_NULL_HANDLE && pCallableShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pCallableShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->stride=" + std::to_string(pCallableShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->size=" + std::to_string(pCallableShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pCallableShaderBindingTable=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"width=" + std::to_string(width) + '!');
winsockSendToUI(&ConnectSocket,"height=" + std::to_string(height) + '!');
winsockSendToUI(&ConnectSocket,"depth=" + std::to_string(depth) + '!');
}
#ifdef CMDTRACERAYSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysKHR_after(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdTraceRaysKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdTraceRaysNV!");
}
#ifdef CMDTRACERAYSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysNV_before(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"raygenShaderBindingTableBuffer=" + ptrToString((void**)std::addressof(raygenShaderBindingTableBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"raygenShaderBindingOffset=" + std::to_string(raygenShaderBindingOffset) + '!');
winsockSendToUI(&ConnectSocket,"missShaderBindingTableBuffer=" + ptrToString((void**)std::addressof(missShaderBindingTableBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"missShaderBindingOffset=" + std::to_string(missShaderBindingOffset) + '!');
winsockSendToUI(&ConnectSocket,"missShaderBindingStride=" + std::to_string(missShaderBindingStride) + '!');
winsockSendToUI(&ConnectSocket,"hitShaderBindingTableBuffer=" + ptrToString((void**)std::addressof(hitShaderBindingTableBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"hitShaderBindingOffset=" + std::to_string(hitShaderBindingOffset) + '!');
winsockSendToUI(&ConnectSocket,"hitShaderBindingStride=" + std::to_string(hitShaderBindingStride) + '!');
winsockSendToUI(&ConnectSocket,"callableShaderBindingTableBuffer=" + ptrToString((void**)std::addressof(callableShaderBindingTableBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"callableShaderBindingOffset=" + std::to_string(callableShaderBindingOffset) + '!');
winsockSendToUI(&ConnectSocket,"callableShaderBindingStride=" + std::to_string(callableShaderBindingStride) + '!');
winsockSendToUI(&ConnectSocket,"width=" + std::to_string(width) + '!');
winsockSendToUI(&ConnectSocket,"height=" + std::to_string(height) + '!');
winsockSendToUI(&ConnectSocket,"depth=" + std::to_string(depth) + '!');
}
#ifdef CMDTRACERAYSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysNV_after(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdTraceRaysNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRayTracingShaderGroupHandlesKHR!");
}
#ifdef GETRAYTRACINGSHADERGROUPHANDLESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupHandlesKHR_before(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"firstGroup=" + std::to_string(firstGroup) + '!');
winsockSendToUI(&ConnectSocket,"groupCount=" + std::to_string(groupCount) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef GETRAYTRACINGSHADERGROUPHANDLESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupHandlesKHR_after(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRayTracingShaderGroupHandlesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR!");
}
#ifdef GETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRayTracingCaptureReplayShaderGroupHandlesKHR_before(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"firstGroup=" + std::to_string(firstGroup) + '!');
winsockSendToUI(&ConnectSocket,"groupCount=" + std::to_string(groupCount) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef GETRAYTRACINGCAPTUREREPLAYSHADERGROUPHANDLESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRayTracingCaptureReplayShaderGroupHandlesKHR_after(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAccelerationStructureHandleNV!");
}
#ifdef GETACCELERATIONSTRUCTUREHANDLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureHandleNV_before(device, accelerationStructure, dataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"accelerationStructure=" + ptrToString((void**)std::addressof(accelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef GETACCELERATIONSTRUCTUREHANDLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureHandleNV_after(device, accelerationStructure, dataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAccelerationStructureHandleNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkRayTracingPipelineCreateInfoNV* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateRayTracingPipelinesNV!");
}
#ifdef CREATERAYTRACINGPIPELINESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateRayTracingPipelinesNV_before(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->stageCount=" + std::to_string(pCreateInfos->stageCount) + '!');
if(pCreateInfos->pStages != VK_NULL_HANDLE && pCreateInfos->pStages != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->module=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->module)) + '!');
if(pCreateInfos->pStages->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pStages->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->mapEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pStages=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->groupCount=" + std::to_string(pCreateInfos->groupCount) + '!');
if(pCreateInfos->pGroups != VK_NULL_HANDLE && pCreateInfos->pGroups != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->generalShader=" + std::to_string(pCreateInfos->pGroups->generalShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->closestHitShader=" + std::to_string(pCreateInfos->pGroups->closestHitShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->anyHitShader=" + std::to_string(pCreateInfos->pGroups->anyHitShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->intersectionShader=" + std::to_string(pCreateInfos->pGroups->intersectionShader) + '!');
}else winsockSendToUI(&ConnectSocket, "pGroups=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->maxRecursionDepth=" + std::to_string(pCreateInfos->maxRecursionDepth) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->layout=" + ptrToString((void**)std::addressof(pCreateInfos->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfos->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineIndex=" + std::to_string(pCreateInfos->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelines=" + ptrToString((void**)std::addressof(pPipelines)) + '!');
}
#ifdef CREATERAYTRACINGPIPELINESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateRayTracingPipelinesNV_after(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateRayTracingPipelinesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkRayTracingPipelineCreateInfoKHR* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateRayTracingPipelinesKHR!");
}
#ifdef CREATERAYTRACINGPIPELINESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateRayTracingPipelinesKHR_before(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->stageCount=" + std::to_string(pCreateInfos->stageCount) + '!');
if(pCreateInfos->pStages != VK_NULL_HANDLE && pCreateInfos->pStages != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->module=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->module)) + '!');
if(pCreateInfos->pStages->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pStages->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->mapEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pStages=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->groupCount=" + std::to_string(pCreateInfos->groupCount) + '!');
if(pCreateInfos->pGroups != VK_NULL_HANDLE && pCreateInfos->pGroups != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->generalShader=" + std::to_string(pCreateInfos->pGroups->generalShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->closestHitShader=" + std::to_string(pCreateInfos->pGroups->closestHitShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->anyHitShader=" + std::to_string(pCreateInfos->pGroups->anyHitShader) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pGroups->intersectionShader=" + std::to_string(pCreateInfos->pGroups->intersectionShader) + '!');
}else winsockSendToUI(&ConnectSocket, "pGroups=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->maxPipelineRayRecursionDepth=" + std::to_string(pCreateInfos->maxPipelineRayRecursionDepth) + '!');
if(pCreateInfos->pLibraryInfo != VK_NULL_HANDLE && pCreateInfos->pLibraryInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInfo->libraryCount=" + std::to_string(pCreateInfos->pLibraryInfo->libraryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInfo->pLibraries=" + ptrToString((void**)std::addressof(pCreateInfos->pLibraryInfo->pLibraries)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLibraryInfo=VK_NULL_HANDLE!");
if(pCreateInfos->pLibraryInterface != VK_NULL_HANDLE && pCreateInfos->pLibraryInterface != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInterface->maxPipelineRayPayloadSize=" + std::to_string(pCreateInfos->pLibraryInterface->maxPipelineRayPayloadSize) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInterface->maxPipelineRayHitAttributeSize=" + std::to_string(pCreateInfos->pLibraryInterface->maxPipelineRayHitAttributeSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pLibraryInterface=VK_NULL_HANDLE!");
if(pCreateInfos->pDynamicState != VK_NULL_HANDLE && pCreateInfos->pDynamicState != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pDynamicState->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->dynamicStateCount=" + std::to_string(pCreateInfos->pDynamicState->dynamicStateCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pDynamicState->pDynamicStates=" + ptrToString((void**)std::addressof(pCreateInfos->pDynamicState->pDynamicStates)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDynamicState=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->layout=" + ptrToString((void**)std::addressof(pCreateInfos->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfos->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineIndex=" + std::to_string(pCreateInfos->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelines=" + ptrToString((void**)std::addressof(pPipelines)) + '!');
}
#ifdef CREATERAYTRACINGPIPELINESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateRayTracingPipelinesKHR_after(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateRayTracingPipelinesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdTraceRaysIndirectKHR!");
}
#ifdef CMDTRACERAYSINDIRECTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysIndirectKHR_before(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRaygenShaderBindingTable != VK_NULL_HANDLE && pRaygenShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pRaygenShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->stride=" + std::to_string(pRaygenShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pRaygenShaderBindingTable->size=" + std::to_string(pRaygenShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pRaygenShaderBindingTable=VK_NULL_HANDLE!");
if(pMissShaderBindingTable != VK_NULL_HANDLE && pMissShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pMissShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->stride=" + std::to_string(pMissShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pMissShaderBindingTable->size=" + std::to_string(pMissShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMissShaderBindingTable=VK_NULL_HANDLE!");
if(pHitShaderBindingTable != VK_NULL_HANDLE && pHitShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pHitShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->stride=" + std::to_string(pHitShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pHitShaderBindingTable->size=" + std::to_string(pHitShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pHitShaderBindingTable=VK_NULL_HANDLE!");
if(pCallableShaderBindingTable != VK_NULL_HANDLE && pCallableShaderBindingTable != NULL) {
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->deviceAddress=" + ptrToString((void**)std::addressof(pCallableShaderBindingTable->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->stride=" + std::to_string(pCallableShaderBindingTable->stride) + '!');
winsockSendToUI(&ConnectSocket,"pCallableShaderBindingTable->size=" + std::to_string(pCallableShaderBindingTable->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pCallableShaderBindingTable=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"indirectDeviceAddress=" + ptrToString((void**)std::addressof(indirectDeviceAddress)) + '!');
}
#ifdef CMDTRACERAYSINDIRECTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysIndirectKHR_after(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdTraceRaysIndirectKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdTraceRaysIndirect2KHR!");
}
#ifdef CMDTRACERAYSINDIRECT2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysIndirect2KHR_before(commandBuffer, indirectDeviceAddress);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"indirectDeviceAddress=" + ptrToString((void**)std::addressof(indirectDeviceAddress)) + '!');
}
#ifdef CMDTRACERAYSINDIRECT2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdTraceRaysIndirect2KHR_after(commandBuffer, indirectDeviceAddress);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdTraceRaysIndirect2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, VkAccelerationStructureVersionInfoKHR* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceAccelerationStructureCompatibilityKHR!");
}
#ifdef GETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceAccelerationStructureCompatibilityKHR_before(device, pVersionInfo, pCompatibility);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pVersionInfo != VK_NULL_HANDLE && pVersionInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pVersionInfo->pVersionData=" + ptrToString((void**)std::addressof(pVersionInfo->pVersionData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVersionInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCompatibility=" + ptrToString((void**)std::addressof(pCompatibility)) + '!');
}
#ifdef GETDEVICEACCELERATIONSTRUCTURECOMPATIBILITYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceAccelerationStructureCompatibilityKHR_after(device, pVersionInfo, pCompatibility);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceAccelerationStructureCompatibilityKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
}
}

 VK_LAYER_EXPORT VkDeviceSize VKAPI_CALL DebuggerLayer_GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRayTracingShaderGroupStackSizeKHR!");
}
#ifdef GETRAYTRACINGSHADERGROUPSTACKSIZEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupStackSizeKHR_before(device, pipeline, group, groupShader);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"group=" + std::to_string(group) + '!');
}
#ifdef GETRAYTRACINGSHADERGROUPSTACKSIZEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupStackSizeKHR_after(device, pipeline, group, groupShader);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRayTracingShaderGroupStackSizeKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRayTracingPipelineStackSizeKHR!");
}
#ifdef CMDSETRAYTRACINGPIPELINESTACKSIZEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRayTracingPipelineStackSizeKHR_before(commandBuffer, pipelineStackSize);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineStackSize=" + std::to_string(pipelineStackSize) + '!');
}
#ifdef CMDSETRAYTRACINGPIPELINESTACKSIZEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRayTracingPipelineStackSizeKHR_after(commandBuffer, pipelineStackSize);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRayTracingPipelineStackSizeKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
}
}

 VK_LAYER_EXPORT uint32_t VKAPI_CALL DebuggerLayer_GetImageViewHandleNVX(VkDevice device, VkImageViewHandleInfoNVX* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageViewHandleNVX!");
}
#ifdef GETIMAGEVIEWHANDLENVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageViewHandleNVX_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetImageViewHandleNVX(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->imageView=" + ptrToString((void**)std::addressof(pInfo->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->sampler=" + ptrToString((void**)std::addressof(pInfo->sampler)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEVIEWHANDLENVX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageViewHandleNVX_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageViewHandleNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetImageViewHandleNVX(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetImageViewAddressNVX(VkDevice device, VkImageView imageView, VkImageViewAddressPropertiesNVX* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageViewAddressNVX!");
}
#ifdef GETIMAGEVIEWADDRESSNVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageViewAddressNVX_before(device, imageView, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetImageViewAddressNVX(device, imageView, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"imageView=" + ptrToString((void**)std::addressof(imageView)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->deviceAddress=" + ptrToString((void**)std::addressof(pProperties->deviceAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->size=" + std::to_string(pProperties->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEVIEWADDRESSNVX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageViewAddressNVX_after(device, imageView, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageViewAddressNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetImageViewAddressNVX(device, imageView, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceGroupSurfacePresentModes2EXT!");
}
#ifdef GETDEVICEGROUPSURFACEPRESENTMODES2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupSurfacePresentModes2EXT_before(device, pSurfaceInfo, pModes);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pSurfaceInfo != VK_NULL_HANDLE && pSurfaceInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSurfaceInfo->surface=" + ptrToString((void**)std::addressof(pSurfaceInfo->surface)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSurfaceInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pModes=" + ptrToString((void**)std::addressof(pModes)) + '!');
}
#ifdef GETDEVICEGROUPSURFACEPRESENTMODES2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupSurfacePresentModes2EXT_after(device, pSurfaceInfo, pModes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceGroupSurfacePresentModes2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireFullScreenExclusiveModeEXT!");
}
#ifdef ACQUIREFULLSCREENEXCLUSIVEMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireFullScreenExclusiveModeEXT_before(device, swapchain);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquireFullScreenExclusiveModeEXT(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
}
#ifdef ACQUIREFULLSCREENEXCLUSIVEMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireFullScreenExclusiveModeEXT_after(device, swapchain);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireFullScreenExclusiveModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquireFullScreenExclusiveModeEXT(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkReleaseFullScreenExclusiveModeEXT!");
}
#ifdef RELEASEFULLSCREENEXCLUSIVEMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ReleaseFullScreenExclusiveModeEXT_before(device, swapchain);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ReleaseFullScreenExclusiveModeEXT(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
}
#ifdef RELEASEFULLSCREENEXCLUSIVEMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_ReleaseFullScreenExclusiveModeEXT_after(device, swapchain);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkReleaseFullScreenExclusiveModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ReleaseFullScreenExclusiveModeEXT(device, swapchain);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquireProfilingLockKHR(VkDevice device, VkAcquireProfilingLockInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquireProfilingLockKHR!");
}
#ifdef ACQUIREPROFILINGLOCKKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquireProfilingLockKHR_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquireProfilingLockKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->flags=" + ptrToString((void**)std::addressof(pInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->timeout=" + std::to_string(pInfo->timeout) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef ACQUIREPROFILINGLOCKKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquireProfilingLockKHR_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquireProfilingLockKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquireProfilingLockKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_ReleaseProfilingLockKHR(VkDevice device) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkReleaseProfilingLockKHR!");
}
#ifdef RELEASEPROFILINGLOCKKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_ReleaseProfilingLockKHR_before(device);
}
#endif 
device_dispatch[GetKey(device)].ReleaseProfilingLockKHR(device);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
}
#ifdef RELEASEPROFILINGLOCKKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_ReleaseProfilingLockKHR_after(device);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkReleaseProfilingLockKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].ReleaseProfilingLockKHR(device);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageDrmFormatModifierPropertiesEXT!");
}
#ifdef GETIMAGEDRMFORMATMODIFIERPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageDrmFormatModifierPropertiesEXT_before(device, image, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->drmFormatModifier=" + std::to_string(pProperties->drmFormatModifier) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEDRMFORMATMODIFIERPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageDrmFormatModifierPropertiesEXT_after(device, image, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageDrmFormatModifierPropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT uint64_t VKAPI_CALL DebuggerLayer_GetBufferOpaqueCaptureAddress(VkDevice device, VkBufferDeviceAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferOpaqueCaptureAddress!");
}
#ifdef GETBUFFEROPAQUECAPTUREADDRESS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureAddress_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFEROPAQUECAPTUREADDRESS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureAddress_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferOpaqueCaptureAddress!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkDeviceAddress VKAPI_CALL DebuggerLayer_GetBufferDeviceAddress(VkDevice device, VkBufferDeviceAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferDeviceAddress!");
}
#ifdef GETBUFFERDEVICEADDRESS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddress_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERDEVICEADDRESS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddress_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferDeviceAddress!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_InitializePerformanceApiINTEL(VkDevice device, VkInitializePerformanceApiInfoINTEL* pInitializeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkInitializePerformanceApiINTEL!");
}
#ifdef INITIALIZEPERFORMANCEAPIINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_InitializePerformanceApiINTEL_before(device, pInitializeInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].InitializePerformanceApiINTEL(device, pInitializeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInitializeInfo != VK_NULL_HANDLE && pInitializeInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pInitializeInfo=VK_NULL_HANDLE!");
}
#ifdef INITIALIZEPERFORMANCEAPIINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_InitializePerformanceApiINTEL_after(device, pInitializeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkInitializePerformanceApiINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].InitializePerformanceApiINTEL(device, pInitializeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_UninitializePerformanceApiINTEL(VkDevice device) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUninitializePerformanceApiINTEL!");
}
#ifdef UNINITIALIZEPERFORMANCEAPIINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_UninitializePerformanceApiINTEL_before(device);
}
#endif 
device_dispatch[GetKey(device)].UninitializePerformanceApiINTEL(device);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
}
#ifdef UNINITIALIZEPERFORMANCEAPIINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_UninitializePerformanceApiINTEL_after(device);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUninitializePerformanceApiINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].UninitializePerformanceApiINTEL(device);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, VkPerformanceMarkerInfoINTEL* pMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPerformanceMarkerINTEL!");
}
#ifdef CMDSETPERFORMANCEMARKERINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceMarkerINTEL_before(commandBuffer, pMarkerInfo);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pMarkerInfo != VK_NULL_HANDLE && pMarkerInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pMarkerInfo->marker=" + std::to_string(pMarkerInfo->marker) + '!');
}else winsockSendToUI(&ConnectSocket, "pMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETPERFORMANCEMARKERINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceMarkerINTEL_after(commandBuffer, pMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPerformanceMarkerINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPerformanceStreamMarkerINTEL!");
}
#ifdef CMDSETPERFORMANCESTREAMMARKERINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceStreamMarkerINTEL_before(commandBuffer, pMarkerInfo);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pMarkerInfo != VK_NULL_HANDLE && pMarkerInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pMarkerInfo->marker=" + std::to_string(pMarkerInfo->marker) + '!');
}else winsockSendToUI(&ConnectSocket, "pMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETPERFORMANCESTREAMMARKERINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceStreamMarkerINTEL_after(commandBuffer, pMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPerformanceStreamMarkerINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, VkPerformanceOverrideInfoINTEL* pOverrideInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPerformanceOverrideINTEL!");
}
#ifdef CMDSETPERFORMANCEOVERRIDEINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceOverrideINTEL_before(commandBuffer, pOverrideInfo);
}
#endif 
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pOverrideInfo != VK_NULL_HANDLE && pOverrideInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pOverrideInfo->enable=" + bool_as_text(pOverrideInfo->enable) + '!');
winsockSendToUI(&ConnectSocket,"pOverrideInfo->parameter=" + std::to_string(pOverrideInfo->parameter) + '!');
}else winsockSendToUI(&ConnectSocket, "pOverrideInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETPERFORMANCEOVERRIDEINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPerformanceOverrideINTEL_after(commandBuffer, pOverrideInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPerformanceOverrideINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(commandBuffer)].CmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_AcquirePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkAcquirePerformanceConfigurationINTEL!");
}
#ifdef ACQUIREPERFORMANCECONFIGURATIONINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_AcquirePerformanceConfigurationINTEL_before(device, pAcquireInfo, pConfiguration);
}
#endif 
auto ret = device_dispatch[GetKey(device)].AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAcquireInfo != VK_NULL_HANDLE && pAcquireInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pAcquireInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pConfiguration=" + ptrToString((void**)std::addressof(pConfiguration)) + '!');
}
#ifdef ACQUIREPERFORMANCECONFIGURATIONINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_AcquirePerformanceConfigurationINTEL_after(device, pAcquireInfo, pConfiguration);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkAcquirePerformanceConfigurationINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].AcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkReleasePerformanceConfigurationINTEL!");
}
#ifdef RELEASEPERFORMANCECONFIGURATIONINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_ReleasePerformanceConfigurationINTEL_before(device, configuration);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ReleasePerformanceConfigurationINTEL(device, configuration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"configuration=" + ptrToString((void**)std::addressof(configuration)) + '!');
}
#ifdef RELEASEPERFORMANCECONFIGURATIONINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_ReleasePerformanceConfigurationINTEL_after(device, configuration);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkReleasePerformanceConfigurationINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ReleasePerformanceConfigurationINTEL(device, configuration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueSetPerformanceConfigurationINTEL!");
}
#ifdef QUEUESETPERFORMANCECONFIGURATIONINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueSetPerformanceConfigurationINTEL_before(queue, configuration);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueSetPerformanceConfigurationINTEL(queue, configuration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"configuration=" + ptrToString((void**)std::addressof(configuration)) + '!');
}
#ifdef QUEUESETPERFORMANCECONFIGURATIONINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueSetPerformanceConfigurationINTEL_after(queue, configuration);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueSetPerformanceConfigurationINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueSetPerformanceConfigurationINTEL(queue, configuration);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPerformanceParameterINTEL!");
}
#ifdef GETPERFORMANCEPARAMETERINTEL_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPerformanceParameterINTEL_before(device, parameter, pValue);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPerformanceParameterINTEL(device, parameter, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pValue != VK_NULL_HANDLE && pValue != NULL) {
winsockSendToUI(&ConnectSocket,"pValue->data=" + ptrToString((void**)std::addressof(pValue->data)) + '!');
}else winsockSendToUI(&ConnectSocket, "pValue=VK_NULL_HANDLE!");
}
#ifdef GETPERFORMANCEPARAMETERINTEL_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPerformanceParameterINTEL_after(device, parameter, pValue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPerformanceParameterINTEL!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPerformanceParameterINTEL(device, parameter, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT uint64_t VKAPI_CALL DebuggerLayer_GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceMemoryOpaqueCaptureAddress!");
}
#ifdef GETDEVICEMEMORYOPAQUECAPTUREADDRESS_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryOpaqueCaptureAddress_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->memory=" + ptrToString((void**)std::addressof(pInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEMEMORYOPAQUECAPTUREADDRESS_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryOpaqueCaptureAddress_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceMemoryOpaqueCaptureAddress!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPipelineExecutablePropertiesKHR(VkDevice device, VkPipelineInfoKHR* pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineExecutablePropertiesKHR!");
}
#ifdef GETPIPELINEEXECUTABLEPROPERTIESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutablePropertiesKHR_before(device, pPipelineInfo, pExecutableCount, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pPipelineInfo != VK_NULL_HANDLE && pPipelineInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPipelineInfo->pipeline=" + ptrToString((void**)std::addressof(pPipelineInfo->pipeline)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPipelineInfo=VK_NULL_HANDLE!");
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->stages=" + ptrToString((void**)std::addressof(pProperties->stages)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->subgroupSize=" + std::to_string(pProperties->subgroupSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEEXECUTABLEPROPERTIESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutablePropertiesKHR_after(device, pPipelineInfo, pExecutableCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineExecutablePropertiesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPipelineExecutableStatisticsKHR(VkDevice device, VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineExecutableStatisticsKHR!");
}
#ifdef GETPIPELINEEXECUTABLESTATISTICSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutableStatisticsKHR_before(device, pExecutableInfo, pStatisticCount, pStatistics);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pExecutableInfo != VK_NULL_HANDLE && pExecutableInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pExecutableInfo->pipeline=" + ptrToString((void**)std::addressof(pExecutableInfo->pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pExecutableInfo->executableIndex=" + std::to_string(pExecutableInfo->executableIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pExecutableInfo=VK_NULL_HANDLE!");
if(pStatistics != VK_NULL_HANDLE && pStatistics != NULL) {
winsockSendToUI(&ConnectSocket,"pStatistics->value=" + ptrToString((void**)std::addressof(pStatistics->value)) + '!');
}else winsockSendToUI(&ConnectSocket, "pStatistics=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEEXECUTABLESTATISTICSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutableStatisticsKHR_after(device, pExecutableInfo, pStatisticCount, pStatistics);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineExecutableStatisticsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, VkPipelineExecutableInfoKHR* pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineExecutableInternalRepresentationsKHR!");
}
#ifdef GETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutableInternalRepresentationsKHR_before(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pExecutableInfo != VK_NULL_HANDLE && pExecutableInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pExecutableInfo->pipeline=" + ptrToString((void**)std::addressof(pExecutableInfo->pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"pExecutableInfo->executableIndex=" + std::to_string(pExecutableInfo->executableIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pExecutableInfo=VK_NULL_HANDLE!");
if(pInternalRepresentations != VK_NULL_HANDLE && pInternalRepresentations != NULL) {
winsockSendToUI(&ConnectSocket,"pInternalRepresentations->isText=" + bool_as_text(pInternalRepresentations->isText) + '!');
winsockSendToUI(&ConnectSocket,"pInternalRepresentations->dataSize=" + std::to_string(pInternalRepresentations->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pInternalRepresentations=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEEXECUTABLEINTERNALREPRESENTATIONSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineExecutableInternalRepresentationsKHR_after(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineExecutableInternalRepresentationsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateAccelerationStructureKHR(VkDevice device, VkAccelerationStructureCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkAccelerationStructureKHR* pAccelerationStructure) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateAccelerationStructureKHR!");
}
#ifdef CREATEACCELERATIONSTRUCTUREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateAccelerationStructureKHR_before(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->createFlags=" + ptrToString((void**)std::addressof(pCreateInfo->createFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->buffer=" + ptrToString((void**)std::addressof(pCreateInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->offset=" + std::to_string(pCreateInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->size=" + std::to_string(pCreateInfo->size) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->deviceAddress=" + ptrToString((void**)std::addressof(pCreateInfo->deviceAddress)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pAccelerationStructure=" + ptrToString((void**)std::addressof(pAccelerationStructure)) + '!');
}
#ifdef CREATEACCELERATIONSTRUCTUREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateAccelerationStructureKHR_after(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateAccelerationStructureKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBuildAccelerationStructuresKHR!");
}
#ifdef CMDBUILDACCELERATIONSTRUCTURESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructuresKHR_before(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"infoCount=" + std::to_string(infoCount) + '!');
if(pInfos != VK_NULL_HANDLE && pInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->flags=" + ptrToString((void**)std::addressof(pInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->srcAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->srcAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->dstAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->dstAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->geometryCount=" + std::to_string(pInfos->geometryCount) + '!');
if(pInfos->pGeometries != VK_NULL_HANDLE && pInfos->pGeometries != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->geometry=" + ptrToString((void**)std::addressof(pInfos->pGeometries->geometry)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->flags=" + ptrToString((void**)std::addressof(pInfos->pGeometries->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeometries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pInfos->scratchData=" + ptrToString((void**)std::addressof(pInfos->scratchData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"ppBuildRangeInfos=" + ptrToString((void**)std::addressof(ppBuildRangeInfos)) + '!');
}
#ifdef CMDBUILDACCELERATIONSTRUCTURESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructuresKHR_after(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBuildAccelerationStructuresKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkDeviceAddress* pIndirectDeviceAddresses, uint32_t* pIndirectStrides, uint32_t** ppMaxPrimitiveCounts) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBuildAccelerationStructuresIndirectKHR!");
}
#ifdef CMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructuresIndirectKHR_before(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"infoCount=" + std::to_string(infoCount) + '!');
if(pInfos != VK_NULL_HANDLE && pInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->flags=" + ptrToString((void**)std::addressof(pInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->srcAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->srcAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->dstAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->dstAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->geometryCount=" + std::to_string(pInfos->geometryCount) + '!');
if(pInfos->pGeometries != VK_NULL_HANDLE && pInfos->pGeometries != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->geometry=" + ptrToString((void**)std::addressof(pInfos->pGeometries->geometry)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->flags=" + ptrToString((void**)std::addressof(pInfos->pGeometries->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeometries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pInfos->scratchData=" + ptrToString((void**)std::addressof(pInfos->scratchData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pIndirectDeviceAddresses=" + ptrToString((void**)std::addressof(pIndirectDeviceAddresses)) + '!');
winsockSendToUI(&ConnectSocket,"ppMaxPrimitiveCounts=" + ptrToString((void**)std::addressof(ppMaxPrimitiveCounts)) + '!');
}
#ifdef CMDBUILDACCELERATIONSTRUCTURESINDIRECTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBuildAccelerationStructuresIndirectKHR_after(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBuildAccelerationStructuresIndirectKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, VkAccelerationStructureBuildGeometryInfoKHR* pInfos, VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBuildAccelerationStructuresKHR!");
}
#ifdef BUILDACCELERATIONSTRUCTURESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_BuildAccelerationStructuresKHR_before(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
winsockSendToUI(&ConnectSocket,"infoCount=" + std::to_string(infoCount) + '!');
if(pInfos != VK_NULL_HANDLE && pInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->flags=" + ptrToString((void**)std::addressof(pInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->srcAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->srcAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->dstAccelerationStructure=" + ptrToString((void**)std::addressof(pInfos->dstAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->geometryCount=" + std::to_string(pInfos->geometryCount) + '!');
if(pInfos->pGeometries != VK_NULL_HANDLE && pInfos->pGeometries != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->geometry=" + ptrToString((void**)std::addressof(pInfos->pGeometries->geometry)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pGeometries->flags=" + ptrToString((void**)std::addressof(pInfos->pGeometries->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeometries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pInfos->scratchData=" + ptrToString((void**)std::addressof(pInfos->scratchData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"ppBuildRangeInfos=" + ptrToString((void**)std::addressof(ppBuildRangeInfos)) + '!');
}
#ifdef BUILDACCELERATIONSTRUCTURESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_BuildAccelerationStructuresKHR_after(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBuildAccelerationStructuresKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkDeviceAddress VKAPI_CALL DebuggerLayer_GetAccelerationStructureDeviceAddressKHR(VkDevice device, VkAccelerationStructureDeviceAddressInfoKHR* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAccelerationStructureDeviceAddressKHR!");
}
#ifdef GETACCELERATIONSTRUCTUREDEVICEADDRESSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureDeviceAddressKHR_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureDeviceAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->accelerationStructure=" + ptrToString((void**)std::addressof(pInfo->accelerationStructure)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETACCELERATIONSTRUCTUREDEVICEADDRESSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureDeviceAddressKHR_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAccelerationStructureDeviceAddressKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureDeviceAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDeferredOperationKHR(VkDevice device, VkAllocationCallbacks* pAllocator, VkDeferredOperationKHR* pDeferredOperation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDeferredOperationKHR!");
}
#ifdef CREATEDEFERREDOPERATIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDeferredOperationKHR_before(device, pAllocator, pDeferredOperation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDeferredOperation=" + ptrToString((void**)std::addressof(pDeferredOperation)) + '!');
}
#ifdef CREATEDEFERREDOPERATIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDeferredOperationKHR_after(device, pAllocator, pDeferredOperation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDeferredOperationKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDeferredOperationKHR!");
}
#ifdef DESTROYDEFERREDOPERATIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDeferredOperationKHR_before(device, operation, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyDeferredOperationKHR(device, operation, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"operation=" + ptrToString((void**)std::addressof(operation)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDEFERREDOPERATIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDeferredOperationKHR_after(device, operation, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDeferredOperationKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyDeferredOperationKHR(device, operation, pAllocator);
}
}

 VK_LAYER_EXPORT uint32_t VKAPI_CALL DebuggerLayer_GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeferredOperationMaxConcurrencyKHR!");
}
#ifdef GETDEFERREDOPERATIONMAXCONCURRENCYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeferredOperationMaxConcurrencyKHR_before(device, operation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeferredOperationMaxConcurrencyKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"operation=" + ptrToString((void**)std::addressof(operation)) + '!');
}
#ifdef GETDEFERREDOPERATIONMAXCONCURRENCYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeferredOperationMaxConcurrencyKHR_after(device, operation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeferredOperationMaxConcurrencyKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeferredOperationMaxConcurrencyKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeferredOperationResultKHR!");
}
#ifdef GETDEFERREDOPERATIONRESULTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeferredOperationResultKHR_before(device, operation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeferredOperationResultKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"operation=" + ptrToString((void**)std::addressof(operation)) + '!');
}
#ifdef GETDEFERREDOPERATIONRESULTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeferredOperationResultKHR_after(device, operation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeferredOperationResultKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeferredOperationResultKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDeferredOperationJoinKHR!");
}
#ifdef DEFERREDOPERATIONJOINKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DeferredOperationJoinKHR_before(device, operation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].DeferredOperationJoinKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"operation=" + ptrToString((void**)std::addressof(operation)) + '!');
}
#ifdef DEFERREDOPERATIONJOINKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DeferredOperationJoinKHR_after(device, operation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDeferredOperationJoinKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].DeferredOperationJoinKHR(device, operation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPipelineIndirectMemoryRequirementsNV(VkDevice device, VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineIndirectMemoryRequirementsNV!");
}
#ifdef GETPIPELINEINDIRECTMEMORYREQUIREMENTSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineIndirectMemoryRequirementsNV_before(device, pCreateInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->stage=" + ptrToString((void**)std::addressof(pCreateInfo->stage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->layout=" + ptrToString((void**)std::addressof(pCreateInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfo->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->basePipelineIndex=" + std::to_string(pCreateInfo->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEINDIRECTMEMORYREQUIREMENTSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineIndirectMemoryRequirementsNV_after(device, pCreateInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineIndirectMemoryRequirementsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkDeviceAddress VKAPI_CALL DebuggerLayer_GetPipelineIndirectDeviceAddressNV(VkDevice device, VkPipelineIndirectDeviceAddressInfoNV* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelineIndirectDeviceAddressNV!");
}
#ifdef GETPIPELINEINDIRECTDEVICEADDRESSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelineIndirectDeviceAddressNV_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelineIndirectDeviceAddressNV(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pipeline=" + ptrToString((void**)std::addressof(pInfo->pipeline)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEINDIRECTDEVICEADDRESSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelineIndirectDeviceAddressNV_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelineIndirectDeviceAddressNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelineIndirectDeviceAddressNV(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCullMode!");
}
#ifdef CMDSETCULLMODE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCullMode_before(commandBuffer, cullMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCullMode(commandBuffer, cullMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"cullMode=" + ptrToString((void**)std::addressof(cullMode)) + '!');
}
#ifdef CMDSETCULLMODE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCullMode_after(commandBuffer, cullMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCullMode!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCullMode(commandBuffer, cullMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetFrontFace!");
}
#ifdef CMDSETFRONTFACE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetFrontFace_before(commandBuffer, frontFace);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetFrontFace(commandBuffer, frontFace);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETFRONTFACE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetFrontFace_after(commandBuffer, frontFace);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetFrontFace!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetFrontFace(commandBuffer, frontFace);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPrimitiveTopology!");
}
#ifdef CMDSETPRIMITIVETOPOLOGY_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveTopology_before(commandBuffer, primitiveTopology);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETPRIMITIVETOPOLOGY_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveTopology_after(commandBuffer, primitiveTopology);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPrimitiveTopology!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, VkViewport* pViewports) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportWithCount!");
}
#ifdef CMDSETVIEWPORTWITHCOUNT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWithCount_before(commandBuffer, viewportCount, pViewports);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pViewports != VK_NULL_HANDLE && pViewports != NULL) {
winsockSendToUI(&ConnectSocket,"pViewports->x=" + std::to_string(pViewports->x) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->y=" + std::to_string(pViewports->y) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->width=" + std::to_string(pViewports->width) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->height=" + std::to_string(pViewports->height) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->minDepth=" + std::to_string(pViewports->minDepth) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->maxDepth=" + std::to_string(pViewports->maxDepth) + '!');
}else winsockSendToUI(&ConnectSocket, "pViewports=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORTWITHCOUNT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWithCount_after(commandBuffer, viewportCount, pViewports);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportWithCount!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, VkRect2D* pScissors) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetScissorWithCount!");
}
#ifdef CMDSETSCISSORWITHCOUNT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetScissorWithCount_before(commandBuffer, scissorCount, pScissors);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scissorCount=" + std::to_string(scissorCount) + '!');
if(pScissors != VK_NULL_HANDLE && pScissors != NULL) {
winsockSendToUI(&ConnectSocket,"pScissors->offset=" + ptrToString((void**)std::addressof(pScissors->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pScissors->extent=" + ptrToString((void**)std::addressof(pScissors->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pScissors=VK_NULL_HANDLE!");
}
#ifdef CMDSETSCISSORWITHCOUNT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetScissorWithCount_after(commandBuffer, scissorCount, pScissors);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetScissorWithCount!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindIndexBuffer2KHR!");
}
#ifdef CMDBINDINDEXBUFFER2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindIndexBuffer2KHR_before(commandBuffer, buffer, offset, size, indexType);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"size=" + std::to_string(size) + '!');
}
#ifdef CMDBINDINDEXBUFFER2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindIndexBuffer2KHR_after(commandBuffer, buffer, offset, size, indexType);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindIndexBuffer2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets, VkDeviceSize* pSizes, VkDeviceSize* pStrides) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindVertexBuffers2!");
}
#ifdef CMDBINDVERTEXBUFFERS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers2_before(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstBinding=" + std::to_string(firstBinding) + '!');
winsockSendToUI(&ConnectSocket,"bindingCount=" + std::to_string(bindingCount) + '!');
winsockSendToUI(&ConnectSocket,"pBuffers=" + ptrToString((void**)std::addressof(pBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pOffsets=" + ptrToString((void**)std::addressof(pOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pSizes=" + ptrToString((void**)std::addressof(pSizes)) + '!');
winsockSendToUI(&ConnectSocket,"pStrides=" + ptrToString((void**)std::addressof(pStrides)) + '!');
}
#ifdef CMDBINDVERTEXBUFFERS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers2_after(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindVertexBuffers2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthTestEnable!");
}
#ifdef CMDSETDEPTHTESTENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthTestEnable_before(commandBuffer, depthTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthTestEnable(commandBuffer, depthTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthTestEnable=" + bool_as_text(depthTestEnable) + '!');
}
#ifdef CMDSETDEPTHTESTENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthTestEnable_after(commandBuffer, depthTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthTestEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthWriteEnable!");
}
#ifdef CMDSETDEPTHWRITEENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthWriteEnable_before(commandBuffer, depthWriteEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthWriteEnable=" + bool_as_text(depthWriteEnable) + '!');
}
#ifdef CMDSETDEPTHWRITEENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthWriteEnable_after(commandBuffer, depthWriteEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthWriteEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthCompareOp!");
}
#ifdef CMDSETDEPTHCOMPAREOP_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthCompareOp_before(commandBuffer, depthCompareOp);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthCompareOp(commandBuffer, depthCompareOp);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETDEPTHCOMPAREOP_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthCompareOp_after(commandBuffer, depthCompareOp);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthCompareOp!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBoundsTestEnable!");
}
#ifdef CMDSETDEPTHBOUNDSTESTENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBoundsTestEnable_before(commandBuffer, depthBoundsTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthBoundsTestEnable=" + bool_as_text(depthBoundsTestEnable) + '!');
}
#ifdef CMDSETDEPTHBOUNDSTESTENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBoundsTestEnable_after(commandBuffer, depthBoundsTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBoundsTestEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilTestEnable!");
}
#ifdef CMDSETSTENCILTESTENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilTestEnable_before(commandBuffer, stencilTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stencilTestEnable=" + bool_as_text(stencilTestEnable) + '!');
}
#ifdef CMDSETSTENCILTESTENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilTestEnable_after(commandBuffer, stencilTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilTestEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilOp!");
}
#ifdef CMDSETSTENCILOP_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilOp_before(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"faceMask=" + ptrToString((void**)std::addressof(faceMask)) + '!');
}
#ifdef CMDSETSTENCILOP_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilOp_after(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilOp!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPatchControlPointsEXT!");
}
#ifdef CMDSETPATCHCONTROLPOINTSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPatchControlPointsEXT_before(commandBuffer, patchControlPoints);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"patchControlPoints=" + std::to_string(patchControlPoints) + '!');
}
#ifdef CMDSETPATCHCONTROLPOINTSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPatchControlPointsEXT_after(commandBuffer, patchControlPoints);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPatchControlPointsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRasterizerDiscardEnable!");
}
#ifdef CMDSETRASTERIZERDISCARDENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizerDiscardEnable_before(commandBuffer, rasterizerDiscardEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"rasterizerDiscardEnable=" + bool_as_text(rasterizerDiscardEnable) + '!');
}
#ifdef CMDSETRASTERIZERDISCARDENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizerDiscardEnable_after(commandBuffer, rasterizerDiscardEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRasterizerDiscardEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBiasEnable!");
}
#ifdef CMDSETDEPTHBIASENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBiasEnable_before(commandBuffer, depthBiasEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthBiasEnable=" + bool_as_text(depthBiasEnable) + '!');
}
#ifdef CMDSETDEPTHBIASENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBiasEnable_after(commandBuffer, depthBiasEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBiasEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLogicOpEXT!");
}
#ifdef CMDSETLOGICOPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLogicOpEXT_before(commandBuffer, logicOp);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLogicOpEXT(commandBuffer, logicOp);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETLOGICOPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLogicOpEXT_after(commandBuffer, logicOp);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLogicOpEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLogicOpEXT(commandBuffer, logicOp);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPrimitiveRestartEnable!");
}
#ifdef CMDSETPRIMITIVERESTARTENABLE_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveRestartEnable_before(commandBuffer, primitiveRestartEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"primitiveRestartEnable=" + bool_as_text(primitiveRestartEnable) + '!');
}
#ifdef CMDSETPRIMITIVERESTARTENABLE_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveRestartEnable_after(commandBuffer, primitiveRestartEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPrimitiveRestartEnable!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetTessellationDomainOriginEXT!");
}
#ifdef CMDSETTESSELLATIONDOMAINORIGINEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetTessellationDomainOriginEXT_before(commandBuffer, domainOrigin);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETTESSELLATIONDOMAINORIGINEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetTessellationDomainOriginEXT_after(commandBuffer, domainOrigin);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetTessellationDomainOriginEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthClampEnableEXT!");
}
#ifdef CMDSETDEPTHCLAMPENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClampEnableEXT_before(commandBuffer, depthClampEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthClampEnable=" + bool_as_text(depthClampEnable) + '!');
}
#ifdef CMDSETDEPTHCLAMPENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClampEnableEXT_after(commandBuffer, depthClampEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthClampEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPolygonModeEXT!");
}
#ifdef CMDSETPOLYGONMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPolygonModeEXT_before(commandBuffer, polygonMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPolygonModeEXT(commandBuffer, polygonMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETPOLYGONMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPolygonModeEXT_after(commandBuffer, polygonMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPolygonModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPolygonModeEXT(commandBuffer, polygonMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRasterizationSamplesEXT!");
}
#ifdef CMDSETRASTERIZATIONSAMPLESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizationSamplesEXT_before(commandBuffer, rasterizationSamples);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETRASTERIZATIONSAMPLESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizationSamplesEXT_after(commandBuffer, rasterizationSamples);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRasterizationSamplesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, VkSampleMask* pSampleMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetSampleMaskEXT!");
}
#ifdef CMDSETSAMPLEMASKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleMaskEXT_before(commandBuffer, samples, pSampleMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pSampleMask=" + ptrToString((void**)std::addressof(pSampleMask)) + '!');
}
#ifdef CMDSETSAMPLEMASKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleMaskEXT_after(commandBuffer, samples, pSampleMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetSampleMaskEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetAlphaToCoverageEnableEXT!");
}
#ifdef CMDSETALPHATOCOVERAGEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetAlphaToCoverageEnableEXT_before(commandBuffer, alphaToCoverageEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"alphaToCoverageEnable=" + bool_as_text(alphaToCoverageEnable) + '!');
}
#ifdef CMDSETALPHATOCOVERAGEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetAlphaToCoverageEnableEXT_after(commandBuffer, alphaToCoverageEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetAlphaToCoverageEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetAlphaToOneEnableEXT!");
}
#ifdef CMDSETALPHATOONEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetAlphaToOneEnableEXT_before(commandBuffer, alphaToOneEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"alphaToOneEnable=" + bool_as_text(alphaToOneEnable) + '!');
}
#ifdef CMDSETALPHATOONEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetAlphaToOneEnableEXT_after(commandBuffer, alphaToOneEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetAlphaToOneEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLogicOpEnableEXT!");
}
#ifdef CMDSETLOGICOPENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLogicOpEnableEXT_before(commandBuffer, logicOpEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"logicOpEnable=" + bool_as_text(logicOpEnable) + '!');
}
#ifdef CMDSETLOGICOPENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLogicOpEnableEXT_after(commandBuffer, logicOpEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLogicOpEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, VkBool32* pColorBlendEnables) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetColorBlendEnableEXT!");
}
#ifdef CMDSETCOLORBLENDENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendEnableEXT_before(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstAttachment=" + std::to_string(firstAttachment) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
winsockSendToUI(&ConnectSocket,"pColorBlendEnables=" + ptrToString((void**)std::addressof(pColorBlendEnables)) + '!');
}
#ifdef CMDSETCOLORBLENDENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendEnableEXT_after(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetColorBlendEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, VkColorBlendEquationEXT* pColorBlendEquations) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetColorBlendEquationEXT!");
}
#ifdef CMDSETCOLORBLENDEQUATIONEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendEquationEXT_before(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstAttachment=" + std::to_string(firstAttachment) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
if(pColorBlendEquations != VK_NULL_HANDLE && pColorBlendEquations != NULL) {
}else winsockSendToUI(&ConnectSocket, "pColorBlendEquations=VK_NULL_HANDLE!");
}
#ifdef CMDSETCOLORBLENDEQUATIONEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendEquationEXT_after(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetColorBlendEquationEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, VkColorComponentFlags* pColorWriteMasks) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetColorWriteMaskEXT!");
}
#ifdef CMDSETCOLORWRITEMASKEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetColorWriteMaskEXT_before(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstAttachment=" + std::to_string(firstAttachment) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
winsockSendToUI(&ConnectSocket,"pColorWriteMasks=" + ptrToString((void**)std::addressof(pColorWriteMasks)) + '!');
}
#ifdef CMDSETCOLORWRITEMASKEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetColorWriteMaskEXT_after(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetColorWriteMaskEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRasterizationStreamEXT!");
}
#ifdef CMDSETRASTERIZATIONSTREAMEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizationStreamEXT_before(commandBuffer, rasterizationStream);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"rasterizationStream=" + std::to_string(rasterizationStream) + '!');
}
#ifdef CMDSETRASTERIZATIONSTREAMEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizationStreamEXT_after(commandBuffer, rasterizationStream);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRasterizationStreamEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetConservativeRasterizationModeEXT!");
}
#ifdef CMDSETCONSERVATIVERASTERIZATIONMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetConservativeRasterizationModeEXT_before(commandBuffer, conservativeRasterizationMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETCONSERVATIVERASTERIZATIONMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetConservativeRasterizationModeEXT_after(commandBuffer, conservativeRasterizationMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetConservativeRasterizationModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetExtraPrimitiveOverestimationSizeEXT!");
}
#ifdef CMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetExtraPrimitiveOverestimationSizeEXT_before(commandBuffer, extraPrimitiveOverestimationSize);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"extraPrimitiveOverestimationSize=" + std::to_string(extraPrimitiveOverestimationSize) + '!');
}
#ifdef CMDSETEXTRAPRIMITIVEOVERESTIMATIONSIZEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetExtraPrimitiveOverestimationSizeEXT_after(commandBuffer, extraPrimitiveOverestimationSize);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetExtraPrimitiveOverestimationSizeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthClipEnableEXT!");
}
#ifdef CMDSETDEPTHCLIPENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClipEnableEXT_before(commandBuffer, depthClipEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthClipEnable=" + bool_as_text(depthClipEnable) + '!');
}
#ifdef CMDSETDEPTHCLIPENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClipEnableEXT_after(commandBuffer, depthClipEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthClipEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetSampleLocationsEnableEXT!");
}
#ifdef CMDSETSAMPLELOCATIONSENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleLocationsEnableEXT_before(commandBuffer, sampleLocationsEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"sampleLocationsEnable=" + bool_as_text(sampleLocationsEnable) + '!');
}
#ifdef CMDSETSAMPLELOCATIONSENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetSampleLocationsEnableEXT_after(commandBuffer, sampleLocationsEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetSampleLocationsEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, VkColorBlendAdvancedEXT* pColorBlendAdvanced) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetColorBlendAdvancedEXT!");
}
#ifdef CMDSETCOLORBLENDADVANCEDEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendAdvancedEXT_before(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstAttachment=" + std::to_string(firstAttachment) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
if(pColorBlendAdvanced != VK_NULL_HANDLE && pColorBlendAdvanced != NULL) {
winsockSendToUI(&ConnectSocket,"pColorBlendAdvanced->srcPremultiplied=" + bool_as_text(pColorBlendAdvanced->srcPremultiplied) + '!');
winsockSendToUI(&ConnectSocket,"pColorBlendAdvanced->dstPremultiplied=" + bool_as_text(pColorBlendAdvanced->dstPremultiplied) + '!');
winsockSendToUI(&ConnectSocket,"pColorBlendAdvanced->clampResults=" + bool_as_text(pColorBlendAdvanced->clampResults) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorBlendAdvanced=VK_NULL_HANDLE!");
}
#ifdef CMDSETCOLORBLENDADVANCEDEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetColorBlendAdvancedEXT_after(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetColorBlendAdvancedEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetProvokingVertexModeEXT!");
}
#ifdef CMDSETPROVOKINGVERTEXMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetProvokingVertexModeEXT_before(commandBuffer, provokingVertexMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETPROVOKINGVERTEXMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetProvokingVertexModeEXT_after(commandBuffer, provokingVertexMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetProvokingVertexModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLineRasterizationModeEXT!");
}
#ifdef CMDSETLINERASTERIZATIONMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLineRasterizationModeEXT_before(commandBuffer, lineRasterizationMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"lineRasterizationMode=" + ptrToString((void**)std::addressof(lineRasterizationMode)) + '!');
}
#ifdef CMDSETLINERASTERIZATIONMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLineRasterizationModeEXT_after(commandBuffer, lineRasterizationMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLineRasterizationModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLineStippleEnableEXT!");
}
#ifdef CMDSETLINESTIPPLEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLineStippleEnableEXT_before(commandBuffer, stippledLineEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stippledLineEnable=" + bool_as_text(stippledLineEnable) + '!');
}
#ifdef CMDSETLINESTIPPLEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLineStippleEnableEXT_after(commandBuffer, stippledLineEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLineStippleEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthClipNegativeOneToOneEXT!");
}
#ifdef CMDSETDEPTHCLIPNEGATIVEONETOONEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClipNegativeOneToOneEXT_before(commandBuffer, negativeOneToOne);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"negativeOneToOne=" + bool_as_text(negativeOneToOne) + '!');
}
#ifdef CMDSETDEPTHCLIPNEGATIVEONETOONEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthClipNegativeOneToOneEXT_after(commandBuffer, negativeOneToOne);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthClipNegativeOneToOneEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportWScalingEnableNV!");
}
#ifdef CMDSETVIEWPORTWSCALINGENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWScalingEnableNV_before(commandBuffer, viewportWScalingEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"viewportWScalingEnable=" + bool_as_text(viewportWScalingEnable) + '!');
}
#ifdef CMDSETVIEWPORTWSCALINGENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWScalingEnableNV_after(commandBuffer, viewportWScalingEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportWScalingEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewportSwizzleNV* pViewportSwizzles) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportSwizzleNV!");
}
#ifdef CMDSETVIEWPORTSWIZZLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportSwizzleNV_before(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstViewport=" + std::to_string(firstViewport) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pViewportSwizzles != VK_NULL_HANDLE && pViewportSwizzles != NULL) {
}else winsockSendToUI(&ConnectSocket, "pViewportSwizzles=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORTSWIZZLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportSwizzleNV_after(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportSwizzleNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageToColorEnableNV!");
}
#ifdef CMDSETCOVERAGETOCOLORENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageToColorEnableNV_before(commandBuffer, coverageToColorEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"coverageToColorEnable=" + bool_as_text(coverageToColorEnable) + '!');
}
#ifdef CMDSETCOVERAGETOCOLORENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageToColorEnableNV_after(commandBuffer, coverageToColorEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageToColorEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageToColorLocationNV!");
}
#ifdef CMDSETCOVERAGETOCOLORLOCATIONNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageToColorLocationNV_before(commandBuffer, coverageToColorLocation);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"coverageToColorLocation=" + std::to_string(coverageToColorLocation) + '!');
}
#ifdef CMDSETCOVERAGETOCOLORLOCATIONNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageToColorLocationNV_after(commandBuffer, coverageToColorLocation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageToColorLocationNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageModulationModeNV!");
}
#ifdef CMDSETCOVERAGEMODULATIONMODENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationModeNV_before(commandBuffer, coverageModulationMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETCOVERAGEMODULATIONMODENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationModeNV_after(commandBuffer, coverageModulationMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageModulationModeNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageModulationTableEnableNV!");
}
#ifdef CMDSETCOVERAGEMODULATIONTABLEENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationTableEnableNV_before(commandBuffer, coverageModulationTableEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"coverageModulationTableEnable=" + bool_as_text(coverageModulationTableEnable) + '!');
}
#ifdef CMDSETCOVERAGEMODULATIONTABLEENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationTableEnableNV_after(commandBuffer, coverageModulationTableEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageModulationTableEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, float* pCoverageModulationTable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageModulationTableNV!");
}
#ifdef CMDSETCOVERAGEMODULATIONTABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationTableNV_before(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"coverageModulationTableCount=" + std::to_string(coverageModulationTableCount) + '!');
winsockSendToUI(&ConnectSocket,"pCoverageModulationTable=" + ptrToString((void**)std::addressof(pCoverageModulationTable)) + '!');
}
#ifdef CMDSETCOVERAGEMODULATIONTABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageModulationTableNV_after(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageModulationTableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetShadingRateImageEnableNV!");
}
#ifdef CMDSETSHADINGRATEIMAGEENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetShadingRateImageEnableNV_before(commandBuffer, shadingRateImageEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"shadingRateImageEnable=" + bool_as_text(shadingRateImageEnable) + '!');
}
#ifdef CMDSETSHADINGRATEIMAGEENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetShadingRateImageEnableNV_after(commandBuffer, shadingRateImageEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetShadingRateImageEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCoverageReductionModeNV!");
}
#ifdef CMDSETCOVERAGEREDUCTIONMODENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageReductionModeNV_before(commandBuffer, coverageReductionMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETCOVERAGEREDUCTIONMODENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCoverageReductionModeNV_after(commandBuffer, coverageReductionMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCoverageReductionModeNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRepresentativeFragmentTestEnableNV!");
}
#ifdef CMDSETREPRESENTATIVEFRAGMENTTESTENABLENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRepresentativeFragmentTestEnableNV_before(commandBuffer, representativeFragmentTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"representativeFragmentTestEnable=" + bool_as_text(representativeFragmentTestEnable) + '!');
}
#ifdef CMDSETREPRESENTATIVEFRAGMENTTESTENABLENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRepresentativeFragmentTestEnableNV_after(commandBuffer, representativeFragmentTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRepresentativeFragmentTestEnableNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreatePrivateDataSlot(VkDevice device, VkPrivateDataSlotCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreatePrivateDataSlot!");
}
#ifdef CREATEPRIVATEDATASLOT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreatePrivateDataSlot_before(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPrivateDataSlot=" + ptrToString((void**)std::addressof(pPrivateDataSlot)) + '!');
}
#ifdef CREATEPRIVATEDATASLOT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreatePrivateDataSlot_after(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreatePrivateDataSlot!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyPrivateDataSlot!");
}
#ifdef DESTROYPRIVATEDATASLOT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyPrivateDataSlot_before(device, privateDataSlot, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYPRIVATEDATASLOT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyPrivateDataSlot_after(device, privateDataSlot, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyPrivateDataSlot!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetPrivateData!");
}
#ifdef SETPRIVATEDATA_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetPrivateData_before(device, objectType, objectHandle, privateDataSlot, data);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"objectHandle=" + std::to_string(objectHandle) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
winsockSendToUI(&ConnectSocket,"data=" + std::to_string(data) + '!');
}
#ifdef SETPRIVATEDATA_AFTER_EXEC_EXISTS
if(connected) {
layer_SetPrivateData_after(device, objectType, objectHandle, privateDataSlot, data);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetPrivateData!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPrivateData!");
}
#ifdef GETPRIVATEDATA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPrivateData_before(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif 
device_dispatch[GetKey(device)].GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"objectHandle=" + std::to_string(objectHandle) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
winsockSendToUI(&ConnectSocket,"pData=" + ptrToString((void**)std::addressof(pData)) + '!');
}
#ifdef GETPRIVATEDATA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPrivateData_after(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPrivateData!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBuffer2(VkCommandBuffer commandBuffer, VkCopyBufferInfo2* pCopyBufferInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBuffer2!");
}
#ifdef CMDCOPYBUFFER2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer2_before(commandBuffer, pCopyBufferInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyBufferInfo != VK_NULL_HANDLE && pCopyBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->srcBuffer=" + ptrToString((void**)std::addressof(pCopyBufferInfo->srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->dstBuffer=" + ptrToString((void**)std::addressof(pCopyBufferInfo->dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->regionCount=" + std::to_string(pCopyBufferInfo->regionCount) + '!');
if(pCopyBufferInfo->pRegions != VK_NULL_HANDLE && pCopyBufferInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->srcOffset=" + std::to_string(pCopyBufferInfo->pRegions->srcOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->dstOffset=" + std::to_string(pCopyBufferInfo->pRegions->dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->size=" + std::to_string(pCopyBufferInfo->pRegions->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyBufferInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFER2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer2_after(commandBuffer, pCopyBufferInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBuffer2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImage2(VkCommandBuffer commandBuffer, VkCopyImageInfo2* pCopyImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImage2!");
}
#ifdef CMDCOPYIMAGE2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage2_before(commandBuffer, pCopyImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImage2(commandBuffer, pCopyImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyImageInfo != VK_NULL_HANDLE && pCopyImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->regionCount=" + std::to_string(pCopyImageInfo->regionCount) + '!');
if(pCopyImageInfo->pRegions != VK_NULL_HANDLE && pCopyImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->srcOffset=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->dstOffset=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGE2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage2_after(commandBuffer, pCopyImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImage2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImage2(commandBuffer, pCopyImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBlitImage2(VkCommandBuffer commandBuffer, VkBlitImageInfo2* pBlitImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBlitImage2!");
}
#ifdef CMDBLITIMAGE2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage2_before(commandBuffer, pBlitImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBlitImage2(commandBuffer, pBlitImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBlitImageInfo != VK_NULL_HANDLE && pBlitImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->srcImage=" + ptrToString((void**)std::addressof(pBlitImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->dstImage=" + ptrToString((void**)std::addressof(pBlitImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->regionCount=" + std::to_string(pBlitImageInfo->regionCount) + '!');
if(pBlitImageInfo->pRegions != VK_NULL_HANDLE && pBlitImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->srcOffsets=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->srcOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->dstOffsets=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->dstOffsets)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pBlitImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBLITIMAGE2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage2_after(commandBuffer, pBlitImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBlitImage2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBlitImage2(commandBuffer, pBlitImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBufferToImage2!");
}
#ifdef CMDCOPYBUFFERTOIMAGE2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage2_before(commandBuffer, pCopyBufferToImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyBufferToImageInfo != VK_NULL_HANDLE && pCopyBufferToImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->srcBuffer=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->regionCount=" + std::to_string(pCopyBufferToImageInfo->regionCount) + '!');
if(pCopyBufferToImageInfo->pRegions != VK_NULL_HANDLE && pCopyBufferToImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferOffset=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferRowLength=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferImageHeight=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyBufferToImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFERTOIMAGE2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage2_after(commandBuffer, pCopyBufferToImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBufferToImage2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImageToBuffer2!");
}
#ifdef CMDCOPYIMAGETOBUFFER2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer2_before(commandBuffer, pCopyImageToBufferInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyImageToBufferInfo != VK_NULL_HANDLE && pCopyImageToBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->dstBuffer=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->regionCount=" + std::to_string(pCopyImageToBufferInfo->regionCount) + '!');
if(pCopyImageToBufferInfo->pRegions != VK_NULL_HANDLE && pCopyImageToBufferInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferOffset=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferRowLength=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferImageHeight=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageToBufferInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGETOBUFFER2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer2_after(commandBuffer, pCopyImageToBufferInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImageToBuffer2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResolveImage2(VkCommandBuffer commandBuffer, VkResolveImageInfo2* pResolveImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResolveImage2!");
}
#ifdef CMDRESOLVEIMAGE2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage2_before(commandBuffer, pResolveImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResolveImage2(commandBuffer, pResolveImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pResolveImageInfo != VK_NULL_HANDLE && pResolveImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->srcImage=" + ptrToString((void**)std::addressof(pResolveImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->dstImage=" + ptrToString((void**)std::addressof(pResolveImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->regionCount=" + std::to_string(pResolveImageInfo->regionCount) + '!');
if(pResolveImageInfo->pRegions != VK_NULL_HANDLE && pResolveImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->srcOffset=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->dstOffset=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pResolveImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDRESOLVEIMAGE2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage2_after(commandBuffer, pResolveImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResolveImage2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResolveImage2(commandBuffer, pResolveImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, VkExtent2D* pFragmentSize, VkFragmentShadingRateCombinerOpKHR* combinerOps) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetFragmentShadingRateKHR!");
}
#ifdef CMDSETFRAGMENTSHADINGRATEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetFragmentShadingRateKHR_before(commandBuffer, pFragmentSize, combinerOps);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pFragmentSize != VK_NULL_HANDLE && pFragmentSize != NULL) {
winsockSendToUI(&ConnectSocket,"pFragmentSize->width=" + std::to_string(pFragmentSize->width) + '!');
winsockSendToUI(&ConnectSocket,"pFragmentSize->height=" + std::to_string(pFragmentSize->height) + '!');
}else winsockSendToUI(&ConnectSocket, "pFragmentSize=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"combinerOps=" + ptrToString((void**)std::addressof(combinerOps)) + '!');
}
#ifdef CMDSETFRAGMENTSHADINGRATEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetFragmentShadingRateKHR_after(commandBuffer, pFragmentSize, combinerOps);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetFragmentShadingRateKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, VkFragmentShadingRateCombinerOpKHR* combinerOps) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetFragmentShadingRateEnumNV!");
}
#ifdef CMDSETFRAGMENTSHADINGRATEENUMNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetFragmentShadingRateEnumNV_before(commandBuffer, shadingRate, combinerOps);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"combinerOps=" + ptrToString((void**)std::addressof(combinerOps)) + '!');
}
#ifdef CMDSETFRAGMENTSHADINGRATEENUMNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetFragmentShadingRateEnumNV_after(commandBuffer, shadingRate, combinerOps);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetFragmentShadingRateEnumNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, VkAccelerationStructureBuildGeometryInfoKHR* pBuildInfo, uint32_t* pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR* pSizeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAccelerationStructureBuildSizesKHR!");
}
#ifdef GETACCELERATIONSTRUCTUREBUILDSIZESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureBuildSizesKHR_before(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
#endif 
device_dispatch[GetKey(device)].GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pBuildInfo != VK_NULL_HANDLE && pBuildInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBuildInfo->flags=" + ptrToString((void**)std::addressof(pBuildInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->srcAccelerationStructure=" + ptrToString((void**)std::addressof(pBuildInfo->srcAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->dstAccelerationStructure=" + ptrToString((void**)std::addressof(pBuildInfo->dstAccelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->geometryCount=" + std::to_string(pBuildInfo->geometryCount) + '!');
if(pBuildInfo->pGeometries != VK_NULL_HANDLE && pBuildInfo->pGeometries != NULL) {
winsockSendToUI(&ConnectSocket,"pBuildInfo->pGeometries->geometry=" + ptrToString((void**)std::addressof(pBuildInfo->pGeometries->geometry)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->pGeometries->flags=" + ptrToString((void**)std::addressof(pBuildInfo->pGeometries->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pGeometries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBuildInfo->scratchData=" + ptrToString((void**)std::addressof(pBuildInfo->scratchData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBuildInfo=VK_NULL_HANDLE!");
if(pSizeInfo != VK_NULL_HANDLE && pSizeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSizeInfo->accelerationStructureSize=" + std::to_string(pSizeInfo->accelerationStructureSize) + '!');
winsockSendToUI(&ConnectSocket,"pSizeInfo->updateScratchSize=" + std::to_string(pSizeInfo->updateScratchSize) + '!');
winsockSendToUI(&ConnectSocket,"pSizeInfo->buildScratchSize=" + std::to_string(pSizeInfo->buildScratchSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSizeInfo=VK_NULL_HANDLE!");
}
#ifdef GETACCELERATIONSTRUCTUREBUILDSIZESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureBuildSizesKHR_after(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAccelerationStructureBuildSizesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetVertexInputEXT!");
}
#ifdef CMDSETVERTEXINPUTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetVertexInputEXT_before(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"vertexBindingDescriptionCount=" + std::to_string(vertexBindingDescriptionCount) + '!');
if(pVertexBindingDescriptions != VK_NULL_HANDLE && pVertexBindingDescriptions != NULL) {
winsockSendToUI(&ConnectSocket,"pVertexBindingDescriptions->binding=" + std::to_string(pVertexBindingDescriptions->binding) + '!');
winsockSendToUI(&ConnectSocket,"pVertexBindingDescriptions->stride=" + std::to_string(pVertexBindingDescriptions->stride) + '!');
winsockSendToUI(&ConnectSocket,"pVertexBindingDescriptions->divisor=" + std::to_string(pVertexBindingDescriptions->divisor) + '!');
}else winsockSendToUI(&ConnectSocket, "pVertexBindingDescriptions=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"vertexAttributeDescriptionCount=" + std::to_string(vertexAttributeDescriptionCount) + '!');
if(pVertexAttributeDescriptions != VK_NULL_HANDLE && pVertexAttributeDescriptions != NULL) {
winsockSendToUI(&ConnectSocket,"pVertexAttributeDescriptions->location=" + std::to_string(pVertexAttributeDescriptions->location) + '!');
winsockSendToUI(&ConnectSocket,"pVertexAttributeDescriptions->binding=" + std::to_string(pVertexAttributeDescriptions->binding) + '!');
winsockSendToUI(&ConnectSocket,"pVertexAttributeDescriptions->offset=" + std::to_string(pVertexAttributeDescriptions->offset) + '!');
}else winsockSendToUI(&ConnectSocket, "pVertexAttributeDescriptions=VK_NULL_HANDLE!");
}
#ifdef CMDSETVERTEXINPUTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetVertexInputEXT_after(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetVertexInputEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkBool32* pColorWriteEnables) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetColorWriteEnableEXT!");
}
#ifdef CMDSETCOLORWRITEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetColorWriteEnableEXT_before(commandBuffer, attachmentCount, pColorWriteEnables);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"attachmentCount=" + std::to_string(attachmentCount) + '!');
winsockSendToUI(&ConnectSocket,"pColorWriteEnables=" + ptrToString((void**)std::addressof(pColorWriteEnables)) + '!');
}
#ifdef CMDSETCOLORWRITEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetColorWriteEnableEXT_after(commandBuffer, attachmentCount, pColorWriteEnables);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetColorWriteEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkDependencyInfo* pDependencyInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetEvent2!");
}
#ifdef CMDSETEVENT2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent2_before(commandBuffer, event, pDependencyInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetEvent2(commandBuffer, event, pDependencyInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
if(pDependencyInfo != VK_NULL_HANDLE && pDependencyInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfo->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->memoryBarrierCount=" + std::to_string(pDependencyInfo->memoryBarrierCount) + '!');
if(pDependencyInfo->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfo->bufferMemoryBarrierCount) + '!');
if(pDependencyInfo->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->imageMemoryBarrierCount=" + std::to_string(pDependencyInfo->imageMemoryBarrierCount) + '!');
if(pDependencyInfo->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETEVENT2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent2_after(commandBuffer, event, pDependencyInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetEvent2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResetEvent2!");
}
#ifdef CMDRESETEVENT2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent2_before(commandBuffer, event, stageMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResetEvent2(commandBuffer, event, stageMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
winsockSendToUI(&ConnectSocket,"stageMask=" + ptrToString((void**)std::addressof(stageMask)) + '!');
}
#ifdef CMDRESETEVENT2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent2_after(commandBuffer, event, stageMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResetEvent2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResetEvent2(commandBuffer, event, stageMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkDependencyInfo* pDependencyInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWaitEvents2!");
}
#ifdef CMDWAITEVENTS2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents2_before(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"eventCount=" + std::to_string(eventCount) + '!');
winsockSendToUI(&ConnectSocket,"pEvents=" + ptrToString((void**)std::addressof(pEvents)) + '!');
if(pDependencyInfos != VK_NULL_HANDLE && pDependencyInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfos->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->memoryBarrierCount=" + std::to_string(pDependencyInfos->memoryBarrierCount) + '!');
if(pDependencyInfos->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfos->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfos->bufferMemoryBarrierCount) + '!');
if(pDependencyInfos->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfos->imageMemoryBarrierCount=" + std::to_string(pDependencyInfos->imageMemoryBarrierCount) + '!');
if(pDependencyInfos->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfos->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfos->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfos=VK_NULL_HANDLE!");
}
#ifdef CMDWAITEVENTS2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents2_after(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWaitEvents2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPipelineBarrier2(VkCommandBuffer commandBuffer, VkDependencyInfo* pDependencyInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPipelineBarrier2!");
}
#ifdef CMDPIPELINEBARRIER2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier2_before(commandBuffer, pDependencyInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier2(commandBuffer, pDependencyInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pDependencyInfo != VK_NULL_HANDLE && pDependencyInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfo->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->memoryBarrierCount=" + std::to_string(pDependencyInfo->memoryBarrierCount) + '!');
if(pDependencyInfo->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfo->bufferMemoryBarrierCount) + '!');
if(pDependencyInfo->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->imageMemoryBarrierCount=" + std::to_string(pDependencyInfo->imageMemoryBarrierCount) + '!');
if(pDependencyInfo->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPIPELINEBARRIER2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier2_after(commandBuffer, pDependencyInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPipelineBarrier2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueSubmit2(VkQueue queue, uint32_t submitCount, VkSubmitInfo2* pSubmits, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueSubmit2!");
}
#ifdef QUEUESUBMIT2_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueSubmit2_before(queue, submitCount, pSubmits, fence);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueSubmit2(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"submitCount=" + std::to_string(submitCount) + '!');
if(pSubmits != VK_NULL_HANDLE && pSubmits != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->flags=" + ptrToString((void**)std::addressof(pSubmits->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->waitSemaphoreInfoCount=" + std::to_string(pSubmits->waitSemaphoreInfoCount) + '!');
if(pSubmits->pWaitSemaphoreInfos != VK_NULL_HANDLE && pSubmits->pWaitSemaphoreInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->semaphore=" + ptrToString((void**)std::addressof(pSubmits->pWaitSemaphoreInfos->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->value=" + std::to_string(pSubmits->pWaitSemaphoreInfos->value) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->stageMask=" + ptrToString((void**)std::addressof(pSubmits->pWaitSemaphoreInfos->stageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->deviceIndex=" + std::to_string(pSubmits->pWaitSemaphoreInfos->deviceIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pWaitSemaphoreInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSubmits->commandBufferInfoCount=" + std::to_string(pSubmits->commandBufferInfoCount) + '!');
if(pSubmits->pCommandBufferInfos != VK_NULL_HANDLE && pSubmits->pCommandBufferInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pCommandBufferInfos->commandBuffer=" + ptrToString((void**)std::addressof(pSubmits->pCommandBufferInfos->commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pCommandBufferInfos->deviceMask=" + std::to_string(pSubmits->pCommandBufferInfos->deviceMask) + '!');
}else winsockSendToUI(&ConnectSocket, "pCommandBufferInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSubmits->signalSemaphoreInfoCount=" + std::to_string(pSubmits->signalSemaphoreInfoCount) + '!');
if(pSubmits->pSignalSemaphoreInfos != VK_NULL_HANDLE && pSubmits->pSignalSemaphoreInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->semaphore=" + ptrToString((void**)std::addressof(pSubmits->pSignalSemaphoreInfos->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->value=" + std::to_string(pSubmits->pSignalSemaphoreInfos->value) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->stageMask=" + ptrToString((void**)std::addressof(pSubmits->pSignalSemaphoreInfos->stageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->deviceIndex=" + std::to_string(pSubmits->pSignalSemaphoreInfos->deviceIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pSignalSemaphoreInfos=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pSubmits=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef QUEUESUBMIT2_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueSubmit2_after(queue, submitCount, pSubmits, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueSubmit2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueSubmit2(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteTimestamp2!");
}
#ifdef CMDWRITETIMESTAMP2_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp2_before(commandBuffer, stage, queryPool, query);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stage=" + ptrToString((void**)std::addressof(stage)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
}
#ifdef CMDWRITETIMESTAMP2_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp2_after(commandBuffer, stage, queryPool, query);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteTimestamp2!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteBufferMarker2AMD!");
}
#ifdef CMDWRITEBUFFERMARKER2AMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteBufferMarker2AMD_before(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stage=" + ptrToString((void**)std::addressof(stage)) + '!');
winsockSendToUI(&ConnectSocket,"dstBuffer=" + ptrToString((void**)std::addressof(dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"dstOffset=" + std::to_string(dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"marker=" + std::to_string(marker) + '!');
}
#ifdef CMDWRITEBUFFERMARKER2AMD_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteBufferMarker2AMD_after(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteBufferMarker2AMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetQueueCheckpointData2NV(VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetQueueCheckpointData2NV!");
}
#ifdef GETQUEUECHECKPOINTDATA2NV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetQueueCheckpointData2NV_before(queue, pCheckpointDataCount, pCheckpointData);
}
#endif 
device_dispatch[GetKey(queue)].GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pCheckpointData != VK_NULL_HANDLE && pCheckpointData != NULL) {
winsockSendToUI(&ConnectSocket,"pCheckpointData->stage=" + ptrToString((void**)std::addressof(pCheckpointData->stage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCheckpointData=VK_NULL_HANDLE!");
}
#ifdef GETQUEUECHECKPOINTDATA2NV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetQueueCheckpointData2NV_after(queue, pCheckpointDataCount, pCheckpointData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetQueueCheckpointData2NV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].GetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyMemoryToImageEXT(VkDevice device, VkCopyMemoryToImageInfoEXT* pCopyMemoryToImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyMemoryToImageEXT!");
}
#ifdef COPYMEMORYTOIMAGEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToImageEXT_before(device, pCopyMemoryToImageInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCopyMemoryToImageInfo != VK_NULL_HANDLE && pCopyMemoryToImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->flags=" + ptrToString((void**)std::addressof(pCopyMemoryToImageInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyMemoryToImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->regionCount=" + std::to_string(pCopyMemoryToImageInfo->regionCount) + '!');
if(pCopyMemoryToImageInfo->pRegions != VK_NULL_HANDLE && pCopyMemoryToImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->pRegions->memoryRowLength=" + std::to_string(pCopyMemoryToImageInfo->pRegions->memoryRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->pRegions->memoryImageHeight=" + std::to_string(pCopyMemoryToImageInfo->pRegions->memoryImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyMemoryToImageInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyMemoryToImageInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyMemoryToImageInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyMemoryToImageInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyMemoryToImageInfo=VK_NULL_HANDLE!");
}
#ifdef COPYMEMORYTOIMAGEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToImageEXT_after(device, pCopyMemoryToImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyMemoryToImageEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyMemoryToImageEXT(device, pCopyMemoryToImageInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyImageToMemoryEXT(VkDevice device, VkCopyImageToMemoryInfoEXT* pCopyImageToMemoryInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyImageToMemoryEXT!");
}
#ifdef COPYIMAGETOMEMORYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyImageToMemoryEXT_before(device, pCopyImageToMemoryInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCopyImageToMemoryInfo != VK_NULL_HANDLE && pCopyImageToMemoryInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->flags=" + ptrToString((void**)std::addressof(pCopyImageToMemoryInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageToMemoryInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->regionCount=" + std::to_string(pCopyImageToMemoryInfo->regionCount) + '!');
if(pCopyImageToMemoryInfo->pRegions != VK_NULL_HANDLE && pCopyImageToMemoryInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->pRegions->memoryRowLength=" + std::to_string(pCopyImageToMemoryInfo->pRegions->memoryRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->pRegions->memoryImageHeight=" + std::to_string(pCopyImageToMemoryInfo->pRegions->memoryImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyImageToMemoryInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyImageToMemoryInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToMemoryInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyImageToMemoryInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageToMemoryInfo=VK_NULL_HANDLE!");
}
#ifdef COPYIMAGETOMEMORYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyImageToMemoryEXT_after(device, pCopyImageToMemoryInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyImageToMemoryEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyImageToMemoryEXT(device, pCopyImageToMemoryInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyImageToImageEXT(VkDevice device, VkCopyImageToImageInfoEXT* pCopyImageToImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyImageToImageEXT!");
}
#ifdef COPYIMAGETOIMAGEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyImageToImageEXT_before(device, pCopyImageToImageInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyImageToImageEXT(device, pCopyImageToImageInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCopyImageToImageInfo != VK_NULL_HANDLE && pCopyImageToImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->flags=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->regionCount=" + std::to_string(pCopyImageToImageInfo->regionCount) + '!');
if(pCopyImageToImageInfo->pRegions != VK_NULL_HANDLE && pCopyImageToImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->pRegions->srcOffset=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->pRegions->dstOffset=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToImageInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pCopyImageToImageInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageToImageInfo=VK_NULL_HANDLE!");
}
#ifdef COPYIMAGETOIMAGEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyImageToImageEXT_after(device, pCopyImageToImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyImageToImageEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyImageToImageEXT(device, pCopyImageToImageInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, VkHostImageLayoutTransitionInfoEXT* pTransitions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkTransitionImageLayoutEXT!");
}
#ifdef TRANSITIONIMAGELAYOUTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_TransitionImageLayoutEXT_before(device, transitionCount, pTransitions);
}
#endif 
auto ret = device_dispatch[GetKey(device)].TransitionImageLayoutEXT(device, transitionCount, pTransitions);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"transitionCount=" + std::to_string(transitionCount) + '!');
if(pTransitions != VK_NULL_HANDLE && pTransitions != NULL) {
winsockSendToUI(&ConnectSocket,"pTransitions->image=" + ptrToString((void**)std::addressof(pTransitions->image)) + '!');
winsockSendToUI(&ConnectSocket,"pTransitions->subresourceRange=" + ptrToString((void**)std::addressof(pTransitions->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pTransitions=VK_NULL_HANDLE!");
}
#ifdef TRANSITIONIMAGELAYOUTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_TransitionImageLayoutEXT_after(device, transitionCount, pTransitions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkTransitionImageLayoutEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].TransitionImageLayoutEXT(device, transitionCount, pTransitions);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateVideoSessionKHR(VkDevice device, VkVideoSessionCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkVideoSessionKHR* pVideoSession) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateVideoSessionKHR!");
}
#ifdef CREATEVIDEOSESSIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateVideoSessionKHR_before(device, pCreateInfo, pAllocator, pVideoSession);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->queueFamilyIndex=" + std::to_string(pCreateInfo->queueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
if(pCreateInfo->pVideoProfile != VK_NULL_HANDLE && pCreateInfo->pVideoProfile != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pVideoProfile->chromaSubsampling=" + ptrToString((void**)std::addressof(pCreateInfo->pVideoProfile->chromaSubsampling)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pVideoProfile->lumaBitDepth=" + ptrToString((void**)std::addressof(pCreateInfo->pVideoProfile->lumaBitDepth)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pVideoProfile->chromaBitDepth=" + ptrToString((void**)std::addressof(pCreateInfo->pVideoProfile->chromaBitDepth)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoProfile=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxCodedExtent=" + ptrToString((void**)std::addressof(pCreateInfo->maxCodedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxDpbSlots=" + std::to_string(pCreateInfo->maxDpbSlots) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->maxActiveReferencePictures=" + std::to_string(pCreateInfo->maxActiveReferencePictures) + '!');
if(pCreateInfo->pStdHeaderVersion != VK_NULL_HANDLE && pCreateInfo->pStdHeaderVersion != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pStdHeaderVersion->specVersion=" + std::to_string(pCreateInfo->pStdHeaderVersion->specVersion) + '!');
}else winsockSendToUI(&ConnectSocket, "pStdHeaderVersion=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pVideoSession=" + ptrToString((void**)std::addressof(pVideoSession)) + '!');
}
#ifdef CREATEVIDEOSESSIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateVideoSessionKHR_after(device, pCreateInfo, pAllocator, pVideoSession);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateVideoSessionKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyVideoSessionKHR!");
}
#ifdef DESTROYVIDEOSESSIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyVideoSessionKHR_before(device, videoSession, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyVideoSessionKHR(device, videoSession, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"videoSession=" + ptrToString((void**)std::addressof(videoSession)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYVIDEOSESSIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyVideoSessionKHR_after(device, videoSession, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyVideoSessionKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyVideoSessionKHR(device, videoSession, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersCreateInfoKHR* pCreateInfo, VkAllocationCallbacks* pAllocator, VkVideoSessionParametersKHR* pVideoSessionParameters) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateVideoSessionParametersKHR!");
}
#ifdef CREATEVIDEOSESSIONPARAMETERSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateVideoSessionParametersKHR_before(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->videoSessionParametersTemplate=" + ptrToString((void**)std::addressof(pCreateInfo->videoSessionParametersTemplate)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->videoSession=" + ptrToString((void**)std::addressof(pCreateInfo->videoSession)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pVideoSessionParameters=" + ptrToString((void**)std::addressof(pVideoSessionParameters)) + '!');
}
#ifdef CREATEVIDEOSESSIONPARAMETERSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateVideoSessionParametersKHR_after(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateVideoSessionParametersKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, VkVideoSessionParametersUpdateInfoKHR* pUpdateInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUpdateVideoSessionParametersKHR!");
}
#ifdef UPDATEVIDEOSESSIONPARAMETERSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_UpdateVideoSessionParametersKHR_before(device, videoSessionParameters, pUpdateInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"videoSessionParameters=" + ptrToString((void**)std::addressof(videoSessionParameters)) + '!');
if(pUpdateInfo != VK_NULL_HANDLE && pUpdateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pUpdateInfo->updateSequenceCount=" + std::to_string(pUpdateInfo->updateSequenceCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pUpdateInfo=VK_NULL_HANDLE!");
}
#ifdef UPDATEVIDEOSESSIONPARAMETERSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_UpdateVideoSessionParametersKHR_after(device, videoSessionParameters, pUpdateInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUpdateVideoSessionParametersKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].UpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetEncodedVideoSessionParametersKHR(VkDevice device, VkVideoEncodeSessionParametersGetInfoKHR* pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, size_t* pDataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetEncodedVideoSessionParametersKHR!");
}
#ifdef GETENCODEDVIDEOSESSIONPARAMETERSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetEncodedVideoSessionParametersKHR_before(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pVideoSessionParametersInfo != VK_NULL_HANDLE && pVideoSessionParametersInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pVideoSessionParametersInfo->videoSessionParameters=" + ptrToString((void**)std::addressof(pVideoSessionParametersInfo->videoSessionParameters)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVideoSessionParametersInfo=VK_NULL_HANDLE!");
if(pFeedbackInfo != VK_NULL_HANDLE && pFeedbackInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pFeedbackInfo->hasOverrides=" + bool_as_text(pFeedbackInfo->hasOverrides) + '!');
}else winsockSendToUI(&ConnectSocket, "pFeedbackInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDataSize=" + ptrToString((void**)std::addressof(pDataSize)) + '!');
}
#ifdef GETENCODEDVIDEOSESSIONPARAMETERSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetEncodedVideoSessionParametersKHR_after(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetEncodedVideoSessionParametersKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyVideoSessionParametersKHR!");
}
#ifdef DESTROYVIDEOSESSIONPARAMETERSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyVideoSessionParametersKHR_before(device, videoSessionParameters, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"videoSessionParameters=" + ptrToString((void**)std::addressof(videoSessionParameters)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYVIDEOSESSIONPARAMETERSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyVideoSessionParametersKHR_after(device, videoSessionParameters, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyVideoSessionParametersKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t* pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetVideoSessionMemoryRequirementsKHR!");
}
#ifdef GETVIDEOSESSIONMEMORYREQUIREMENTSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetVideoSessionMemoryRequirementsKHR_before(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"videoSession=" + ptrToString((void**)std::addressof(videoSession)) + '!');
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryBindIndex=" + std::to_string(pMemoryRequirements->memoryBindIndex) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETVIDEOSESSIONMEMORYREQUIREMENTSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetVideoSessionMemoryRequirementsKHR_after(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetVideoSessionMemoryRequirementsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindVideoSessionMemoryKHR!");
}
#ifdef BINDVIDEOSESSIONMEMORYKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindVideoSessionMemoryKHR_before(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"videoSession=" + ptrToString((void**)std::addressof(videoSession)) + '!');
winsockSendToUI(&ConnectSocket,"bindSessionMemoryInfoCount=" + std::to_string(bindSessionMemoryInfoCount) + '!');
if(pBindSessionMemoryInfos != VK_NULL_HANDLE && pBindSessionMemoryInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindSessionMemoryInfos->memoryBindIndex=" + std::to_string(pBindSessionMemoryInfos->memoryBindIndex) + '!');
winsockSendToUI(&ConnectSocket,"pBindSessionMemoryInfos->memory=" + ptrToString((void**)std::addressof(pBindSessionMemoryInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindSessionMemoryInfos->memoryOffset=" + std::to_string(pBindSessionMemoryInfos->memoryOffset) + '!');
winsockSendToUI(&ConnectSocket,"pBindSessionMemoryInfos->memorySize=" + std::to_string(pBindSessionMemoryInfos->memorySize) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindSessionMemoryInfos=VK_NULL_HANDLE!");
}
#ifdef BINDVIDEOSESSIONMEMORYKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_BindVideoSessionMemoryKHR_after(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindVideoSessionMemoryKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, VkVideoDecodeInfoKHR* pDecodeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDecodeVideoKHR!");
}
#ifdef CMDDECODEVIDEOKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDecodeVideoKHR_before(commandBuffer, pDecodeInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pDecodeInfo != VK_NULL_HANDLE && pDecodeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDecodeInfo->flags=" + ptrToString((void**)std::addressof(pDecodeInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->srcBuffer=" + ptrToString((void**)std::addressof(pDecodeInfo->srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->srcBufferOffset=" + std::to_string(pDecodeInfo->srcBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->srcBufferRange=" + std::to_string(pDecodeInfo->srcBufferRange) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->dstPictureResource=" + ptrToString((void**)std::addressof(pDecodeInfo->dstPictureResource)) + '!');
if(pDecodeInfo->pSetupReferenceSlot != VK_NULL_HANDLE && pDecodeInfo->pSetupReferenceSlot != NULL) {
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pSetupReferenceSlot->slotIndex=" + std::to_string(pDecodeInfo->pSetupReferenceSlot->slotIndex) + '!');
if(pDecodeInfo->pSetupReferenceSlot->pPictureResource != VK_NULL_HANDLE && pDecodeInfo->pSetupReferenceSlot->pPictureResource != NULL) {
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pSetupReferenceSlot->pPictureResource->codedOffset=" + ptrToString((void**)std::addressof(pDecodeInfo->pSetupReferenceSlot->pPictureResource->codedOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pSetupReferenceSlot->pPictureResource->codedExtent=" + ptrToString((void**)std::addressof(pDecodeInfo->pSetupReferenceSlot->pPictureResource->codedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pSetupReferenceSlot->pPictureResource->baseArrayLayer=" + std::to_string(pDecodeInfo->pSetupReferenceSlot->pPictureResource->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding=" + ptrToString((void**)std::addressof(pDecodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPictureResource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pSetupReferenceSlot=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDecodeInfo->referenceSlotCount=" + std::to_string(pDecodeInfo->referenceSlotCount) + '!');
if(pDecodeInfo->pReferenceSlots != VK_NULL_HANDLE && pDecodeInfo->pReferenceSlots != NULL) {
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pReferenceSlots->slotIndex=" + std::to_string(pDecodeInfo->pReferenceSlots->slotIndex) + '!');
if(pDecodeInfo->pReferenceSlots->pPictureResource != VK_NULL_HANDLE && pDecodeInfo->pReferenceSlots->pPictureResource != NULL) {
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pReferenceSlots->pPictureResource->codedOffset=" + ptrToString((void**)std::addressof(pDecodeInfo->pReferenceSlots->pPictureResource->codedOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pReferenceSlots->pPictureResource->codedExtent=" + ptrToString((void**)std::addressof(pDecodeInfo->pReferenceSlots->pPictureResource->codedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pReferenceSlots->pPictureResource->baseArrayLayer=" + std::to_string(pDecodeInfo->pReferenceSlots->pPictureResource->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pDecodeInfo->pReferenceSlots->pPictureResource->imageViewBinding=" + ptrToString((void**)std::addressof(pDecodeInfo->pReferenceSlots->pPictureResource->imageViewBinding)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPictureResource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pReferenceSlots=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDecodeInfo=VK_NULL_HANDLE!");
}
#ifdef CMDDECODEVIDEOKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDecodeVideoKHR_after(commandBuffer, pDecodeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDecodeVideoKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoBeginCodingInfoKHR* pBeginInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginVideoCodingKHR!");
}
#ifdef CMDBEGINVIDEOCODINGKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginVideoCodingKHR_before(commandBuffer, pBeginInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBeginInfo != VK_NULL_HANDLE && pBeginInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBeginInfo->flags=" + ptrToString((void**)std::addressof(pBeginInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->videoSession=" + ptrToString((void**)std::addressof(pBeginInfo->videoSession)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->videoSessionParameters=" + ptrToString((void**)std::addressof(pBeginInfo->videoSessionParameters)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->referenceSlotCount=" + std::to_string(pBeginInfo->referenceSlotCount) + '!');
if(pBeginInfo->pReferenceSlots != VK_NULL_HANDLE && pBeginInfo->pReferenceSlots != NULL) {
winsockSendToUI(&ConnectSocket,"pBeginInfo->pReferenceSlots->slotIndex=" + std::to_string(pBeginInfo->pReferenceSlots->slotIndex) + '!');
if(pBeginInfo->pReferenceSlots->pPictureResource != VK_NULL_HANDLE && pBeginInfo->pReferenceSlots->pPictureResource != NULL) {
winsockSendToUI(&ConnectSocket,"pBeginInfo->pReferenceSlots->pPictureResource->codedOffset=" + ptrToString((void**)std::addressof(pBeginInfo->pReferenceSlots->pPictureResource->codedOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pReferenceSlots->pPictureResource->codedExtent=" + ptrToString((void**)std::addressof(pBeginInfo->pReferenceSlots->pPictureResource->codedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pReferenceSlots->pPictureResource->baseArrayLayer=" + std::to_string(pBeginInfo->pReferenceSlots->pPictureResource->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pBeginInfo->pReferenceSlots->pPictureResource->imageViewBinding=" + ptrToString((void**)std::addressof(pBeginInfo->pReferenceSlots->pPictureResource->imageViewBinding)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPictureResource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pReferenceSlots=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pBeginInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINVIDEOCODINGKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginVideoCodingKHR_after(commandBuffer, pBeginInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginVideoCodingKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoCodingControlInfoKHR* pCodingControlInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdControlVideoCodingKHR!");
}
#ifdef CMDCONTROLVIDEOCODINGKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdControlVideoCodingKHR_before(commandBuffer, pCodingControlInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCodingControlInfo != VK_NULL_HANDLE && pCodingControlInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCodingControlInfo->flags=" + ptrToString((void**)std::addressof(pCodingControlInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCodingControlInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCONTROLVIDEOCODINGKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdControlVideoCodingKHR_after(commandBuffer, pCodingControlInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdControlVideoCodingKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, VkVideoEndCodingInfoKHR* pEndCodingInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndVideoCodingKHR!");
}
#ifdef CMDENDVIDEOCODINGKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndVideoCodingKHR_before(commandBuffer, pEndCodingInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pEndCodingInfo != VK_NULL_HANDLE && pEndCodingInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pEndCodingInfo->flags=" + ptrToString((void**)std::addressof(pEndCodingInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pEndCodingInfo=VK_NULL_HANDLE!");
}
#ifdef CMDENDVIDEOCODINGKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndVideoCodingKHR_after(commandBuffer, pEndCodingInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndVideoCodingKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, VkVideoEncodeInfoKHR* pEncodeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEncodeVideoKHR!");
}
#ifdef CMDENCODEVIDEOKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEncodeVideoKHR_before(commandBuffer, pEncodeInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pEncodeInfo != VK_NULL_HANDLE && pEncodeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pEncodeInfo->flags=" + ptrToString((void**)std::addressof(pEncodeInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->dstBuffer=" + ptrToString((void**)std::addressof(pEncodeInfo->dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->dstBufferOffset=" + std::to_string(pEncodeInfo->dstBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->dstBufferRange=" + std::to_string(pEncodeInfo->dstBufferRange) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->srcPictureResource=" + ptrToString((void**)std::addressof(pEncodeInfo->srcPictureResource)) + '!');
if(pEncodeInfo->pSetupReferenceSlot != VK_NULL_HANDLE && pEncodeInfo->pSetupReferenceSlot != NULL) {
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pSetupReferenceSlot->slotIndex=" + std::to_string(pEncodeInfo->pSetupReferenceSlot->slotIndex) + '!');
if(pEncodeInfo->pSetupReferenceSlot->pPictureResource != VK_NULL_HANDLE && pEncodeInfo->pSetupReferenceSlot->pPictureResource != NULL) {
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pSetupReferenceSlot->pPictureResource->codedOffset=" + ptrToString((void**)std::addressof(pEncodeInfo->pSetupReferenceSlot->pPictureResource->codedOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pSetupReferenceSlot->pPictureResource->codedExtent=" + ptrToString((void**)std::addressof(pEncodeInfo->pSetupReferenceSlot->pPictureResource->codedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pSetupReferenceSlot->pPictureResource->baseArrayLayer=" + std::to_string(pEncodeInfo->pSetupReferenceSlot->pPictureResource->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding=" + ptrToString((void**)std::addressof(pEncodeInfo->pSetupReferenceSlot->pPictureResource->imageViewBinding)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPictureResource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pSetupReferenceSlot=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pEncodeInfo->referenceSlotCount=" + std::to_string(pEncodeInfo->referenceSlotCount) + '!');
if(pEncodeInfo->pReferenceSlots != VK_NULL_HANDLE && pEncodeInfo->pReferenceSlots != NULL) {
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pReferenceSlots->slotIndex=" + std::to_string(pEncodeInfo->pReferenceSlots->slotIndex) + '!');
if(pEncodeInfo->pReferenceSlots->pPictureResource != VK_NULL_HANDLE && pEncodeInfo->pReferenceSlots->pPictureResource != NULL) {
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pReferenceSlots->pPictureResource->codedOffset=" + ptrToString((void**)std::addressof(pEncodeInfo->pReferenceSlots->pPictureResource->codedOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pReferenceSlots->pPictureResource->codedExtent=" + ptrToString((void**)std::addressof(pEncodeInfo->pReferenceSlots->pPictureResource->codedExtent)) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pReferenceSlots->pPictureResource->baseArrayLayer=" + std::to_string(pEncodeInfo->pReferenceSlots->pPictureResource->baseArrayLayer) + '!');
winsockSendToUI(&ConnectSocket,"pEncodeInfo->pReferenceSlots->pPictureResource->imageViewBinding=" + ptrToString((void**)std::addressof(pEncodeInfo->pReferenceSlots->pPictureResource->imageViewBinding)) + '!');
}else winsockSendToUI(&ConnectSocket, "pPictureResource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pReferenceSlots=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pEncodeInfo->precedingExternallyEncodedBytes=" + std::to_string(pEncodeInfo->precedingExternallyEncodedBytes) + '!');
}else winsockSendToUI(&ConnectSocket, "pEncodeInfo=VK_NULL_HANDLE!");
}
#ifdef CMDENCODEVIDEOKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEncodeVideoKHR_after(commandBuffer, pEncodeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEncodeVideoKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, VkDecompressMemoryRegionNV* pDecompressMemoryRegions) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDecompressMemoryNV!");
}
#ifdef CMDDECOMPRESSMEMORYNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDecompressMemoryNV_before(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"decompressRegionCount=" + std::to_string(decompressRegionCount) + '!');
if(pDecompressMemoryRegions != VK_NULL_HANDLE && pDecompressMemoryRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pDecompressMemoryRegions->srcAddress=" + ptrToString((void**)std::addressof(pDecompressMemoryRegions->srcAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pDecompressMemoryRegions->dstAddress=" + ptrToString((void**)std::addressof(pDecompressMemoryRegions->dstAddress)) + '!');
winsockSendToUI(&ConnectSocket,"pDecompressMemoryRegions->compressedSize=" + std::to_string(pDecompressMemoryRegions->compressedSize) + '!');
winsockSendToUI(&ConnectSocket,"pDecompressMemoryRegions->decompressedSize=" + std::to_string(pDecompressMemoryRegions->decompressedSize) + '!');
winsockSendToUI(&ConnectSocket,"pDecompressMemoryRegions->decompressionMethod=" + ptrToString((void**)std::addressof(pDecompressMemoryRegions->decompressionMethod)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDecompressMemoryRegions=VK_NULL_HANDLE!");
}
#ifdef CMDDECOMPRESSMEMORYNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDecompressMemoryNV_after(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDecompressMemoryNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDecompressMemoryIndirectCountNV!");
}
#ifdef CMDDECOMPRESSMEMORYINDIRECTCOUNTNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDecompressMemoryIndirectCountNV_before(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"indirectCommandsAddress=" + ptrToString((void**)std::addressof(indirectCommandsAddress)) + '!');
winsockSendToUI(&ConnectSocket,"indirectCommandsCountAddress=" + ptrToString((void**)std::addressof(indirectCommandsCountAddress)) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDECOMPRESSMEMORYINDIRECTCOUNTNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDecompressMemoryIndirectCountNV_after(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDecompressMemoryIndirectCountNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateCuModuleNVX(VkDevice device, VkCuModuleCreateInfoNVX* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCuModuleNVX* pModule) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateCuModuleNVX!");
}
#ifdef CREATECUMODULENVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateCuModuleNVX_before(device, pCreateInfo, pAllocator, pModule);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->dataSize=" + std::to_string(pCreateInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pModule=" + ptrToString((void**)std::addressof(pModule)) + '!');
}
#ifdef CREATECUMODULENVX_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateCuModuleNVX_after(device, pCreateInfo, pAllocator, pModule);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateCuModuleNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateCuFunctionNVX(VkDevice device, VkCuFunctionCreateInfoNVX* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCuFunctionNVX* pFunction) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateCuFunctionNVX!");
}
#ifdef CREATECUFUNCTIONNVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateCuFunctionNVX_before(device, pCreateInfo, pAllocator, pFunction);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->module=" + ptrToString((void**)std::addressof(pCreateInfo->module)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFunction=" + ptrToString((void**)std::addressof(pFunction)) + '!');
}
#ifdef CREATECUFUNCTIONNVX_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateCuFunctionNVX_after(device, pCreateInfo, pAllocator, pFunction);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateCuFunctionNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyCuModuleNVX!");
}
#ifdef DESTROYCUMODULENVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyCuModuleNVX_before(device, module, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyCuModuleNVX(device, module, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"module=" + ptrToString((void**)std::addressof(module)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYCUMODULENVX_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyCuModuleNVX_after(device, module, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyCuModuleNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyCuModuleNVX(device, module, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyCuFunctionNVX!");
}
#ifdef DESTROYCUFUNCTIONNVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyCuFunctionNVX_before(device, function, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyCuFunctionNVX(device, function, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"function=" + ptrToString((void**)std::addressof(function)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYCUFUNCTIONNVX_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyCuFunctionNVX_after(device, function, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyCuFunctionNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyCuFunctionNVX(device, function, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, VkCuLaunchInfoNVX* pLaunchInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCuLaunchKernelNVX!");
}
#ifdef CMDCULAUNCHKERNELNVX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCuLaunchKernelNVX_before(commandBuffer, pLaunchInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pLaunchInfo != VK_NULL_HANDLE && pLaunchInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pLaunchInfo->function=" + ptrToString((void**)std::addressof(pLaunchInfo->function)) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimX=" + std::to_string(pLaunchInfo->gridDimX) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimY=" + std::to_string(pLaunchInfo->gridDimY) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimZ=" + std::to_string(pLaunchInfo->gridDimZ) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimX=" + std::to_string(pLaunchInfo->blockDimX) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimY=" + std::to_string(pLaunchInfo->blockDimY) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimZ=" + std::to_string(pLaunchInfo->blockDimZ) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->sharedMemBytes=" + std::to_string(pLaunchInfo->sharedMemBytes) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->paramCount=" + std::to_string(pLaunchInfo->paramCount) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->extraCount=" + std::to_string(pLaunchInfo->extraCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pLaunchInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCULAUNCHKERNELNVX_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCuLaunchKernelNVX_after(commandBuffer, pLaunchInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCuLaunchKernelNVX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize* pLayoutSizeInBytes) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetLayoutSizeEXT!");
}
#ifdef GETDESCRIPTORSETLAYOUTSIZEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSizeEXT_before(device, layout, pLayoutSizeInBytes);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"pLayoutSizeInBytes=" + ptrToString((void**)std::addressof(pLayoutSizeInBytes)) + '!');
}
#ifdef GETDESCRIPTORSETLAYOUTSIZEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSizeEXT_after(device, layout, pLayoutSizeInBytes);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetLayoutSizeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize* pOffset) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetLayoutBindingOffsetEXT!");
}
#ifdef GETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutBindingOffsetEXT_before(device, layout, binding, pOffset);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"binding=" + std::to_string(binding) + '!');
winsockSendToUI(&ConnectSocket,"pOffset=" + ptrToString((void**)std::addressof(pOffset)) + '!');
}
#ifdef GETDESCRIPTORSETLAYOUTBINDINGOFFSETEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutBindingOffsetEXT_after(device, layout, binding, pOffset);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetLayoutBindingOffsetEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorEXT(VkDevice device, VkDescriptorGetInfoEXT* pDescriptorInfo, size_t dataSize, void* pDescriptor) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorEXT!");
}
#ifdef GETDESCRIPTOREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorEXT_before(device, pDescriptorInfo, dataSize, pDescriptor);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pDescriptorInfo != VK_NULL_HANDLE && pDescriptorInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDescriptorInfo->data=" + ptrToString((void**)std::addressof(pDescriptorInfo->data)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef GETDESCRIPTOREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorEXT_after(device, pDescriptorInfo, dataSize, pDescriptor);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, VkDescriptorBufferBindingInfoEXT* pBindingInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindDescriptorBuffersEXT!");
}
#ifdef CMDBINDDESCRIPTORBUFFERSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBuffersEXT_before(commandBuffer, bufferCount, pBindingInfos);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"bufferCount=" + std::to_string(bufferCount) + '!');
if(pBindingInfos != VK_NULL_HANDLE && pBindingInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindingInfos->address=" + ptrToString((void**)std::addressof(pBindingInfos->address)) + '!');
winsockSendToUI(&ConnectSocket,"pBindingInfos->usage=" + ptrToString((void**)std::addressof(pBindingInfos->usage)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindingInfos=VK_NULL_HANDLE!");
}
#ifdef CMDBINDDESCRIPTORBUFFERSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBuffersEXT_after(commandBuffer, bufferCount, pBindingInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindDescriptorBuffersEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, uint32_t* pBufferIndices, VkDeviceSize* pOffsets) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDescriptorBufferOffsetsEXT!");
}
#ifdef CMDSETDESCRIPTORBUFFEROFFSETSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDescriptorBufferOffsetsEXT_before(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"firstSet=" + std::to_string(firstSet) + '!');
winsockSendToUI(&ConnectSocket,"setCount=" + std::to_string(setCount) + '!');
winsockSendToUI(&ConnectSocket,"pOffsets=" + ptrToString((void**)std::addressof(pOffsets)) + '!');
}
#ifdef CMDSETDESCRIPTORBUFFEROFFSETSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDescriptorBufferOffsetsEXT_after(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDescriptorBufferOffsetsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindDescriptorBufferEmbeddedSamplersEXT!");
}
#ifdef CMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBufferEmbeddedSamplersEXT_before(commandBuffer, pipelineBindPoint, layout, set);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"layout=" + ptrToString((void**)std::addressof(layout)) + '!');
winsockSendToUI(&ConnectSocket,"set=" + std::to_string(set) + '!');
}
#ifdef CMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBufferEmbeddedSamplersEXT_after(commandBuffer, pipelineBindPoint, layout, set);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindDescriptorBufferEmbeddedSamplersEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, VkBufferCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferOpaqueCaptureDescriptorDataEXT!");
}
#ifdef GETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureDescriptorDataEXT_before(device, pInfo, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFEROPAQUECAPTUREDESCRIPTORDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureDescriptorDataEXT_after(device, pInfo, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferOpaqueCaptureDescriptorDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, VkImageCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageOpaqueCaptureDescriptorDataEXT!");
}
#ifdef GETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageOpaqueCaptureDescriptorDataEXT_before(device, pInfo, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->image=" + ptrToString((void**)std::addressof(pInfo->image)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEOPAQUECAPTUREDESCRIPTORDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageOpaqueCaptureDescriptorDataEXT_after(device, pInfo, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageOpaqueCaptureDescriptorDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, VkImageViewCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageViewOpaqueCaptureDescriptorDataEXT!");
}
#ifdef GETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageViewOpaqueCaptureDescriptorDataEXT_before(device, pInfo, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->imageView=" + ptrToString((void**)std::addressof(pInfo->imageView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEVIEWOPAQUECAPTUREDESCRIPTORDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageViewOpaqueCaptureDescriptorDataEXT_after(device, pInfo, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageViewOpaqueCaptureDescriptorDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, VkSamplerCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSamplerOpaqueCaptureDescriptorDataEXT!");
}
#ifdef GETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSamplerOpaqueCaptureDescriptorDataEXT_before(device, pInfo, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->sampler=" + ptrToString((void**)std::addressof(pInfo->sampler)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETSAMPLEROPAQUECAPTUREDESCRIPTORDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSamplerOpaqueCaptureDescriptorDataEXT_after(device, pInfo, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSamplerOpaqueCaptureDescriptorDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, VkAccelerationStructureCaptureDescriptorDataInfoEXT* pInfo, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT!");
}
#ifdef GETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT_before(device, pInfo, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->accelerationStructure=" + ptrToString((void**)std::addressof(pInfo->accelerationStructure)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->accelerationStructureNV=" + ptrToString((void**)std::addressof(pInfo->accelerationStructureNV)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETACCELERATIONSTRUCTUREOPAQUECAPTUREDESCRIPTORDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT_after(device, pInfo, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetDeviceMemoryPriorityEXT!");
}
#ifdef SETDEVICEMEMORYPRIORITYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetDeviceMemoryPriorityEXT_before(device, memory, priority);
}
#endif 
device_dispatch[GetKey(device)].SetDeviceMemoryPriorityEXT(device, memory, priority);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"memory=" + ptrToString((void**)std::addressof(memory)) + '!');
winsockSendToUI(&ConnectSocket,"priority=" + std::to_string(priority) + '!');
}
#ifdef SETDEVICEMEMORYPRIORITYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetDeviceMemoryPriorityEXT_after(device, memory, priority);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetDeviceMemoryPriorityEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].SetDeviceMemoryPriorityEXT(device, memory, priority);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWaitForPresentKHR!");
}
#ifdef WAITFORPRESENTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_WaitForPresentKHR_before(device, swapchain, presentId, timeout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WaitForPresentKHR(device, swapchain, presentId, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"presentId=" + std::to_string(presentId) + '!');
winsockSendToUI(&ConnectSocket,"timeout=" + std::to_string(timeout) + '!');
}
#ifdef WAITFORPRESENTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_WaitForPresentKHR_after(device, swapchain, presentId, timeout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWaitForPresentKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WaitForPresentKHR(device, swapchain, presentId, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionCreateInfoFUCHSIA* pCreateInfo, VkAllocationCallbacks* pAllocator, VkBufferCollectionFUCHSIA* pCollection) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateBufferCollectionFUCHSIA!");
}
#ifdef CREATEBUFFERCOLLECTIONFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateBufferCollectionFUCHSIA_before(device, pCreateInfo, pAllocator, pCollection);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->collectionToken=" + ptrToString((void**)std::addressof(pCreateInfo->collectionToken)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCollection=" + ptrToString((void**)std::addressof(pCollection)) + '!');
}
#ifdef CREATEBUFFERCOLLECTIONFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateBufferCollectionFUCHSIA_after(device, pCreateInfo, pAllocator, pCollection);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateBufferCollectionFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferConstraintsInfoFUCHSIA* pBufferConstraintsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetBufferCollectionBufferConstraintsFUCHSIA!");
}
#ifdef SETBUFFERCOLLECTIONBUFFERCONSTRAINTSFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetBufferCollectionBufferConstraintsFUCHSIA_before(device, collection, pBufferConstraintsInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"collection=" + ptrToString((void**)std::addressof(collection)) + '!');
if(pBufferConstraintsInfo != VK_NULL_HANDLE && pBufferConstraintsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBufferConstraintsInfo->createInfo=" + ptrToString((void**)std::addressof(pBufferConstraintsInfo->createInfo)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferConstraintsInfo->requiredFormatFeatures=" + ptrToString((void**)std::addressof(pBufferConstraintsInfo->requiredFormatFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pBufferConstraintsInfo->bufferCollectionConstraints=" + ptrToString((void**)std::addressof(pBufferConstraintsInfo->bufferCollectionConstraints)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferConstraintsInfo=VK_NULL_HANDLE!");
}
#ifdef SETBUFFERCOLLECTIONBUFFERCONSTRAINTSFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_SetBufferCollectionBufferConstraintsFUCHSIA_after(device, collection, pBufferConstraintsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetBufferCollectionBufferConstraintsFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkImageConstraintsInfoFUCHSIA* pImageConstraintsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetBufferCollectionImageConstraintsFUCHSIA!");
}
#ifdef SETBUFFERCOLLECTIONIMAGECONSTRAINTSFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetBufferCollectionImageConstraintsFUCHSIA_before(device, collection, pImageConstraintsInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"collection=" + ptrToString((void**)std::addressof(collection)) + '!');
if(pImageConstraintsInfo != VK_NULL_HANDLE && pImageConstraintsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->formatConstraintsCount=" + std::to_string(pImageConstraintsInfo->formatConstraintsCount) + '!');
if(pImageConstraintsInfo->pFormatConstraints != VK_NULL_HANDLE && pImageConstraintsInfo->pFormatConstraints != NULL) {
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->imageCreateInfo=" + ptrToString((void**)std::addressof(pImageConstraintsInfo->pFormatConstraints->imageCreateInfo)) + '!');
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->requiredFormatFeatures=" + ptrToString((void**)std::addressof(pImageConstraintsInfo->pFormatConstraints->requiredFormatFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->flags=" + ptrToString((void**)std::addressof(pImageConstraintsInfo->pFormatConstraints->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->sysmemPixelFormat=" + std::to_string(pImageConstraintsInfo->pFormatConstraints->sysmemPixelFormat) + '!');
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->colorSpaceCount=" + std::to_string(pImageConstraintsInfo->pFormatConstraints->colorSpaceCount) + '!');
if(pImageConstraintsInfo->pFormatConstraints->pColorSpaces != VK_NULL_HANDLE && pImageConstraintsInfo->pFormatConstraints->pColorSpaces != NULL) {
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->pFormatConstraints->pColorSpaces->colorSpace=" + std::to_string(pImageConstraintsInfo->pFormatConstraints->pColorSpaces->colorSpace) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorSpaces=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pFormatConstraints=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->bufferCollectionConstraints=" + ptrToString((void**)std::addressof(pImageConstraintsInfo->bufferCollectionConstraints)) + '!');
winsockSendToUI(&ConnectSocket,"pImageConstraintsInfo->flags=" + ptrToString((void**)std::addressof(pImageConstraintsInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageConstraintsInfo=VK_NULL_HANDLE!");
}
#ifdef SETBUFFERCOLLECTIONIMAGECONSTRAINTSFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_SetBufferCollectionImageConstraintsFUCHSIA_after(device, collection, pImageConstraintsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetBufferCollectionImageConstraintsFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyBufferCollectionFUCHSIA!");
}
#ifdef DESTROYBUFFERCOLLECTIONFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyBufferCollectionFUCHSIA_before(device, collection, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyBufferCollectionFUCHSIA(device, collection, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"collection=" + ptrToString((void**)std::addressof(collection)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYBUFFERCOLLECTIONFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyBufferCollectionFUCHSIA_after(device, collection, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyBufferCollectionFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyBufferCollectionFUCHSIA(device, collection, pAllocator);
}
}

#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferCollectionPropertiesFUCHSIA!");
}
#ifdef GETBUFFERCOLLECTIONPROPERTIESFUCHSIA_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferCollectionPropertiesFUCHSIA_before(device, collection, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"collection=" + ptrToString((void**)std::addressof(collection)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->memoryTypeBits=" + std::to_string(pProperties->memoryTypeBits) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->bufferCount=" + std::to_string(pProperties->bufferCount) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->createInfoIndex=" + std::to_string(pProperties->createInfoIndex) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->sysmemPixelFormat=" + std::to_string(pProperties->sysmemPixelFormat) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->formatFeatures=" + ptrToString((void**)std::addressof(pProperties->formatFeatures)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->sysmemColorSpaceIndex=" + ptrToString((void**)std::addressof(pProperties->sysmemColorSpaceIndex)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->samplerYcbcrConversionComponents=" + ptrToString((void**)std::addressof(pProperties->samplerYcbcrConversionComponents)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERCOLLECTIONPROPERTIESFUCHSIA_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferCollectionPropertiesFUCHSIA_after(device, collection, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferCollectionPropertiesFUCHSIA!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateCudaModuleNV(VkDevice device, VkCudaModuleCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCudaModuleNV* pModule) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateCudaModuleNV!");
}
#ifdef CREATECUDAMODULENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateCudaModuleNV_before(device, pCreateInfo, pAllocator, pModule);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->dataSize=" + std::to_string(pCreateInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pModule=" + ptrToString((void**)std::addressof(pModule)) + '!');
}
#ifdef CREATECUDAMODULENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateCudaModuleNV_after(device, pCreateInfo, pAllocator, pModule);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateCudaModuleNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t* pCacheSize, void* pCacheData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetCudaModuleCacheNV!");
}
#ifdef GETCUDAMODULECACHENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetCudaModuleCacheNV_before(device, module, pCacheSize, pCacheData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"module=" + ptrToString((void**)std::addressof(module)) + '!');
winsockSendToUI(&ConnectSocket,"pCacheSize=" + ptrToString((void**)std::addressof(pCacheSize)) + '!');
}
#ifdef GETCUDAMODULECACHENV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetCudaModuleCacheNV_after(device, module, pCacheSize, pCacheData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetCudaModuleCacheNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetCudaModuleCacheNV(device, module, pCacheSize, pCacheData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateCudaFunctionNV(VkDevice device, VkCudaFunctionCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkCudaFunctionNV* pFunction) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateCudaFunctionNV!");
}
#ifdef CREATECUDAFUNCTIONNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateCudaFunctionNV_before(device, pCreateInfo, pAllocator, pFunction);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->module=" + ptrToString((void**)std::addressof(pCreateInfo->module)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pFunction=" + ptrToString((void**)std::addressof(pFunction)) + '!');
}
#ifdef CREATECUDAFUNCTIONNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateCudaFunctionNV_after(device, pCreateInfo, pAllocator, pFunction);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateCudaFunctionNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyCudaModuleNV!");
}
#ifdef DESTROYCUDAMODULENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyCudaModuleNV_before(device, module, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyCudaModuleNV(device, module, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"module=" + ptrToString((void**)std::addressof(module)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYCUDAMODULENV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyCudaModuleNV_after(device, module, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyCudaModuleNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyCudaModuleNV(device, module, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyCudaFunctionNV!");
}
#ifdef DESTROYCUDAFUNCTIONNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyCudaFunctionNV_before(device, function, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyCudaFunctionNV(device, function, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"function=" + ptrToString((void**)std::addressof(function)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYCUDAFUNCTIONNV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyCudaFunctionNV_after(device, function, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyCudaFunctionNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyCudaFunctionNV(device, function, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, VkCudaLaunchInfoNV* pLaunchInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCudaLaunchKernelNV!");
}
#ifdef CMDCUDALAUNCHKERNELNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCudaLaunchKernelNV_before(commandBuffer, pLaunchInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pLaunchInfo != VK_NULL_HANDLE && pLaunchInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pLaunchInfo->function=" + ptrToString((void**)std::addressof(pLaunchInfo->function)) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimX=" + std::to_string(pLaunchInfo->gridDimX) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimY=" + std::to_string(pLaunchInfo->gridDimY) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->gridDimZ=" + std::to_string(pLaunchInfo->gridDimZ) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimX=" + std::to_string(pLaunchInfo->blockDimX) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimY=" + std::to_string(pLaunchInfo->blockDimY) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->blockDimZ=" + std::to_string(pLaunchInfo->blockDimZ) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->sharedMemBytes=" + std::to_string(pLaunchInfo->sharedMemBytes) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->paramCount=" + std::to_string(pLaunchInfo->paramCount) + '!');
winsockSendToUI(&ConnectSocket,"pLaunchInfo->extraCount=" + std::to_string(pLaunchInfo->extraCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pLaunchInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCUDALAUNCHKERNELNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCudaLaunchKernelNV_after(commandBuffer, pLaunchInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCudaLaunchKernelNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginRendering(VkCommandBuffer commandBuffer, VkRenderingInfo* pRenderingInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginRendering!");
}
#ifdef CMDBEGINRENDERING_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginRendering_before(commandBuffer, pRenderingInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginRendering(commandBuffer, pRenderingInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRenderingInfo != VK_NULL_HANDLE && pRenderingInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->flags=" + ptrToString((void**)std::addressof(pRenderingInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->renderArea=" + ptrToString((void**)std::addressof(pRenderingInfo->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->layerCount=" + std::to_string(pRenderingInfo->layerCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->viewMask=" + std::to_string(pRenderingInfo->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->colorAttachmentCount=" + std::to_string(pRenderingInfo->colorAttachmentCount) + '!');
if(pRenderingInfo->pColorAttachments != VK_NULL_HANDLE && pRenderingInfo->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pRenderingInfo->pDepthAttachment != VK_NULL_HANDLE && pRenderingInfo->pDepthAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthAttachment=VK_NULL_HANDLE!");
if(pRenderingInfo->pStencilAttachment != VK_NULL_HANDLE && pRenderingInfo->pStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pStencilAttachment=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pRenderingInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINRENDERING_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginRendering_after(commandBuffer, pRenderingInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginRendering!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginRendering(commandBuffer, pRenderingInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndRendering(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndRendering!");
}
#ifdef CMDENDRENDERING_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndRendering_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndRendering(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDENDRENDERING_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndRendering_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndRendering!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndRendering(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetLayoutHostMappingInfoVALVE!");
}
#ifdef GETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutHostMappingInfoVALVE_before(device, pBindingReference, pHostMapping);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pBindingReference != VK_NULL_HANDLE && pBindingReference != NULL) {
winsockSendToUI(&ConnectSocket,"pBindingReference->descriptorSetLayout=" + ptrToString((void**)std::addressof(pBindingReference->descriptorSetLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pBindingReference->binding=" + std::to_string(pBindingReference->binding) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindingReference=VK_NULL_HANDLE!");
if(pHostMapping != VK_NULL_HANDLE && pHostMapping != NULL) {
winsockSendToUI(&ConnectSocket,"pHostMapping->descriptorOffset=" + std::to_string(pHostMapping->descriptorOffset) + '!');
winsockSendToUI(&ConnectSocket,"pHostMapping->descriptorSize=" + std::to_string(pHostMapping->descriptorSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pHostMapping=VK_NULL_HANDLE!");
}
#ifdef GETDESCRIPTORSETLAYOUTHOSTMAPPINGINFOVALVE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutHostMappingInfoVALVE_after(device, pBindingReference, pHostMapping);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetLayoutHostMappingInfoVALVE!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void** ppData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetHostMappingVALVE!");
}
#ifdef GETDESCRIPTORSETHOSTMAPPINGVALVE_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetHostMappingVALVE_before(device, descriptorSet, ppData);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSet=" + ptrToString((void**)std::addressof(descriptorSet)) + '!');
winsockSendToUI(&ConnectSocket,"ppData=" + ptrToString((void**)std::addressof(ppData)) + '!');
}
#ifdef GETDESCRIPTORSETHOSTMAPPINGVALVE_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetHostMappingVALVE_after(device, descriptorSet, ppData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetHostMappingVALVE!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateMicromapEXT(VkDevice device, VkMicromapCreateInfoEXT* pCreateInfo, VkAllocationCallbacks* pAllocator, VkMicromapEXT* pMicromap) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateMicromapEXT!");
}
#ifdef CREATEMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateMicromapEXT_before(device, pCreateInfo, pAllocator, pMicromap);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->createFlags=" + ptrToString((void**)std::addressof(pCreateInfo->createFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->buffer=" + ptrToString((void**)std::addressof(pCreateInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->offset=" + std::to_string(pCreateInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->size=" + std::to_string(pCreateInfo->size) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->deviceAddress=" + ptrToString((void**)std::addressof(pCreateInfo->deviceAddress)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pMicromap=" + ptrToString((void**)std::addressof(pMicromap)) + '!');
}
#ifdef CREATEMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateMicromapEXT_after(device, pCreateInfo, pAllocator, pMicromap);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, VkMicromapBuildInfoEXT* pInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBuildMicromapsEXT!");
}
#ifdef CMDBUILDMICROMAPSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBuildMicromapsEXT_before(commandBuffer, infoCount, pInfos);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"infoCount=" + std::to_string(infoCount) + '!');
if(pInfos != VK_NULL_HANDLE && pInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->flags=" + ptrToString((void**)std::addressof(pInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->dstMicromap=" + ptrToString((void**)std::addressof(pInfos->dstMicromap)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->usageCountsCount=" + std::to_string(pInfos->usageCountsCount) + '!');
if(pInfos->pUsageCounts != VK_NULL_HANDLE && pInfos->pUsageCounts != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->count=" + std::to_string(pInfos->pUsageCounts->count) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->subdivisionLevel=" + std::to_string(pInfos->pUsageCounts->subdivisionLevel) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->format=" + std::to_string(pInfos->pUsageCounts->format) + '!');
}else winsockSendToUI(&ConnectSocket, "pUsageCounts=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pInfos->data=" + ptrToString((void**)std::addressof(pInfos->data)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->scratchData=" + ptrToString((void**)std::addressof(pInfos->scratchData)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->triangleArray=" + ptrToString((void**)std::addressof(pInfos->triangleArray)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->triangleArrayStride=" + std::to_string(pInfos->triangleArrayStride) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfos=VK_NULL_HANDLE!");
}
#ifdef CMDBUILDMICROMAPSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBuildMicromapsEXT_after(commandBuffer, infoCount, pInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBuildMicromapsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, VkMicromapBuildInfoEXT* pInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBuildMicromapsEXT!");
}
#ifdef BUILDMICROMAPSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_BuildMicromapsEXT_before(device, deferredOperation, infoCount, pInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
winsockSendToUI(&ConnectSocket,"infoCount=" + std::to_string(infoCount) + '!');
if(pInfos != VK_NULL_HANDLE && pInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->flags=" + ptrToString((void**)std::addressof(pInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->dstMicromap=" + ptrToString((void**)std::addressof(pInfos->dstMicromap)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->usageCountsCount=" + std::to_string(pInfos->usageCountsCount) + '!');
if(pInfos->pUsageCounts != VK_NULL_HANDLE && pInfos->pUsageCounts != NULL) {
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->count=" + std::to_string(pInfos->pUsageCounts->count) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->subdivisionLevel=" + std::to_string(pInfos->pUsageCounts->subdivisionLevel) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->pUsageCounts->format=" + std::to_string(pInfos->pUsageCounts->format) + '!');
}else winsockSendToUI(&ConnectSocket, "pUsageCounts=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pInfos->data=" + ptrToString((void**)std::addressof(pInfos->data)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->scratchData=" + ptrToString((void**)std::addressof(pInfos->scratchData)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->triangleArray=" + ptrToString((void**)std::addressof(pInfos->triangleArray)) + '!');
winsockSendToUI(&ConnectSocket,"pInfos->triangleArrayStride=" + std::to_string(pInfos->triangleArrayStride) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfos=VK_NULL_HANDLE!");
}
#ifdef BUILDMICROMAPSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_BuildMicromapsEXT_after(device, deferredOperation, infoCount, pInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBuildMicromapsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyMicromapEXT!");
}
#ifdef DESTROYMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyMicromapEXT_before(device, micromap, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyMicromapEXT(device, micromap, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"micromap=" + ptrToString((void**)std::addressof(micromap)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyMicromapEXT_after(device, micromap, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyMicromapEXT(device, micromap, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, VkCopyMicromapInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMicromapEXT!");
}
#ifdef CMDCOPYMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMicromapEXT_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMicromapEXT(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMicromapEXT_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMicromapEXT(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMicromapInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyMicromapEXT!");
}
#ifdef COPYMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyMicromapEXT_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyMicromapEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyMicromapEXT_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyMicromapEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, VkCopyMicromapToMemoryInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMicromapToMemoryEXT!");
}
#ifdef CMDCOPYMICROMAPTOMEMORYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMicromapToMemoryEXT_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYMICROMAPTOMEMORYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMicromapToMemoryEXT_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMicromapToMemoryEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMicromapToMemoryInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyMicromapToMemoryEXT!");
}
#ifdef COPYMICROMAPTOMEMORYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyMicromapToMemoryEXT_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYMICROMAPTOMEMORYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyMicromapToMemoryEXT_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyMicromapToMemoryEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, VkCopyMemoryToMicromapInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyMemoryToMicromapEXT!");
}
#ifdef CMDCOPYMEMORYTOMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToMicromapEXT_before(commandBuffer, pInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYMEMORYTOMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyMemoryToMicromapEXT_after(commandBuffer, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyMemoryToMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, VkCopyMemoryToMicromapInfoEXT* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCopyMemoryToMicromapEXT!");
}
#ifdef COPYMEMORYTOMICROMAPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToMicromapEXT_before(device, deferredOperation, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"deferredOperation=" + ptrToString((void**)std::addressof(deferredOperation)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->src=" + ptrToString((void**)std::addressof(pInfo->src)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->dst=" + ptrToString((void**)std::addressof(pInfo->dst)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef COPYMEMORYTOMICROMAPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CopyMemoryToMicromapEXT_after(device, deferredOperation, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCopyMemoryToMicromapEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteMicromapsPropertiesEXT!");
}
#ifdef CMDWRITEMICROMAPSPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteMicromapsPropertiesEXT_before(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"micromapCount=" + std::to_string(micromapCount) + '!');
winsockSendToUI(&ConnectSocket,"pMicromaps=" + ptrToString((void**)std::addressof(pMicromaps)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
}
#ifdef CMDWRITEMICROMAPSPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteMicromapsPropertiesEXT_after(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteMicromapsPropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, VkMicromapEXT* pMicromaps, VkQueryType queryType, size_t dataSize, void* pData, size_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWriteMicromapsPropertiesEXT!");
}
#ifdef WRITEMICROMAPSPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_WriteMicromapsPropertiesEXT_before(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"micromapCount=" + std::to_string(micromapCount) + '!');
winsockSendToUI(&ConnectSocket,"pMicromaps=" + ptrToString((void**)std::addressof(pMicromaps)) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef WRITEMICROMAPSPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_WriteMicromapsPropertiesEXT_after(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWriteMicromapsPropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceMicromapCompatibilityEXT(VkDevice device, VkMicromapVersionInfoEXT* pVersionInfo, VkAccelerationStructureCompatibilityKHR* pCompatibility) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceMicromapCompatibilityEXT!");
}
#ifdef GETDEVICEMICROMAPCOMPATIBILITYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceMicromapCompatibilityEXT_before(device, pVersionInfo, pCompatibility);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pVersionInfo != VK_NULL_HANDLE && pVersionInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pVersionInfo->pVersionData=" + ptrToString((void**)std::addressof(pVersionInfo->pVersionData)) + '!');
}else winsockSendToUI(&ConnectSocket, "pVersionInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCompatibility=" + ptrToString((void**)std::addressof(pCompatibility)) + '!');
}
#ifdef GETDEVICEMICROMAPCOMPATIBILITYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceMicromapCompatibilityEXT_after(device, pVersionInfo, pCompatibility);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceMicromapCompatibilityEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, VkMicromapBuildInfoEXT* pBuildInfo, VkMicromapBuildSizesInfoEXT* pSizeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetMicromapBuildSizesEXT!");
}
#ifdef GETMICROMAPBUILDSIZESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetMicromapBuildSizesEXT_before(device, buildType, pBuildInfo, pSizeInfo);
}
#endif 
device_dispatch[GetKey(device)].GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pBuildInfo != VK_NULL_HANDLE && pBuildInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBuildInfo->flags=" + ptrToString((void**)std::addressof(pBuildInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->dstMicromap=" + ptrToString((void**)std::addressof(pBuildInfo->dstMicromap)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->usageCountsCount=" + std::to_string(pBuildInfo->usageCountsCount) + '!');
if(pBuildInfo->pUsageCounts != VK_NULL_HANDLE && pBuildInfo->pUsageCounts != NULL) {
winsockSendToUI(&ConnectSocket,"pBuildInfo->pUsageCounts->count=" + std::to_string(pBuildInfo->pUsageCounts->count) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->pUsageCounts->subdivisionLevel=" + std::to_string(pBuildInfo->pUsageCounts->subdivisionLevel) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->pUsageCounts->format=" + std::to_string(pBuildInfo->pUsageCounts->format) + '!');
}else winsockSendToUI(&ConnectSocket, "pUsageCounts=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pBuildInfo->data=" + ptrToString((void**)std::addressof(pBuildInfo->data)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->scratchData=" + ptrToString((void**)std::addressof(pBuildInfo->scratchData)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->triangleArray=" + ptrToString((void**)std::addressof(pBuildInfo->triangleArray)) + '!');
winsockSendToUI(&ConnectSocket,"pBuildInfo->triangleArrayStride=" + std::to_string(pBuildInfo->triangleArrayStride) + '!');
}else winsockSendToUI(&ConnectSocket, "pBuildInfo=VK_NULL_HANDLE!");
if(pSizeInfo != VK_NULL_HANDLE && pSizeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSizeInfo->micromapSize=" + std::to_string(pSizeInfo->micromapSize) + '!');
winsockSendToUI(&ConnectSocket,"pSizeInfo->buildScratchSize=" + std::to_string(pSizeInfo->buildScratchSize) + '!');
winsockSendToUI(&ConnectSocket,"pSizeInfo->discardable=" + bool_as_text(pSizeInfo->discardable) + '!');
}else winsockSendToUI(&ConnectSocket, "pSizeInfo=VK_NULL_HANDLE!");
}
#ifdef GETMICROMAPBUILDSIZESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetMicromapBuildSizesEXT_after(device, buildType, pBuildInfo, pSizeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetMicromapBuildSizesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT* pIdentifier) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetShaderModuleIdentifierEXT!");
}
#ifdef GETSHADERMODULEIDENTIFIEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetShaderModuleIdentifierEXT_before(device, shaderModule, pIdentifier);
}
#endif 
device_dispatch[GetKey(device)].GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"shaderModule=" + ptrToString((void**)std::addressof(shaderModule)) + '!');
if(pIdentifier != VK_NULL_HANDLE && pIdentifier != NULL) {
winsockSendToUI(&ConnectSocket,"pIdentifier->identifierSize=" + std::to_string(pIdentifier->identifierSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pIdentifier=VK_NULL_HANDLE!");
}
#ifdef GETSHADERMODULEIDENTIFIEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetShaderModuleIdentifierEXT_after(device, shaderModule, pIdentifier);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetShaderModuleIdentifierEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, VkShaderModuleCreateInfo* pCreateInfo, VkShaderModuleIdentifierEXT* pIdentifier) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetShaderModuleCreateInfoIdentifierEXT!");
}
#ifdef GETSHADERMODULECREATEINFOIDENTIFIEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetShaderModuleCreateInfoIdentifierEXT_before(device, pCreateInfo, pIdentifier);
}
#endif 
device_dispatch[GetKey(device)].GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->codeSize=" + std::to_string(pCreateInfo->codeSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pIdentifier != VK_NULL_HANDLE && pIdentifier != NULL) {
winsockSendToUI(&ConnectSocket,"pIdentifier->identifierSize=" + std::to_string(pIdentifier->identifierSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pIdentifier=VK_NULL_HANDLE!");
}
#ifdef GETSHADERMODULECREATEINFOIDENTIFIEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetShaderModuleCreateInfoIdentifierEXT_after(device, pCreateInfo, pIdentifier);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetShaderModuleCreateInfoIdentifierEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSubresourceLayout2KHR!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout2KHR_before(device, image, pSubresource, pLayout);
}
#endif 
device_dispatch[GetKey(device)].GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pSubresource != VK_NULL_HANDLE && pSubresource != NULL) {
winsockSendToUI(&ConnectSocket,"pSubresource->imageSubresource=" + ptrToString((void**)std::addressof(pSubresource->imageSubresource)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubresource=VK_NULL_HANDLE!");
if(pLayout != VK_NULL_HANDLE && pLayout != NULL) {
winsockSendToUI(&ConnectSocket,"pLayout->subresourceLayout=" + ptrToString((void**)std::addressof(pLayout->subresourceLayout)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLayout=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout2KHR_after(device, image, pSubresource, pLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSubresourceLayout2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetPipelinePropertiesEXT(VkDevice device, VkPipelineInfoEXT* pPipelineInfo, VkBaseOutStructure* pPipelineProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPipelinePropertiesEXT!");
}
#ifdef GETPIPELINEPROPERTIESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPipelinePropertiesEXT_before(device, pPipelineInfo, pPipelineProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pPipelineInfo != VK_NULL_HANDLE && pPipelineInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pPipelineInfo=VK_NULL_HANDLE!");
if(pPipelineProperties != VK_NULL_HANDLE && pPipelineProperties != NULL) {
if(pPipelineProperties->pNext != VK_NULL_HANDLE && pPipelineProperties->pNext != NULL) {
if(pPipelineProperties->pNext->pNext != VK_NULL_HANDLE && pPipelineProperties->pNext->pNext != NULL) {
}else winsockSendToUI(&ConnectSocket, "pNext=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pNext=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pPipelineProperties=VK_NULL_HANDLE!");
}
#ifdef GETPIPELINEPROPERTIESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPipelinePropertiesEXT_after(device, pPipelineInfo, pPipelineProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPipelinePropertiesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#if defined(VK_USE_PLATFORM_METAL_EXT)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT* pMetalObjectsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkExportMetalObjectsEXT!");
}
#ifdef EXPORTMETALOBJECTSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ExportMetalObjectsEXT_before(device, pMetalObjectsInfo);
}
#endif 
device_dispatch[GetKey(device)].ExportMetalObjectsEXT(device, pMetalObjectsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pMetalObjectsInfo != VK_NULL_HANDLE && pMetalObjectsInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pMetalObjectsInfo=VK_NULL_HANDLE!");
}
#ifdef EXPORTMETALOBJECTSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_ExportMetalObjectsEXT_after(device, pMetalObjectsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkExportMetalObjectsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].ExportMetalObjectsEXT(device, pMetalObjectsInfo);
}
}

#endif
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t* pPropertiesCount, VkTilePropertiesQCOM* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetFramebufferTilePropertiesQCOM!");
}
#ifdef GETFRAMEBUFFERTILEPROPERTIESQCOM_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetFramebufferTilePropertiesQCOM_before(device, framebuffer, pPropertiesCount, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"framebuffer=" + ptrToString((void**)std::addressof(framebuffer)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->tileSize=" + ptrToString((void**)std::addressof(pProperties->tileSize)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->apronSize=" + ptrToString((void**)std::addressof(pProperties->apronSize)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->origin=" + ptrToString((void**)std::addressof(pProperties->origin)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETFRAMEBUFFERTILEPROPERTIESQCOM_AFTER_EXEC_EXISTS
if(connected) {
layer_GetFramebufferTilePropertiesQCOM_after(device, framebuffer, pPropertiesCount, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetFramebufferTilePropertiesQCOM!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDynamicRenderingTilePropertiesQCOM(VkDevice device, VkRenderingInfo* pRenderingInfo, VkTilePropertiesQCOM* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDynamicRenderingTilePropertiesQCOM!");
}
#ifdef GETDYNAMICRENDERINGTILEPROPERTIESQCOM_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDynamicRenderingTilePropertiesQCOM_before(device, pRenderingInfo, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pRenderingInfo != VK_NULL_HANDLE && pRenderingInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->flags=" + ptrToString((void**)std::addressof(pRenderingInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->renderArea=" + ptrToString((void**)std::addressof(pRenderingInfo->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->layerCount=" + std::to_string(pRenderingInfo->layerCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->viewMask=" + std::to_string(pRenderingInfo->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->colorAttachmentCount=" + std::to_string(pRenderingInfo->colorAttachmentCount) + '!');
if(pRenderingInfo->pColorAttachments != VK_NULL_HANDLE && pRenderingInfo->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pRenderingInfo->pDepthAttachment != VK_NULL_HANDLE && pRenderingInfo->pDepthAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthAttachment=VK_NULL_HANDLE!");
if(pRenderingInfo->pStencilAttachment != VK_NULL_HANDLE && pRenderingInfo->pStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pStencilAttachment=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pRenderingInfo=VK_NULL_HANDLE!");
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->tileSize=" + ptrToString((void**)std::addressof(pProperties->tileSize)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->apronSize=" + ptrToString((void**)std::addressof(pProperties->apronSize)) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->origin=" + ptrToString((void**)std::addressof(pProperties->origin)) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETDYNAMICRENDERINGTILEPROPERTIESQCOM_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDynamicRenderingTilePropertiesQCOM_after(device, pRenderingInfo, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDynamicRenderingTilePropertiesQCOM!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionCreateInfoNV* pCreateInfo, VkAllocationCallbacks* pAllocator, VkOpticalFlowSessionNV* pSession) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateOpticalFlowSessionNV!");
}
#ifdef CREATEOPTICALFLOWSESSIONNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateOpticalFlowSessionNV_before(device, pCreateInfo, pAllocator, pSession);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->width=" + std::to_string(pCreateInfo->width) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->height=" + std::to_string(pCreateInfo->height) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->outputGridSize=" + ptrToString((void**)std::addressof(pCreateInfo->outputGridSize)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->hintGridSize=" + ptrToString((void**)std::addressof(pCreateInfo->hintGridSize)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSession=" + ptrToString((void**)std::addressof(pSession)) + '!');
}
#ifdef CREATEOPTICALFLOWSESSIONNV_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateOpticalFlowSessionNV_after(device, pCreateInfo, pAllocator, pSession);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateOpticalFlowSessionNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyOpticalFlowSessionNV!");
}
#ifdef DESTROYOPTICALFLOWSESSIONNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyOpticalFlowSessionNV_before(device, session, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyOpticalFlowSessionNV(device, session, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"session=" + ptrToString((void**)std::addressof(session)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYOPTICALFLOWSESSIONNV_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyOpticalFlowSessionNV_after(device, session, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyOpticalFlowSessionNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyOpticalFlowSessionNV(device, session, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindOpticalFlowSessionImageNV!");
}
#ifdef BINDOPTICALFLOWSESSIONIMAGENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindOpticalFlowSessionImageNV_before(device, session, bindingPoint, view, layout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"session=" + ptrToString((void**)std::addressof(session)) + '!');
winsockSendToUI(&ConnectSocket,"view=" + ptrToString((void**)std::addressof(view)) + '!');
}
#ifdef BINDOPTICALFLOWSESSIONIMAGENV_AFTER_EXEC_EXISTS
if(connected) {
layer_BindOpticalFlowSessionImageNV_after(device, session, bindingPoint, view, layout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindOpticalFlowSessionImageNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, VkOpticalFlowExecuteInfoNV* pExecuteInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdOpticalFlowExecuteNV!");
}
#ifdef CMDOPTICALFLOWEXECUTENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdOpticalFlowExecuteNV_before(commandBuffer, session, pExecuteInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"session=" + ptrToString((void**)std::addressof(session)) + '!');
if(pExecuteInfo != VK_NULL_HANDLE && pExecuteInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pExecuteInfo->flags=" + ptrToString((void**)std::addressof(pExecuteInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pExecuteInfo->regionCount=" + std::to_string(pExecuteInfo->regionCount) + '!');
if(pExecuteInfo->pRegions != VK_NULL_HANDLE && pExecuteInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pExecuteInfo->pRegions->offset=" + ptrToString((void**)std::addressof(pExecuteInfo->pRegions->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pExecuteInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pExecuteInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pExecuteInfo=VK_NULL_HANDLE!");
}
#ifdef CMDOPTICALFLOWEXECUTENV_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdOpticalFlowExecuteNV_after(commandBuffer, session, pExecuteInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdOpticalFlowExecuteNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT* pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceFaultInfoEXT!");
}
#ifdef GETDEVICEFAULTINFOEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceFaultInfoEXT_before(device, pFaultCounts, pFaultInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pFaultCounts != VK_NULL_HANDLE && pFaultCounts != NULL) {
winsockSendToUI(&ConnectSocket,"pFaultCounts->addressInfoCount=" + std::to_string(pFaultCounts->addressInfoCount) + '!');
winsockSendToUI(&ConnectSocket,"pFaultCounts->vendorInfoCount=" + std::to_string(pFaultCounts->vendorInfoCount) + '!');
winsockSendToUI(&ConnectSocket,"pFaultCounts->vendorBinarySize=" + std::to_string(pFaultCounts->vendorBinarySize) + '!');
}else winsockSendToUI(&ConnectSocket, "pFaultCounts=VK_NULL_HANDLE!");
if(pFaultInfo != VK_NULL_HANDLE && pFaultInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pFaultInfo->pAddressInfos=" + ptrToString((void**)std::addressof(pFaultInfo->pAddressInfos)) + '!');
winsockSendToUI(&ConnectSocket,"pFaultInfo->pVendorInfos=" + ptrToString((void**)std::addressof(pFaultInfo->pVendorInfos)) + '!');
}else winsockSendToUI(&ConnectSocket, "pFaultInfo=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEFAULTINFOEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceFaultInfoEXT_after(device, pFaultCounts, pFaultInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceFaultInfoEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, VkDepthBiasInfoEXT* pDepthBiasInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBias2EXT!");
}
#ifdef CMDSETDEPTHBIAS2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBias2EXT_before(commandBuffer, pDepthBiasInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pDepthBiasInfo != VK_NULL_HANDLE && pDepthBiasInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDepthBiasInfo->depthBiasConstantFactor=" + std::to_string(pDepthBiasInfo->depthBiasConstantFactor) + '!');
winsockSendToUI(&ConnectSocket,"pDepthBiasInfo->depthBiasClamp=" + std::to_string(pDepthBiasInfo->depthBiasClamp) + '!');
winsockSendToUI(&ConnectSocket,"pDepthBiasInfo->depthBiasSlopeFactor=" + std::to_string(pDepthBiasInfo->depthBiasSlopeFactor) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthBiasInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETDEPTHBIAS2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBias2EXT_after(commandBuffer, pDepthBiasInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBias2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_ReleaseSwapchainImagesEXT(VkDevice device, VkReleaseSwapchainImagesInfoEXT* pReleaseInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkReleaseSwapchainImagesEXT!");
}
#ifdef RELEASESWAPCHAINIMAGESEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ReleaseSwapchainImagesEXT_before(device, pReleaseInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].ReleaseSwapchainImagesEXT(device, pReleaseInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pReleaseInfo != VK_NULL_HANDLE && pReleaseInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pReleaseInfo->swapchain=" + ptrToString((void**)std::addressof(pReleaseInfo->swapchain)) + '!');
winsockSendToUI(&ConnectSocket,"pReleaseInfo->imageIndexCount=" + std::to_string(pReleaseInfo->imageIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pReleaseInfo=VK_NULL_HANDLE!");
}
#ifdef RELEASESWAPCHAINIMAGESEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_ReleaseSwapchainImagesEXT_after(device, pReleaseInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkReleaseSwapchainImagesEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].ReleaseSwapchainImagesEXT(device, pReleaseInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceImageSubresourceLayoutKHR(VkDevice device, VkDeviceImageSubresourceInfoKHR* pInfo, VkSubresourceLayout2KHR* pLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceImageSubresourceLayoutKHR!");
}
#ifdef GETDEVICEIMAGESUBRESOURCELAYOUTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSubresourceLayoutKHR_before(device, pInfo, pLayout);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->extent=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->mipLevels=" + std::to_string(pInfo->pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->arrayLayers=" + std::to_string(pInfo->pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pInfo->pSubresource != VK_NULL_HANDLE && pInfo->pSubresource != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pSubresource->imageSubresource=" + ptrToString((void**)std::addressof(pInfo->pSubresource->imageSubresource)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubresource=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pLayout != VK_NULL_HANDLE && pLayout != NULL) {
winsockSendToUI(&ConnectSocket,"pLayout->subresourceLayout=" + ptrToString((void**)std::addressof(pLayout->subresourceLayout)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLayout=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEIMAGESUBRESOURCELAYOUTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSubresourceLayoutKHR_after(device, pInfo, pLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceImageSubresourceLayoutKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_MapMemory2KHR(VkDevice device, VkMemoryMapInfoKHR* pMemoryMapInfo, void** ppData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkMapMemory2KHR!");
}
#ifdef MAPMEMORY2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_MapMemory2KHR_before(device, pMemoryMapInfo, ppData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].MapMemory2KHR(device, pMemoryMapInfo, ppData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pMemoryMapInfo != VK_NULL_HANDLE && pMemoryMapInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryMapInfo->flags=" + ptrToString((void**)std::addressof(pMemoryMapInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryMapInfo->memory=" + ptrToString((void**)std::addressof(pMemoryMapInfo->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryMapInfo->offset=" + std::to_string(pMemoryMapInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryMapInfo->size=" + std::to_string(pMemoryMapInfo->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryMapInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"ppData=" + ptrToString((void**)std::addressof(ppData)) + '!');
}
#ifdef MAPMEMORY2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_MapMemory2KHR_after(device, pMemoryMapInfo, ppData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkMapMemory2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].MapMemory2KHR(device, pMemoryMapInfo, ppData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_UnmapMemory2KHR(VkDevice device, VkMemoryUnmapInfoKHR* pMemoryUnmapInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUnmapMemory2KHR!");
}
#ifdef UNMAPMEMORY2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_UnmapMemory2KHR_before(device, pMemoryUnmapInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].UnmapMemory2KHR(device, pMemoryUnmapInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pMemoryUnmapInfo != VK_NULL_HANDLE && pMemoryUnmapInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryUnmapInfo->flags=" + ptrToString((void**)std::addressof(pMemoryUnmapInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pMemoryUnmapInfo->memory=" + ptrToString((void**)std::addressof(pMemoryUnmapInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryUnmapInfo=VK_NULL_HANDLE!");
}
#ifdef UNMAPMEMORY2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_UnmapMemory2KHR_after(device, pMemoryUnmapInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUnmapMemory2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].UnmapMemory2KHR(device, pMemoryUnmapInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateShadersEXT(VkDevice device, uint32_t createInfoCount, VkShaderCreateInfoEXT* pCreateInfos, VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateShadersEXT!");
}
#ifdef CREATESHADERSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateShadersEXT_before(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->nextStage=" + ptrToString((void**)std::addressof(pCreateInfos->nextStage)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->codeSize=" + std::to_string(pCreateInfos->codeSize) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->setLayoutCount=" + std::to_string(pCreateInfos->setLayoutCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSetLayouts=" + ptrToString((void**)std::addressof(pCreateInfos->pSetLayouts)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pushConstantRangeCount=" + std::to_string(pCreateInfos->pushConstantRangeCount) + '!');
if(pCreateInfos->pPushConstantRanges != VK_NULL_HANDLE && pCreateInfos->pPushConstantRanges != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pPushConstantRanges->stageFlags=" + ptrToString((void**)std::addressof(pCreateInfos->pPushConstantRanges->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pPushConstantRanges->offset=" + std::to_string(pCreateInfos->pPushConstantRanges->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pPushConstantRanges->size=" + std::to_string(pCreateInfos->pPushConstantRanges->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pPushConstantRanges=VK_NULL_HANDLE!");
if(pCreateInfos->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pSpecializationInfo->mapEntryCount) + '!');
if(pCreateInfos->pSpecializationInfo->pMapEntries != VK_NULL_HANDLE && pCreateInfos->pSpecializationInfo->pMapEntries != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSpecializationInfo->pMapEntries->constantID=" + std::to_string(pCreateInfos->pSpecializationInfo->pMapEntries->constantID) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSpecializationInfo->pMapEntries->offset=" + std::to_string(pCreateInfos->pSpecializationInfo->pMapEntries->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSpecializationInfo->pMapEntries->size=" + std::to_string(pCreateInfos->pSpecializationInfo->pMapEntries->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pMapEntries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pShaders=" + ptrToString((void**)std::addressof(pShaders)) + '!');
}
#ifdef CREATESHADERSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateShadersEXT_after(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateShadersEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyShaderEXT(VkDevice device, VkShaderEXT shader, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyShaderEXT!");
}
#ifdef DESTROYSHADEREXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyShaderEXT_before(device, shader, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyShaderEXT(device, shader, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"shader=" + ptrToString((void**)std::addressof(shader)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSHADEREXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyShaderEXT_after(device, shader, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyShaderEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyShaderEXT(device, shader, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t* pDataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetShaderBinaryDataEXT!");
}
#ifdef GETSHADERBINARYDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetShaderBinaryDataEXT_before(device, shader, pDataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetShaderBinaryDataEXT(device, shader, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"shader=" + ptrToString((void**)std::addressof(shader)) + '!');
winsockSendToUI(&ConnectSocket,"pDataSize=" + ptrToString((void**)std::addressof(pDataSize)) + '!');
}
#ifdef GETSHADERBINARYDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetShaderBinaryDataEXT_after(device, shader, pDataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetShaderBinaryDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetShaderBinaryDataEXT(device, shader, pDataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, VkShaderStageFlagBits* pStages, VkShaderEXT* pShaders) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindShadersEXT!");
}
#ifdef CMDBINDSHADERSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindShadersEXT_before(commandBuffer, stageCount, pStages, pShaders);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stageCount=" + std::to_string(stageCount) + '!');
winsockSendToUI(&ConnectSocket,"pStages=" + ptrToString((void**)std::addressof(pStages)) + '!');
winsockSendToUI(&ConnectSocket,"pShaders=" + ptrToString((void**)std::addressof(pShaders)) + '!');
}
#ifdef CMDBINDSHADERSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindShadersEXT_after(commandBuffer, stageCount, pStages, pShaders);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindShadersEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders);
}
}

#if defined(VK_USE_PLATFORM_SCREEN_QNX)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetScreenBufferPropertiesQNX(VkDevice device, _screen_buffer* buffer, VkScreenBufferPropertiesQNX* pProperties) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetScreenBufferPropertiesQNX!");
}
#ifdef GETSCREENBUFFERPROPERTIESQNX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetScreenBufferPropertiesQNX_before(device, buffer, pProperties);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetScreenBufferPropertiesQNX(device, buffer, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
if(pProperties != VK_NULL_HANDLE && pProperties != NULL) {
winsockSendToUI(&ConnectSocket,"pProperties->allocationSize=" + std::to_string(pProperties->allocationSize) + '!');
winsockSendToUI(&ConnectSocket,"pProperties->memoryTypeBits=" + std::to_string(pProperties->memoryTypeBits) + '!');
}else winsockSendToUI(&ConnectSocket, "pProperties=VK_NULL_HANDLE!");
}
#ifdef GETSCREENBUFFERPROPERTIESQNX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetScreenBufferPropertiesQNX_after(device, buffer, pProperties);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetScreenBufferPropertiesQNX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetScreenBufferPropertiesQNX(device, buffer, pProperties);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetExecutionGraphPipelineScratchSizeAMDX!");
}
#ifdef GETEXECUTIONGRAPHPIPELINESCRATCHSIZEAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetExecutionGraphPipelineScratchSizeAMDX_before(device, executionGraph, pSizeInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"executionGraph=" + ptrToString((void**)std::addressof(executionGraph)) + '!');
if(pSizeInfo != VK_NULL_HANDLE && pSizeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSizeInfo->size=" + std::to_string(pSizeInfo->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pSizeInfo=VK_NULL_HANDLE!");
}
#ifdef GETEXECUTIONGRAPHPIPELINESCRATCHSIZEAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetExecutionGraphPipelineScratchSizeAMDX_after(device, executionGraph, pSizeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetExecutionGraphPipelineScratchSizeAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint32_t* pNodeIndex) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetExecutionGraphPipelineNodeIndexAMDX!");
}
#ifdef GETEXECUTIONGRAPHPIPELINENODEINDEXAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetExecutionGraphPipelineNodeIndexAMDX_before(device, executionGraph, pNodeInfo, pNodeIndex);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"executionGraph=" + ptrToString((void**)std::addressof(executionGraph)) + '!');
if(pNodeInfo != VK_NULL_HANDLE && pNodeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pNodeInfo->index=" + std::to_string(pNodeInfo->index) + '!');
}else winsockSendToUI(&ConnectSocket, "pNodeInfo=VK_NULL_HANDLE!");
}
#ifdef GETEXECUTIONGRAPHPIPELINENODEINDEXAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_GetExecutionGraphPipelineNodeIndexAMDX_after(device, executionGraph, pNodeInfo, pNodeIndex);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetExecutionGraphPipelineNodeIndexAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateExecutionGraphPipelinesAMDX!");
}
#ifdef CREATEEXECUTIONGRAPHPIPELINESAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateExecutionGraphPipelinesAMDX_before(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipelineCache=" + ptrToString((void**)std::addressof(pipelineCache)) + '!');
winsockSendToUI(&ConnectSocket,"createInfoCount=" + std::to_string(createInfoCount) + '!');
if(pCreateInfos != VK_NULL_HANDLE && pCreateInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->flags=" + ptrToString((void**)std::addressof(pCreateInfos->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->stageCount=" + std::to_string(pCreateInfos->stageCount) + '!');
if(pCreateInfos->pStages != VK_NULL_HANDLE && pCreateInfos->pStages != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->flags=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->module=" + ptrToString((void**)std::addressof(pCreateInfos->pStages->module)) + '!');
if(pCreateInfos->pStages->pSpecializationInfo != VK_NULL_HANDLE && pCreateInfos->pStages->pSpecializationInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->mapEntryCount=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->mapEntryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pStages->pSpecializationInfo->dataSize=" + std::to_string(pCreateInfos->pStages->pSpecializationInfo->dataSize) + '!');
}else winsockSendToUI(&ConnectSocket, "pSpecializationInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pStages=VK_NULL_HANDLE!");
if(pCreateInfos->pLibraryInfo != VK_NULL_HANDLE && pCreateInfos->pLibraryInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInfo->libraryCount=" + std::to_string(pCreateInfos->pLibraryInfo->libraryCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->pLibraryInfo->pLibraries=" + ptrToString((void**)std::addressof(pCreateInfos->pLibraryInfo->pLibraries)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLibraryInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfos->layout=" + ptrToString((void**)std::addressof(pCreateInfos->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineHandle=" + ptrToString((void**)std::addressof(pCreateInfos->basePipelineHandle)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfos->basePipelineIndex=" + std::to_string(pCreateInfos->basePipelineIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfos=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPipelines=" + ptrToString((void**)std::addressof(pPipelines)) + '!');
}
#ifdef CREATEEXECUTIONGRAPHPIPELINESAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateExecutionGraphPipelinesAMDX_after(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateExecutionGraphPipelinesAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdInitializeGraphScratchMemoryAMDX!");
}
#ifdef CMDINITIALIZEGRAPHSCRATCHMEMORYAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdInitializeGraphScratchMemoryAMDX_before(commandBuffer, scratch);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdInitializeGraphScratchMemoryAMDX(commandBuffer, scratch);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scratch=" + ptrToString((void**)std::addressof(scratch)) + '!');
}
#ifdef CMDINITIALIZEGRAPHSCRATCHMEMORYAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdInitializeGraphScratchMemoryAMDX_after(commandBuffer, scratch);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdInitializeGraphScratchMemoryAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdInitializeGraphScratchMemoryAMDX(commandBuffer, scratch);
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDispatchGraphCountInfoAMDX* pCountInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchGraphAMDX!");
}
#ifdef CMDDISPATCHGRAPHAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphAMDX_before(commandBuffer, scratch, pCountInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphAMDX(commandBuffer, scratch, pCountInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scratch=" + ptrToString((void**)std::addressof(scratch)) + '!');
if(pCountInfo != VK_NULL_HANDLE && pCountInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCountInfo->count=" + std::to_string(pCountInfo->count) + '!');
winsockSendToUI(&ConnectSocket,"pCountInfo->infos=" + ptrToString((void**)std::addressof(pCountInfo->infos)) + '!');
winsockSendToUI(&ConnectSocket,"pCountInfo->stride=" + std::to_string(pCountInfo->stride) + '!');
}else winsockSendToUI(&ConnectSocket, "pCountInfo=VK_NULL_HANDLE!");
}
#ifdef CMDDISPATCHGRAPHAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphAMDX_after(commandBuffer, scratch, pCountInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchGraphAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphAMDX(commandBuffer, scratch, pCountInfo);
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDispatchGraphCountInfoAMDX* pCountInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchGraphIndirectAMDX!");
}
#ifdef CMDDISPATCHGRAPHINDIRECTAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphIndirectAMDX_before(commandBuffer, scratch, pCountInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, pCountInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scratch=" + ptrToString((void**)std::addressof(scratch)) + '!');
if(pCountInfo != VK_NULL_HANDLE && pCountInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCountInfo->count=" + std::to_string(pCountInfo->count) + '!');
winsockSendToUI(&ConnectSocket,"pCountInfo->infos=" + ptrToString((void**)std::addressof(pCountInfo->infos)) + '!');
winsockSendToUI(&ConnectSocket,"pCountInfo->stride=" + std::to_string(pCountInfo->stride) + '!');
}else winsockSendToUI(&ConnectSocket, "pCountInfo=VK_NULL_HANDLE!");
}
#ifdef CMDDISPATCHGRAPHINDIRECTAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphIndirectAMDX_after(commandBuffer, scratch, pCountInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchGraphIndirectAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphIndirectAMDX(commandBuffer, scratch, pCountInfo);
}
}

#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceAddress countInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchGraphIndirectCountAMDX!");
}
#ifdef CMDDISPATCHGRAPHINDIRECTCOUNTAMDX_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphIndirectCountAMDX_before(commandBuffer, scratch, countInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, countInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scratch=" + ptrToString((void**)std::addressof(scratch)) + '!');
winsockSendToUI(&ConnectSocket,"countInfo=" + ptrToString((void**)std::addressof(countInfo)) + '!');
}
#ifdef CMDDISPATCHGRAPHINDIRECTCOUNTAMDX_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchGraphIndirectCountAMDX_after(commandBuffer, scratch, countInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchGraphIndirectCountAMDX!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, countInfo);
}
}

#endif
 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindDescriptorSets2KHR!");
}
#ifdef CMDBINDDESCRIPTORSETS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorSets2KHR_before(commandBuffer, pBindDescriptorSetsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBindDescriptorSetsInfo != VK_NULL_HANDLE && pBindDescriptorSetsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->stageFlags=" + ptrToString((void**)std::addressof(pBindDescriptorSetsInfo->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->layout=" + ptrToString((void**)std::addressof(pBindDescriptorSetsInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->firstSet=" + std::to_string(pBindDescriptorSetsInfo->firstSet) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->descriptorSetCount=" + std::to_string(pBindDescriptorSetsInfo->descriptorSetCount) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->pDescriptorSets=" + ptrToString((void**)std::addressof(pBindDescriptorSetsInfo->pDescriptorSets)) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorSetsInfo->dynamicOffsetCount=" + std::to_string(pBindDescriptorSetsInfo->dynamicOffsetCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindDescriptorSetsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBINDDESCRIPTORSETS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorSets2KHR_after(commandBuffer, pBindDescriptorSetsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindDescriptorSets2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushConstants2KHR(VkCommandBuffer commandBuffer, VkPushConstantsInfoKHR* pPushConstantsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushConstants2KHR!");
}
#ifdef CMDPUSHCONSTANTS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushConstants2KHR_before(commandBuffer, pPushConstantsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pPushConstantsInfo != VK_NULL_HANDLE && pPushConstantsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPushConstantsInfo->layout=" + ptrToString((void**)std::addressof(pPushConstantsInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pPushConstantsInfo->stageFlags=" + ptrToString((void**)std::addressof(pPushConstantsInfo->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pPushConstantsInfo->offset=" + std::to_string(pPushConstantsInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pPushConstantsInfo->size=" + std::to_string(pPushConstantsInfo->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pPushConstantsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPUSHCONSTANTS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushConstants2KHR_after(commandBuffer, pPushConstantsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushConstants2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushConstants2KHR(commandBuffer, pPushConstantsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushDescriptorSet2KHR!");
}
#ifdef CMDPUSHDESCRIPTORSET2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSet2KHR_before(commandBuffer, pPushDescriptorSetInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pPushDescriptorSetInfo != VK_NULL_HANDLE && pPushDescriptorSetInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->stageFlags=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->layout=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->set=" + std::to_string(pPushDescriptorSetInfo->set) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->descriptorWriteCount=" + std::to_string(pPushDescriptorSetInfo->descriptorWriteCount) + '!');
if(pPushDescriptorSetInfo->pDescriptorWrites != VK_NULL_HANDLE && pPushDescriptorSetInfo->pDescriptorWrites != NULL) {
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->dstSet=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->pDescriptorWrites->dstSet)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->dstBinding=" + std::to_string(pPushDescriptorSetInfo->pDescriptorWrites->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->dstArrayElement=" + std::to_string(pPushDescriptorSetInfo->pDescriptorWrites->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->descriptorCount=" + std::to_string(pPushDescriptorSetInfo->pDescriptorWrites->descriptorCount) + '!');
if(pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo != VK_NULL_HANDLE && pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo->sampler=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo->sampler)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo->imageView=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->pDescriptorWrites->pImageInfo->imageView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageInfo=VK_NULL_HANDLE!");
if(pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo != VK_NULL_HANDLE && pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->buffer=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->offset=" + std::to_string(pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->offset) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->range=" + std::to_string(pPushDescriptorSetInfo->pDescriptorWrites->pBufferInfo->range) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetInfo->pDescriptorWrites->pTexelBufferView=" + ptrToString((void**)std::addressof(pPushDescriptorSetInfo->pDescriptorWrites->pTexelBufferView)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorWrites=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pPushDescriptorSetInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPUSHDESCRIPTORSET2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSet2KHR_after(commandBuffer, pPushDescriptorSetInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushDescriptorSet2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPushDescriptorSetWithTemplate2KHR!");
}
#ifdef CMDPUSHDESCRIPTORSETWITHTEMPLATE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetWithTemplate2KHR_before(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pPushDescriptorSetWithTemplateInfo != VK_NULL_HANDLE && pPushDescriptorSetWithTemplateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetWithTemplateInfo->descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(pPushDescriptorSetWithTemplateInfo->descriptorUpdateTemplate)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetWithTemplateInfo->layout=" + ptrToString((void**)std::addressof(pPushDescriptorSetWithTemplateInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pPushDescriptorSetWithTemplateInfo->set=" + std::to_string(pPushDescriptorSetWithTemplateInfo->set) + '!');
}else winsockSendToUI(&ConnectSocket, "pPushDescriptorSetWithTemplateInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPUSHDESCRIPTORSETWITHTEMPLATE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPushDescriptorSetWithTemplate2KHR_after(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPushDescriptorSetWithTemplate2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDescriptorBufferOffsets2EXT!");
}
#ifdef CMDSETDESCRIPTORBUFFEROFFSETS2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDescriptorBufferOffsets2EXT_before(commandBuffer, pSetDescriptorBufferOffsetsInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSetDescriptorBufferOffsetsInfo != VK_NULL_HANDLE && pSetDescriptorBufferOffsetsInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSetDescriptorBufferOffsetsInfo->stageFlags=" + ptrToString((void**)std::addressof(pSetDescriptorBufferOffsetsInfo->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pSetDescriptorBufferOffsetsInfo->layout=" + ptrToString((void**)std::addressof(pSetDescriptorBufferOffsetsInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pSetDescriptorBufferOffsetsInfo->firstSet=" + std::to_string(pSetDescriptorBufferOffsetsInfo->firstSet) + '!');
winsockSendToUI(&ConnectSocket,"pSetDescriptorBufferOffsetsInfo->setCount=" + std::to_string(pSetDescriptorBufferOffsetsInfo->setCount) + '!');
winsockSendToUI(&ConnectSocket,"pSetDescriptorBufferOffsetsInfo->pOffsets=" + ptrToString((void**)std::addressof(pSetDescriptorBufferOffsetsInfo->pOffsets)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSetDescriptorBufferOffsetsInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETDESCRIPTORBUFFEROFFSETS2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDescriptorBufferOffsets2EXT_after(commandBuffer, pSetDescriptorBufferOffsetsInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDescriptorBufferOffsets2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT!");
}
#ifdef CMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERS2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBufferEmbeddedSamplers2EXT_before(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBindDescriptorBufferEmbeddedSamplersInfo != VK_NULL_HANDLE && pBindDescriptorBufferEmbeddedSamplersInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBindDescriptorBufferEmbeddedSamplersInfo->stageFlags=" + ptrToString((void**)std::addressof(pBindDescriptorBufferEmbeddedSamplersInfo->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorBufferEmbeddedSamplersInfo->layout=" + ptrToString((void**)std::addressof(pBindDescriptorBufferEmbeddedSamplersInfo->layout)) + '!');
winsockSendToUI(&ConnectSocket,"pBindDescriptorBufferEmbeddedSamplersInfo->set=" + std::to_string(pBindDescriptorBufferEmbeddedSamplersInfo->set) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindDescriptorBufferEmbeddedSamplersInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBINDDESCRIPTORBUFFEREMBEDDEDSAMPLERS2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindDescriptorBufferEmbeddedSamplers2EXT_after(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, VkLatencySleepModeInfoNV* pSleepModeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetLatencySleepModeNV!");
}
#ifdef SETLATENCYSLEEPMODENV_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetLatencySleepModeNV_before(device, swapchain, pSleepModeInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetLatencySleepModeNV(device, swapchain, pSleepModeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pSleepModeInfo != VK_NULL_HANDLE && pSleepModeInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSleepModeInfo->lowLatencyMode=" + bool_as_text(pSleepModeInfo->lowLatencyMode) + '!');
winsockSendToUI(&ConnectSocket,"pSleepModeInfo->lowLatencyBoost=" + bool_as_text(pSleepModeInfo->lowLatencyBoost) + '!');
winsockSendToUI(&ConnectSocket,"pSleepModeInfo->minimumIntervalUs=" + std::to_string(pSleepModeInfo->minimumIntervalUs) + '!');
}else winsockSendToUI(&ConnectSocket, "pSleepModeInfo=VK_NULL_HANDLE!");
}
#ifdef SETLATENCYSLEEPMODENV_AFTER_EXEC_EXISTS
if(connected) {
layer_SetLatencySleepModeNV_after(device, swapchain, pSleepModeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetLatencySleepModeNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetLatencySleepModeNV(device, swapchain, pSleepModeInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, VkLatencySleepInfoNV* pSleepInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkLatencySleepNV!");
}
#ifdef LATENCYSLEEPNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_LatencySleepNV_before(device, swapchain, pSleepInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].LatencySleepNV(device, swapchain, pSleepInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pSleepInfo != VK_NULL_HANDLE && pSleepInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSleepInfo->signalSemaphore=" + ptrToString((void**)std::addressof(pSleepInfo->signalSemaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSleepInfo->value=" + std::to_string(pSleepInfo->value) + '!');
}else winsockSendToUI(&ConnectSocket, "pSleepInfo=VK_NULL_HANDLE!");
}
#ifdef LATENCYSLEEPNV_AFTER_EXEC_EXISTS
if(connected) {
layer_LatencySleepNV_after(device, swapchain, pSleepInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkLatencySleepNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].LatencySleepNV(device, swapchain, pSleepInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, VkSetLatencyMarkerInfoNV* pLatencyMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetLatencyMarkerNV!");
}
#ifdef SETLATENCYMARKERNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetLatencyMarkerNV_before(device, swapchain, pLatencyMarkerInfo);
}
#endif 
device_dispatch[GetKey(device)].SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pLatencyMarkerInfo != VK_NULL_HANDLE && pLatencyMarkerInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pLatencyMarkerInfo->presentID=" + std::to_string(pLatencyMarkerInfo->presentID) + '!');
}else winsockSendToUI(&ConnectSocket, "pLatencyMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef SETLATENCYMARKERNV_AFTER_EXEC_EXISTS
if(connected) {
layer_SetLatencyMarkerNV_after(device, swapchain, pLatencyMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetLatencyMarkerNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].SetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV* pLatencyMarkerInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetLatencyTimingsNV!");
}
#ifdef GETLATENCYTIMINGSNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetLatencyTimingsNV_before(device, swapchain, pLatencyMarkerInfo);
}
#endif 
device_dispatch[GetKey(device)].GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"swapchain=" + ptrToString((void**)std::addressof(swapchain)) + '!');
if(pLatencyMarkerInfo != VK_NULL_HANDLE && pLatencyMarkerInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pLatencyMarkerInfo->timingCount=" + std::to_string(pLatencyMarkerInfo->timingCount) + '!');
winsockSendToUI(&ConnectSocket,"pLatencyMarkerInfo->pTimings=" + ptrToString((void**)std::addressof(pLatencyMarkerInfo->pTimings)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLatencyMarkerInfo=VK_NULL_HANDLE!");
}
#ifdef GETLATENCYTIMINGSNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetLatencyTimingsNV_after(device, swapchain, pLatencyMarkerInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetLatencyTimingsNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_QueueNotifyOutOfBandNV(VkQueue queue, VkOutOfBandQueueTypeInfoNV* pQueueTypeInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueNotifyOutOfBandNV!");
}
#ifdef QUEUENOTIFYOUTOFBANDNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueNotifyOutOfBandNV_before(queue, pQueueTypeInfo);
}
#endif 
device_dispatch[GetKey(queue)].QueueNotifyOutOfBandNV(queue, pQueueTypeInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
if(pQueueTypeInfo != VK_NULL_HANDLE && pQueueTypeInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pQueueTypeInfo=VK_NULL_HANDLE!");
}
#ifdef QUEUENOTIFYOUTOFBANDNV_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueNotifyOutOfBandNV_after(queue, pQueueTypeInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueNotifyOutOfBandNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(queue)].QueueNotifyOutOfBandNV(queue, pQueueTypeInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkResetQueryPoolEXT!");
}
#ifdef RESETQUERYPOOLEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_ResetQueryPoolEXT_before(device, queryPool, firstQuery, queryCount);
}
#endif 
device_dispatch[GetKey(device)].ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"firstQuery=" + std::to_string(firstQuery) + '!');
winsockSendToUI(&ConnectSocket,"queryCount=" + std::to_string(queryCount) + '!');
}
#ifdef RESETQUERYPOOLEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_ResetQueryPoolEXT_after(device, queryPool, firstQuery, queryCount);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkResetQueryPoolEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].ResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkTrimCommandPoolKHR!");
}
#ifdef TRIMCOMMANDPOOLKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_TrimCommandPoolKHR_before(device, commandPool, flags);
}
#endif 
device_dispatch[GetKey(device)].TrimCommandPoolKHR(device, commandPool, flags);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"commandPool=" + ptrToString((void**)std::addressof(commandPool)) + '!');
winsockSendToUI(&ConnectSocket,"flags=" + ptrToString((void**)std::addressof(flags)) + '!');
}
#ifdef TRIMCOMMANDPOOLKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_TrimCommandPoolKHR_after(device, commandPool, flags);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkTrimCommandPoolKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].TrimCommandPoolKHR(device, commandPool, flags);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceGroupPeerMemoryFeaturesKHR!");
}
#ifdef GETDEVICEGROUPPEERMEMORYFEATURESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPeerMemoryFeaturesKHR_before(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"heapIndex=" + std::to_string(heapIndex) + '!');
winsockSendToUI(&ConnectSocket,"localDeviceIndex=" + std::to_string(localDeviceIndex) + '!');
winsockSendToUI(&ConnectSocket,"remoteDeviceIndex=" + std::to_string(remoteDeviceIndex) + '!');
winsockSendToUI(&ConnectSocket,"pPeerMemoryFeatures=" + ptrToString((void**)std::addressof(pPeerMemoryFeatures)) + '!');
}
#ifdef GETDEVICEGROUPPEERMEMORYFEATURESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceGroupPeerMemoryFeaturesKHR_after(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceGroupPeerMemoryFeaturesKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, VkBindBufferMemoryInfo* pBindInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindBufferMemory2KHR!");
}
#ifdef BINDBUFFERMEMORY2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory2KHR_before(device, bindInfoCount, pBindInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfos != VK_NULL_HANDLE && pBindInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfos->buffer=" + ptrToString((void**)std::addressof(pBindInfos->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memory=" + ptrToString((void**)std::addressof(pBindInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memoryOffset=" + std::to_string(pBindInfos->memoryOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfos=VK_NULL_HANDLE!");
}
#ifdef BINDBUFFERMEMORY2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_BindBufferMemory2KHR_after(device, bindInfoCount, pBindInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindBufferMemory2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, VkBindImageMemoryInfo* pBindInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkBindImageMemory2KHR!");
}
#ifdef BINDIMAGEMEMORY2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_BindImageMemory2KHR_before(device, bindInfoCount, pBindInfos);
}
#endif 
auto ret = device_dispatch[GetKey(device)].BindImageMemory2KHR(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"bindInfoCount=" + std::to_string(bindInfoCount) + '!');
if(pBindInfos != VK_NULL_HANDLE && pBindInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pBindInfos->image=" + ptrToString((void**)std::addressof(pBindInfos->image)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memory=" + ptrToString((void**)std::addressof(pBindInfos->memory)) + '!');
winsockSendToUI(&ConnectSocket,"pBindInfos->memoryOffset=" + std::to_string(pBindInfos->memoryOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindInfos=VK_NULL_HANDLE!");
}
#ifdef BINDIMAGEMEMORY2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_BindImageMemory2KHR_after(device, bindInfoCount, pBindInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkBindImageMemory2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].BindImageMemory2KHR(device, bindInfoCount, pBindInfos);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDeviceMaskKHR!");
}
#ifdef CMDSETDEVICEMASKKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDeviceMaskKHR_before(commandBuffer, deviceMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDeviceMaskKHR(commandBuffer, deviceMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"deviceMask=" + std::to_string(deviceMask) + '!');
}
#ifdef CMDSETDEVICEMASKKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDeviceMaskKHR_after(commandBuffer, deviceMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDeviceMaskKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDeviceMaskKHR(commandBuffer, deviceMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDispatchBaseKHR!");
}
#ifdef CMDDISPATCHBASEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDispatchBaseKHR_before(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupX=" + std::to_string(baseGroupX) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupY=" + std::to_string(baseGroupY) + '!');
winsockSendToUI(&ConnectSocket,"baseGroupZ=" + std::to_string(baseGroupZ) + '!');
winsockSendToUI(&ConnectSocket,"groupCountX=" + std::to_string(groupCountX) + '!');
winsockSendToUI(&ConnectSocket,"groupCountY=" + std::to_string(groupCountY) + '!');
winsockSendToUI(&ConnectSocket,"groupCountZ=" + std::to_string(groupCountZ) + '!');
}
#ifdef CMDDISPATCHBASEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDispatchBaseKHR_after(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDispatchBaseKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateDescriptorUpdateTemplateKHR!");
}
#ifdef CREATEDESCRIPTORUPDATETEMPLATEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorUpdateTemplateKHR_before(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->descriptorUpdateEntryCount=" + std::to_string(pCreateInfo->descriptorUpdateEntryCount) + '!');
if(pCreateInfo->pDescriptorUpdateEntries != VK_NULL_HANDLE && pCreateInfo->pDescriptorUpdateEntries != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->dstBinding=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->dstBinding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->dstArrayElement=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->dstArrayElement) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->descriptorCount=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->descriptorCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->offset=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->offset) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDescriptorUpdateEntries->stride=" + std::to_string(pCreateInfo->pDescriptorUpdateEntries->stride) + '!');
}else winsockSendToUI(&ConnectSocket, "pDescriptorUpdateEntries=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->descriptorSetLayout=" + ptrToString((void**)std::addressof(pCreateInfo->descriptorSetLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pipelineLayout=" + ptrToString((void**)std::addressof(pCreateInfo->pipelineLayout)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->set=" + std::to_string(pCreateInfo->set) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDescriptorUpdateTemplate=" + ptrToString((void**)std::addressof(pDescriptorUpdateTemplate)) + '!');
}
#ifdef CREATEDESCRIPTORUPDATETEMPLATEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateDescriptorUpdateTemplateKHR_after(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateDescriptorUpdateTemplateKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyDescriptorUpdateTemplateKHR!");
}
#ifdef DESTROYDESCRIPTORUPDATETEMPLATEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorUpdateTemplateKHR_before(device, descriptorUpdateTemplate, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(descriptorUpdateTemplate)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYDESCRIPTORUPDATETEMPLATEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyDescriptorUpdateTemplateKHR_after(device, descriptorUpdateTemplate, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyDescriptorUpdateTemplateKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkUpdateDescriptorSetWithTemplateKHR!");
}
#ifdef UPDATEDESCRIPTORSETWITHTEMPLATEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSetWithTemplateKHR_before(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif 
device_dispatch[GetKey(device)].UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorSet=" + ptrToString((void**)std::addressof(descriptorSet)) + '!');
winsockSendToUI(&ConnectSocket,"descriptorUpdateTemplate=" + ptrToString((void**)std::addressof(descriptorUpdateTemplate)) + '!');
}
#ifdef UPDATEDESCRIPTORSETWITHTEMPLATEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_UpdateDescriptorSetWithTemplateKHR_after(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkUpdateDescriptorSetWithTemplateKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].UpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetBufferMemoryRequirements2KHR(VkDevice device, VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferMemoryRequirements2KHR!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements2KHR_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERMEMORYREQUIREMENTS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferMemoryRequirements2KHR_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferMemoryRequirements2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageMemoryRequirements2KHR(VkDevice device, VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageMemoryRequirements2KHR!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements2KHR_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->image=" + ptrToString((void**)std::addressof(pInfo->image)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGEMEMORYREQUIREMENTS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageMemoryRequirements2KHR_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageMemoryRequirements2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSparseMemoryRequirements2KHR(VkDevice device, VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSparseMemoryRequirements2KHR!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements2KHR_before(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->image=" + ptrToString((void**)std::addressof(pInfo->image)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pSparseMemoryRequirements != VK_NULL_HANDLE && pSparseMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pSparseMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSparseMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESPARSEMEMORYREQUIREMENTS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSparseMemoryRequirements2KHR_after(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSparseMemoryRequirements2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceBufferMemoryRequirementsKHR(VkDevice device, VkDeviceBufferMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceBufferMemoryRequirementsKHR!");
}
#ifdef GETDEVICEBUFFERMEMORYREQUIREMENTSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceBufferMemoryRequirementsKHR_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->size=" + std::to_string(pInfo->pCreateInfo->size) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEBUFFERMEMORYREQUIREMENTSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceBufferMemoryRequirementsKHR_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceBufferMemoryRequirementsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceImageMemoryRequirementsKHR(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, VkMemoryRequirements2* pMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceImageMemoryRequirementsKHR!");
}
#ifdef GETDEVICEIMAGEMEMORYREQUIREMENTSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageMemoryRequirementsKHR_before(device, pInfo, pMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->extent=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->mipLevels=" + std::to_string(pInfo->pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->arrayLayers=" + std::to_string(pInfo->pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pMemoryRequirements != VK_NULL_HANDLE && pMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEIMAGEMEMORYREQUIREMENTSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageMemoryRequirementsKHR_after(device, pInfo, pMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceImageMemoryRequirementsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, VkDeviceImageMemoryRequirements* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceImageSparseMemoryRequirementsKHR!");
}
#ifdef GETDEVICEIMAGESPARSEMEMORYREQUIREMENTSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSparseMemoryRequirementsKHR_before(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
device_dispatch[GetKey(device)].GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
if(pInfo->pCreateInfo != VK_NULL_HANDLE && pInfo->pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->flags=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->extent=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->extent)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->mipLevels=" + std::to_string(pInfo->pCreateInfo->mipLevels) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->arrayLayers=" + std::to_string(pInfo->pCreateInfo->arrayLayers) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->usage=" + ptrToString((void**)std::addressof(pInfo->pCreateInfo->usage)) + '!');
winsockSendToUI(&ConnectSocket,"pInfo->pCreateInfo->queueFamilyIndexCount=" + std::to_string(pInfo->pCreateInfo->queueFamilyIndexCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
if(pSparseMemoryRequirements != VK_NULL_HANDLE && pSparseMemoryRequirements != NULL) {
winsockSendToUI(&ConnectSocket,"pSparseMemoryRequirements->memoryRequirements=" + ptrToString((void**)std::addressof(pSparseMemoryRequirements->memoryRequirements)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSparseMemoryRequirements=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEIMAGESPARSEMEMORYREQUIREMENTSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceImageSparseMemoryRequirementsKHR_after(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceImageSparseMemoryRequirementsKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateSamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversionCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateSamplerYcbcrConversionKHR!");
}
#ifdef CREATESAMPLERYCBCRCONVERSIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateSamplerYcbcrConversionKHR_before(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->components=" + ptrToString((void**)std::addressof(pCreateInfo->components)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->forceExplicitReconstruction=" + bool_as_text(pCreateInfo->forceExplicitReconstruction) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pYcbcrConversion=" + ptrToString((void**)std::addressof(pYcbcrConversion)) + '!');
}
#ifdef CREATESAMPLERYCBCRCONVERSIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateSamplerYcbcrConversionKHR_after(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateSamplerYcbcrConversionKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroySamplerYcbcrConversionKHR!");
}
#ifdef DESTROYSAMPLERYCBCRCONVERSIONKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroySamplerYcbcrConversionKHR_before(device, ycbcrConversion, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"ycbcrConversion=" + ptrToString((void**)std::addressof(ycbcrConversion)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYSAMPLERYCBCRCONVERSIONKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroySamplerYcbcrConversionKHR_after(device, ycbcrConversion, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroySamplerYcbcrConversionKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetDescriptorSetLayoutSupportKHR(VkDevice device, VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDescriptorSetLayoutSupportKHR!");
}
#ifdef GETDESCRIPTORSETLAYOUTSUPPORTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSupportKHR_before(device, pCreateInfo, pSupport);
}
#endif 
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->bindingCount=" + std::to_string(pCreateInfo->bindingCount) + '!');
if(pCreateInfo->pBindings != VK_NULL_HANDLE && pCreateInfo->pBindings != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->binding=" + std::to_string(pCreateInfo->pBindings->binding) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->descriptorCount=" + std::to_string(pCreateInfo->pBindings->descriptorCount) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->stageFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->stageFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pBindings->pImmutableSamplers=" + ptrToString((void**)std::addressof(pCreateInfo->pBindings->pImmutableSamplers)) + '!');
}else winsockSendToUI(&ConnectSocket, "pBindings=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pSupport != VK_NULL_HANDLE && pSupport != NULL) {
winsockSendToUI(&ConnectSocket,"pSupport->supported=" + bool_as_text(pSupport->supported) + '!');
}else winsockSendToUI(&ConnectSocket, "pSupport=VK_NULL_HANDLE!");
}
#ifdef GETDESCRIPTORSETLAYOUTSUPPORTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDescriptorSetLayoutSupportKHR_after(device, pCreateInfo, pSupport);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDescriptorSetLayoutSupportKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetCalibratedTimestampsEXT!");
}
#ifdef GETCALIBRATEDTIMESTAMPSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetCalibratedTimestampsEXT_before(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"timestampCount=" + std::to_string(timestampCount) + '!');
if(pTimestampInfos != VK_NULL_HANDLE && pTimestampInfos != NULL) {
}else winsockSendToUI(&ConnectSocket, "pTimestampInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pTimestamps=" + ptrToString((void**)std::addressof(pTimestamps)) + '!');
winsockSendToUI(&ConnectSocket,"pMaxDeviation=" + ptrToString((void**)std::addressof(pMaxDeviation)) + '!');
}
#ifdef GETCALIBRATEDTIMESTAMPSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetCalibratedTimestampsEXT_after(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetCalibratedTimestampsEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreateRenderPass2KHR(VkDevice device, VkRenderPassCreateInfo2* pCreateInfo, VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreateRenderPass2KHR!");
}
#ifdef CREATERENDERPASS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass2KHR_before(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->attachmentCount=" + std::to_string(pCreateInfo->attachmentCount) + '!');
if(pCreateInfo->pAttachments != VK_NULL_HANDLE && pCreateInfo->pAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pAttachments->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pAttachments->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->subpassCount=" + std::to_string(pCreateInfo->subpassCount) + '!');
if(pCreateInfo->pSubpasses != VK_NULL_HANDLE && pCreateInfo->pSubpasses != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->flags=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->viewMask=" + std::to_string(pCreateInfo->pSubpasses->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->inputAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->inputAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pInputAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pInputAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pInputAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pInputAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pInputAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pInputAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInputAttachments=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->colorAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->colorAttachmentCount) + '!');
if(pCreateInfo->pSubpasses->pColorAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pColorAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pColorAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pColorAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pColorAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pResolveAttachments != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pResolveAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pResolveAttachments->attachment=" + std::to_string(pCreateInfo->pSubpasses->pResolveAttachments->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pResolveAttachments->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pResolveAttachments->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pResolveAttachments=VK_NULL_HANDLE!");
if(pCreateInfo->pSubpasses->pDepthStencilAttachment != VK_NULL_HANDLE && pCreateInfo->pSubpasses->pDepthStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment=" + std::to_string(pCreateInfo->pSubpasses->pDepthStencilAttachment->attachment) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->pDepthStencilAttachment->aspectMask=" + ptrToString((void**)std::addressof(pCreateInfo->pSubpasses->pDepthStencilAttachment->aspectMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthStencilAttachment=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->pSubpasses->preserveAttachmentCount=" + std::to_string(pCreateInfo->pSubpasses->preserveAttachmentCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubpasses=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->dependencyCount=" + std::to_string(pCreateInfo->dependencyCount) + '!');
if(pCreateInfo->pDependencies != VK_NULL_HANDLE && pCreateInfo->pDependencies != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcSubpass=" + std::to_string(pCreateInfo->pDependencies->srcSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstSubpass=" + std::to_string(pCreateInfo->pDependencies->dstSubpass) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstStageMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->srcAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dstAccessMask=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->dependencyFlags=" + ptrToString((void**)std::addressof(pCreateInfo->pDependencies->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pCreateInfo->pDependencies->viewOffset=" + std::to_string(pCreateInfo->pDependencies->viewOffset) + '!');
}else winsockSendToUI(&ConnectSocket, "pDependencies=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pCreateInfo->correlatedViewMaskCount=" + std::to_string(pCreateInfo->correlatedViewMaskCount) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pRenderPass=" + ptrToString((void**)std::addressof(pRenderPass)) + '!');
}
#ifdef CREATERENDERPASS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CreateRenderPass2KHR_after(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreateRenderPass2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassBeginInfo* pSubpassBeginInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginRenderPass2KHR!");
}
#ifdef CMDBEGINRENDERPASS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass2KHR_before(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRenderPassBegin != VK_NULL_HANDLE && pRenderPassBegin != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderPass=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderPass)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->framebuffer=" + ptrToString((void**)std::addressof(pRenderPassBegin->framebuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->renderArea=" + ptrToString((void**)std::addressof(pRenderPassBegin->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->clearValueCount=" + std::to_string(pRenderPassBegin->clearValueCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderPassBegin->pClearValues=" + ptrToString((void**)std::addressof(pRenderPassBegin->pClearValues)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRenderPassBegin=VK_NULL_HANDLE!");
if(pSubpassBeginInfo != VK_NULL_HANDLE && pSubpassBeginInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassBeginInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINRENDERPASS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderPass2KHR_after(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginRenderPass2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, VkSubpassBeginInfo* pSubpassBeginInfo, VkSubpassEndInfo* pSubpassEndInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdNextSubpass2KHR!");
}
#ifdef CMDNEXTSUBPASS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass2KHR_before(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSubpassBeginInfo != VK_NULL_HANDLE && pSubpassBeginInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassBeginInfo=VK_NULL_HANDLE!");
if(pSubpassEndInfo != VK_NULL_HANDLE && pSubpassEndInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassEndInfo=VK_NULL_HANDLE!");
}
#ifdef CMDNEXTSUBPASS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdNextSubpass2KHR_after(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdNextSubpass2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, VkSubpassEndInfo* pSubpassEndInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndRenderPass2KHR!");
}
#ifdef CMDENDRENDERPASS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass2KHR_before(commandBuffer, pSubpassEndInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pSubpassEndInfo != VK_NULL_HANDLE && pSubpassEndInfo != NULL) {
}else winsockSendToUI(&ConnectSocket, "pSubpassEndInfo=VK_NULL_HANDLE!");
}
#ifdef CMDENDRENDERPASS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderPass2KHR_after(commandBuffer, pSubpassEndInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndRenderPass2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t* pValue) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetSemaphoreCounterValueKHR!");
}
#ifdef GETSEMAPHORECOUNTERVALUEKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreCounterValueKHR_before(device, semaphore, pValue);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetSemaphoreCounterValueKHR(device, semaphore, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"semaphore=" + ptrToString((void**)std::addressof(semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pValue=" + ptrToString((void**)std::addressof(pValue)) + '!');
}
#ifdef GETSEMAPHORECOUNTERVALUEKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetSemaphoreCounterValueKHR_after(device, semaphore, pValue);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetSemaphoreCounterValueKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetSemaphoreCounterValueKHR(device, semaphore, pValue);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_WaitSemaphoresKHR(VkDevice device, VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkWaitSemaphoresKHR!");
}
#ifdef WAITSEMAPHORESKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_WaitSemaphoresKHR_before(device, pWaitInfo, timeout);
}
#endif 
auto ret = device_dispatch[GetKey(device)].WaitSemaphoresKHR(device, pWaitInfo, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pWaitInfo != VK_NULL_HANDLE && pWaitInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pWaitInfo->flags=" + ptrToString((void**)std::addressof(pWaitInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->semaphoreCount=" + std::to_string(pWaitInfo->semaphoreCount) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->pSemaphores=" + ptrToString((void**)std::addressof(pWaitInfo->pSemaphores)) + '!');
winsockSendToUI(&ConnectSocket,"pWaitInfo->pValues=" + ptrToString((void**)std::addressof(pWaitInfo->pValues)) + '!');
}else winsockSendToUI(&ConnectSocket, "pWaitInfo=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"timeout=" + std::to_string(timeout) + '!');
}
#ifdef WAITSEMAPHORESKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_WaitSemaphoresKHR_after(device, pWaitInfo, timeout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkWaitSemaphoresKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].WaitSemaphoresKHR(device, pWaitInfo, timeout);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SignalSemaphoreKHR(VkDevice device, VkSemaphoreSignalInfo* pSignalInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSignalSemaphoreKHR!");
}
#ifdef SIGNALSEMAPHOREKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_SignalSemaphoreKHR_before(device, pSignalInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SignalSemaphoreKHR(device, pSignalInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pSignalInfo != VK_NULL_HANDLE && pSignalInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pSignalInfo->semaphore=" + ptrToString((void**)std::addressof(pSignalInfo->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSignalInfo->value=" + std::to_string(pSignalInfo->value) + '!');
}else winsockSendToUI(&ConnectSocket, "pSignalInfo=VK_NULL_HANDLE!");
}
#ifdef SIGNALSEMAPHOREKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_SignalSemaphoreKHR_after(device, pSignalInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSignalSemaphoreKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SignalSemaphoreKHR(device, pSignalInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndirectCountKHR!");
}
#ifdef CMDDRAWINDIRECTCOUNTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCountKHR_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDIRECTCOUNTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCountKHR_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndirectCountKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndirectCountAMD!");
}
#ifdef CMDDRAWINDIRECTCOUNTAMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCountAMD_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDIRECTCOUNTAMD_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndirectCountAMD_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndirectCountAMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndexedIndirectCountKHR!");
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNTKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCountKHR_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNTKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCountKHR_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndexedIndirectCountKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdDrawIndexedIndirectCountAMD!");
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNTAMD_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCountAMD_before(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"buffer=" + ptrToString((void**)std::addressof(buffer)) + '!');
winsockSendToUI(&ConnectSocket,"offset=" + std::to_string(offset) + '!');
winsockSendToUI(&ConnectSocket,"countBuffer=" + ptrToString((void**)std::addressof(countBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"countBufferOffset=" + std::to_string(countBufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"maxDrawCount=" + std::to_string(maxDrawCount) + '!');
winsockSendToUI(&ConnectSocket,"stride=" + std::to_string(stride) + '!');
}
#ifdef CMDDRAWINDEXEDINDIRECTCOUNTAMD_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdDrawIndexedIndirectCountAMD_after(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdDrawIndexedIndirectCountAMD!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetRayTracingShaderGroupHandlesNV!");
}
#ifdef GETRAYTRACINGSHADERGROUPHANDLESNV_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupHandlesNV_before(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"pipeline=" + ptrToString((void**)std::addressof(pipeline)) + '!');
winsockSendToUI(&ConnectSocket,"firstGroup=" + std::to_string(firstGroup) + '!');
winsockSendToUI(&ConnectSocket,"groupCount=" + std::to_string(groupCount) + '!');
winsockSendToUI(&ConnectSocket,"dataSize=" + std::to_string(dataSize) + '!');
}
#ifdef GETRAYTRACINGSHADERGROUPHANDLESNV_AFTER_EXEC_EXISTS
if(connected) {
layer_GetRayTracingShaderGroupHandlesNV_after(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetRayTracingShaderGroupHandlesNV!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT uint64_t VKAPI_CALL DebuggerLayer_GetBufferOpaqueCaptureAddressKHR(VkDevice device, VkBufferDeviceAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferOpaqueCaptureAddressKHR!");
}
#ifdef GETBUFFEROPAQUECAPTUREADDRESSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureAddressKHR_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFEROPAQUECAPTUREADDRESSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferOpaqueCaptureAddressKHR_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferOpaqueCaptureAddressKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferOpaqueCaptureAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkDeviceAddress VKAPI_CALL DebuggerLayer_GetBufferDeviceAddressKHR(VkDevice device, VkBufferDeviceAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferDeviceAddressKHR!");
}
#ifdef GETBUFFERDEVICEADDRESSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddressKHR_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERDEVICEADDRESSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddressKHR_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferDeviceAddressKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT VkDeviceAddress VKAPI_CALL DebuggerLayer_GetBufferDeviceAddressEXT(VkDevice device, VkBufferDeviceAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetBufferDeviceAddressEXT!");
}
#ifdef GETBUFFERDEVICEADDRESSEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddressEXT_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddressEXT(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->buffer=" + ptrToString((void**)std::addressof(pInfo->buffer)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETBUFFERDEVICEADDRESSEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetBufferDeviceAddressEXT_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetBufferDeviceAddressEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetBufferDeviceAddressEXT(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT uint64_t VKAPI_CALL DebuggerLayer_GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, VkDeviceMemoryOpaqueCaptureAddressInfo* pInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetDeviceMemoryOpaqueCaptureAddressKHR!");
}
#ifdef GETDEVICEMEMORYOPAQUECAPTUREADDRESSKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryOpaqueCaptureAddressKHR_before(device, pInfo);
}
#endif 
auto ret = device_dispatch[GetKey(device)].GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pInfo != VK_NULL_HANDLE && pInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pInfo->memory=" + ptrToString((void**)std::addressof(pInfo->memory)) + '!');
}else winsockSendToUI(&ConnectSocket, "pInfo=VK_NULL_HANDLE!");
}
#ifdef GETDEVICEMEMORYOPAQUECAPTUREADDRESSKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_GetDeviceMemoryOpaqueCaptureAddressKHR_after(device, pInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetDeviceMemoryOpaqueCaptureAddressKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].GetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetLineStippleEXT!");
}
#ifdef CMDSETLINESTIPPLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetLineStippleEXT_before(commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"lineStippleFactor=" + std::to_string(lineStippleFactor) + '!');
winsockSendToUI(&ConnectSocket,"lineStipplePattern=" + ptrToString((void**)std::addressof(lineStipplePattern)) + '!');
}
#ifdef CMDSETLINESTIPPLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetLineStippleEXT_after(commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetLineStippleEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetCullModeEXT!");
}
#ifdef CMDSETCULLMODEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetCullModeEXT_before(commandBuffer, cullMode);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetCullModeEXT(commandBuffer, cullMode);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"cullMode=" + ptrToString((void**)std::addressof(cullMode)) + '!');
}
#ifdef CMDSETCULLMODEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetCullModeEXT_after(commandBuffer, cullMode);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetCullModeEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetCullModeEXT(commandBuffer, cullMode);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetFrontFaceEXT!");
}
#ifdef CMDSETFRONTFACEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetFrontFaceEXT_before(commandBuffer, frontFace);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetFrontFaceEXT(commandBuffer, frontFace);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETFRONTFACEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetFrontFaceEXT_after(commandBuffer, frontFace);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetFrontFaceEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetFrontFaceEXT(commandBuffer, frontFace);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPrimitiveTopologyEXT!");
}
#ifdef CMDSETPRIMITIVETOPOLOGYEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveTopologyEXT_before(commandBuffer, primitiveTopology);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETPRIMITIVETOPOLOGYEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveTopologyEXT_after(commandBuffer, primitiveTopology);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPrimitiveTopologyEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, VkViewport* pViewports) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetViewportWithCountEXT!");
}
#ifdef CMDSETVIEWPORTWITHCOUNTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWithCountEXT_before(commandBuffer, viewportCount, pViewports);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"viewportCount=" + std::to_string(viewportCount) + '!');
if(pViewports != VK_NULL_HANDLE && pViewports != NULL) {
winsockSendToUI(&ConnectSocket,"pViewports->x=" + std::to_string(pViewports->x) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->y=" + std::to_string(pViewports->y) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->width=" + std::to_string(pViewports->width) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->height=" + std::to_string(pViewports->height) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->minDepth=" + std::to_string(pViewports->minDepth) + '!');
winsockSendToUI(&ConnectSocket,"pViewports->maxDepth=" + std::to_string(pViewports->maxDepth) + '!');
}else winsockSendToUI(&ConnectSocket, "pViewports=VK_NULL_HANDLE!");
}
#ifdef CMDSETVIEWPORTWITHCOUNTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetViewportWithCountEXT_after(commandBuffer, viewportCount, pViewports);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetViewportWithCountEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, VkRect2D* pScissors) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetScissorWithCountEXT!");
}
#ifdef CMDSETSCISSORWITHCOUNTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetScissorWithCountEXT_before(commandBuffer, scissorCount, pScissors);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"scissorCount=" + std::to_string(scissorCount) + '!');
if(pScissors != VK_NULL_HANDLE && pScissors != NULL) {
winsockSendToUI(&ConnectSocket,"pScissors->offset=" + ptrToString((void**)std::addressof(pScissors->offset)) + '!');
winsockSendToUI(&ConnectSocket,"pScissors->extent=" + ptrToString((void**)std::addressof(pScissors->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pScissors=VK_NULL_HANDLE!");
}
#ifdef CMDSETSCISSORWITHCOUNTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetScissorWithCountEXT_after(commandBuffer, scissorCount, pScissors);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetScissorWithCountEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer* pBuffers, VkDeviceSize* pOffsets, VkDeviceSize* pSizes, VkDeviceSize* pStrides) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBindVertexBuffers2EXT!");
}
#ifdef CMDBINDVERTEXBUFFERS2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers2EXT_before(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"firstBinding=" + std::to_string(firstBinding) + '!');
winsockSendToUI(&ConnectSocket,"bindingCount=" + std::to_string(bindingCount) + '!');
winsockSendToUI(&ConnectSocket,"pBuffers=" + ptrToString((void**)std::addressof(pBuffers)) + '!');
winsockSendToUI(&ConnectSocket,"pOffsets=" + ptrToString((void**)std::addressof(pOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pSizes=" + ptrToString((void**)std::addressof(pSizes)) + '!');
winsockSendToUI(&ConnectSocket,"pStrides=" + ptrToString((void**)std::addressof(pStrides)) + '!');
}
#ifdef CMDBINDVERTEXBUFFERS2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBindVertexBuffers2EXT_after(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBindVertexBuffers2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthTestEnableEXT!");
}
#ifdef CMDSETDEPTHTESTENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthTestEnableEXT_before(commandBuffer, depthTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthTestEnable=" + bool_as_text(depthTestEnable) + '!');
}
#ifdef CMDSETDEPTHTESTENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthTestEnableEXT_after(commandBuffer, depthTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthTestEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthWriteEnableEXT!");
}
#ifdef CMDSETDEPTHWRITEENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthWriteEnableEXT_before(commandBuffer, depthWriteEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthWriteEnable=" + bool_as_text(depthWriteEnable) + '!');
}
#ifdef CMDSETDEPTHWRITEENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthWriteEnableEXT_after(commandBuffer, depthWriteEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthWriteEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthCompareOpEXT!");
}
#ifdef CMDSETDEPTHCOMPAREOPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthCompareOpEXT_before(commandBuffer, depthCompareOp);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDSETDEPTHCOMPAREOPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthCompareOpEXT_after(commandBuffer, depthCompareOp);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthCompareOpEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBoundsTestEnableEXT!");
}
#ifdef CMDSETDEPTHBOUNDSTESTENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBoundsTestEnableEXT_before(commandBuffer, depthBoundsTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthBoundsTestEnable=" + bool_as_text(depthBoundsTestEnable) + '!');
}
#ifdef CMDSETDEPTHBOUNDSTESTENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBoundsTestEnableEXT_after(commandBuffer, depthBoundsTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBoundsTestEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilTestEnableEXT!");
}
#ifdef CMDSETSTENCILTESTENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilTestEnableEXT_before(commandBuffer, stencilTestEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stencilTestEnable=" + bool_as_text(stencilTestEnable) + '!');
}
#ifdef CMDSETSTENCILTESTENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilTestEnableEXT_after(commandBuffer, stencilTestEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilTestEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetStencilOpEXT!");
}
#ifdef CMDSETSTENCILOPEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilOpEXT_before(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"faceMask=" + ptrToString((void**)std::addressof(faceMask)) + '!');
}
#ifdef CMDSETSTENCILOPEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetStencilOpEXT_after(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetStencilOpEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetRasterizerDiscardEnableEXT!");
}
#ifdef CMDSETRASTERIZERDISCARDENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizerDiscardEnableEXT_before(commandBuffer, rasterizerDiscardEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"rasterizerDiscardEnable=" + bool_as_text(rasterizerDiscardEnable) + '!');
}
#ifdef CMDSETRASTERIZERDISCARDENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetRasterizerDiscardEnableEXT_after(commandBuffer, rasterizerDiscardEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetRasterizerDiscardEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetDepthBiasEnableEXT!");
}
#ifdef CMDSETDEPTHBIASENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBiasEnableEXT_before(commandBuffer, depthBiasEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"depthBiasEnable=" + bool_as_text(depthBiasEnable) + '!');
}
#ifdef CMDSETDEPTHBIASENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetDepthBiasEnableEXT_after(commandBuffer, depthBiasEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetDepthBiasEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetPrimitiveRestartEnableEXT!");
}
#ifdef CMDSETPRIMITIVERESTARTENABLEEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveRestartEnableEXT_before(commandBuffer, primitiveRestartEnable);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"primitiveRestartEnable=" + bool_as_text(primitiveRestartEnable) + '!');
}
#ifdef CMDSETPRIMITIVERESTARTENABLEEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetPrimitiveRestartEnableEXT_after(commandBuffer, primitiveRestartEnable);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetPrimitiveRestartEnableEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_CreatePrivateDataSlotEXT(VkDevice device, VkPrivateDataSlotCreateInfo* pCreateInfo, VkAllocationCallbacks* pAllocator, VkPrivateDataSlot* pPrivateDataSlot) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCreatePrivateDataSlotEXT!");
}
#ifdef CREATEPRIVATEDATASLOTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_CreatePrivateDataSlotEXT_before(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif 
auto ret = device_dispatch[GetKey(device)].CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
if(pCreateInfo != VK_NULL_HANDLE && pCreateInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCreateInfo->flags=" + ptrToString((void**)std::addressof(pCreateInfo->flags)) + '!');
}else winsockSendToUI(&ConnectSocket, "pCreateInfo=VK_NULL_HANDLE!");
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pPrivateDataSlot=" + ptrToString((void**)std::addressof(pPrivateDataSlot)) + '!');
}
#ifdef CREATEPRIVATEDATASLOTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_CreatePrivateDataSlotEXT_after(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCreatePrivateDataSlotEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].CreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, VkAllocationCallbacks* pAllocator) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkDestroyPrivateDataSlotEXT!");
}
#ifdef DESTROYPRIVATEDATASLOTEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_DestroyPrivateDataSlotEXT_before(device, privateDataSlot, pAllocator);
}
#endif 
device_dispatch[GetKey(device)].DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
if(pAllocator != VK_NULL_HANDLE && pAllocator != NULL) {
winsockSendToUI(&ConnectSocket,"pAllocator->pfnAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnReallocation=" + ptrToString((void**)std::addressof(pAllocator->pfnReallocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnFree=" + ptrToString((void**)std::addressof(pAllocator->pfnFree)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalAllocation=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalAllocation)) + '!');
winsockSendToUI(&ConnectSocket,"pAllocator->pfnInternalFree=" + ptrToString((void**)std::addressof(pAllocator->pfnInternalFree)) + '!');
}else winsockSendToUI(&ConnectSocket, "pAllocator=VK_NULL_HANDLE!");
}
#ifdef DESTROYPRIVATEDATASLOTEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_DestroyPrivateDataSlotEXT_after(device, privateDataSlot, pAllocator);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkDestroyPrivateDataSlotEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].DestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkSetPrivateDataEXT!");
}
#ifdef SETPRIVATEDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_SetPrivateDataEXT_before(device, objectType, objectHandle, privateDataSlot, data);
}
#endif 
auto ret = device_dispatch[GetKey(device)].SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"objectHandle=" + std::to_string(objectHandle) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
winsockSendToUI(&ConnectSocket,"data=" + std::to_string(data) + '!');
}
#ifdef SETPRIVATEDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_SetPrivateDataEXT_after(device, objectType, objectHandle, privateDataSlot, data);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkSetPrivateDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(device)].SetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t* pData) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetPrivateDataEXT!");
}
#ifdef GETPRIVATEDATAEXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetPrivateDataEXT_before(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif 
device_dispatch[GetKey(device)].GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"objectHandle=" + std::to_string(objectHandle) + '!');
winsockSendToUI(&ConnectSocket,"privateDataSlot=" + ptrToString((void**)std::addressof(privateDataSlot)) + '!');
winsockSendToUI(&ConnectSocket,"pData=" + ptrToString((void**)std::addressof(pData)) + '!');
}
#ifdef GETPRIVATEDATAEXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetPrivateDataEXT_after(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetPrivateDataEXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, VkCopyBufferInfo2* pCopyBufferInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBuffer2KHR!");
}
#ifdef CMDCOPYBUFFER2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer2KHR_before(commandBuffer, pCopyBufferInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyBufferInfo != VK_NULL_HANDLE && pCopyBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->srcBuffer=" + ptrToString((void**)std::addressof(pCopyBufferInfo->srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->dstBuffer=" + ptrToString((void**)std::addressof(pCopyBufferInfo->dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->regionCount=" + std::to_string(pCopyBufferInfo->regionCount) + '!');
if(pCopyBufferInfo->pRegions != VK_NULL_HANDLE && pCopyBufferInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->srcOffset=" + std::to_string(pCopyBufferInfo->pRegions->srcOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->dstOffset=" + std::to_string(pCopyBufferInfo->pRegions->dstOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferInfo->pRegions->size=" + std::to_string(pCopyBufferInfo->pRegions->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyBufferInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFER2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBuffer2KHR_after(commandBuffer, pCopyBufferInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBuffer2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImage2KHR(VkCommandBuffer commandBuffer, VkCopyImageInfo2* pCopyImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImage2KHR!");
}
#ifdef CMDCOPYIMAGE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage2KHR_before(commandBuffer, pCopyImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyImageInfo != VK_NULL_HANDLE && pCopyImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->regionCount=" + std::to_string(pCopyImageInfo->regionCount) + '!');
if(pCopyImageInfo->pRegions != VK_NULL_HANDLE && pCopyImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->srcOffset=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->dstOffset=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pCopyImageInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImage2KHR_after(commandBuffer, pCopyImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImage2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBlitImage2KHR(VkCommandBuffer commandBuffer, VkBlitImageInfo2* pBlitImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBlitImage2KHR!");
}
#ifdef CMDBLITIMAGE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage2KHR_before(commandBuffer, pBlitImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pBlitImageInfo != VK_NULL_HANDLE && pBlitImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->srcImage=" + ptrToString((void**)std::addressof(pBlitImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->dstImage=" + ptrToString((void**)std::addressof(pBlitImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->regionCount=" + std::to_string(pBlitImageInfo->regionCount) + '!');
if(pBlitImageInfo->pRegions != VK_NULL_HANDLE && pBlitImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->srcOffsets=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->srcOffsets)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pBlitImageInfo->pRegions->dstOffsets=" + ptrToString((void**)std::addressof(pBlitImageInfo->pRegions->dstOffsets)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pBlitImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBLITIMAGE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBlitImage2KHR_after(commandBuffer, pBlitImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBlitImage2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyBufferToImage2KHR!");
}
#ifdef CMDCOPYBUFFERTOIMAGE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage2KHR_before(commandBuffer, pCopyBufferToImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyBufferToImageInfo != VK_NULL_HANDLE && pCopyBufferToImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->srcBuffer=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->srcBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->dstImage=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->regionCount=" + std::to_string(pCopyBufferToImageInfo->regionCount) + '!');
if(pCopyBufferToImageInfo->pRegions != VK_NULL_HANDLE && pCopyBufferToImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferOffset=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferRowLength=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->bufferImageHeight=" + std::to_string(pCopyBufferToImageInfo->pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyBufferToImageInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyBufferToImageInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyBufferToImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYBUFFERTOIMAGE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyBufferToImage2KHR_after(commandBuffer, pCopyBufferToImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyBufferToImage2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdCopyImageToBuffer2KHR!");
}
#ifdef CMDCOPYIMAGETOBUFFER2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer2KHR_before(commandBuffer, pCopyImageToBufferInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pCopyImageToBufferInfo != VK_NULL_HANDLE && pCopyImageToBufferInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->srcImage=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->dstBuffer=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->dstBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->regionCount=" + std::to_string(pCopyImageToBufferInfo->regionCount) + '!');
if(pCopyImageToBufferInfo->pRegions != VK_NULL_HANDLE && pCopyImageToBufferInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferOffset=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferOffset) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferRowLength=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferRowLength) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->bufferImageHeight=" + std::to_string(pCopyImageToBufferInfo->pRegions->bufferImageHeight) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageSubresource=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageOffset=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pCopyImageToBufferInfo->pRegions->imageExtent=" + ptrToString((void**)std::addressof(pCopyImageToBufferInfo->pRegions->imageExtent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pCopyImageToBufferInfo=VK_NULL_HANDLE!");
}
#ifdef CMDCOPYIMAGETOBUFFER2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdCopyImageToBuffer2KHR_after(commandBuffer, pCopyImageToBufferInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdCopyImageToBuffer2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResolveImage2KHR(VkCommandBuffer commandBuffer, VkResolveImageInfo2* pResolveImageInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResolveImage2KHR!");
}
#ifdef CMDRESOLVEIMAGE2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage2KHR_before(commandBuffer, pResolveImageInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pResolveImageInfo != VK_NULL_HANDLE && pResolveImageInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->srcImage=" + ptrToString((void**)std::addressof(pResolveImageInfo->srcImage)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->dstImage=" + ptrToString((void**)std::addressof(pResolveImageInfo->dstImage)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->regionCount=" + std::to_string(pResolveImageInfo->regionCount) + '!');
if(pResolveImageInfo->pRegions != VK_NULL_HANDLE && pResolveImageInfo->pRegions != NULL) {
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->srcSubresource=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->srcSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->srcOffset=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->srcOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->dstSubresource=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->dstSubresource)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->dstOffset=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->dstOffset)) + '!');
winsockSendToUI(&ConnectSocket,"pResolveImageInfo->pRegions->extent=" + ptrToString((void**)std::addressof(pResolveImageInfo->pRegions->extent)) + '!');
}else winsockSendToUI(&ConnectSocket, "pRegions=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pResolveImageInfo=VK_NULL_HANDLE!");
}
#ifdef CMDRESOLVEIMAGE2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResolveImage2KHR_after(commandBuffer, pResolveImageInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResolveImage2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkDependencyInfo* pDependencyInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdSetEvent2KHR!");
}
#ifdef CMDSETEVENT2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent2KHR_before(commandBuffer, event, pDependencyInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
if(pDependencyInfo != VK_NULL_HANDLE && pDependencyInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfo->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->memoryBarrierCount=" + std::to_string(pDependencyInfo->memoryBarrierCount) + '!');
if(pDependencyInfo->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfo->bufferMemoryBarrierCount) + '!');
if(pDependencyInfo->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->imageMemoryBarrierCount=" + std::to_string(pDependencyInfo->imageMemoryBarrierCount) + '!');
if(pDependencyInfo->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfo=VK_NULL_HANDLE!");
}
#ifdef CMDSETEVENT2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdSetEvent2KHR_after(commandBuffer, event, pDependencyInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdSetEvent2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdResetEvent2KHR!");
}
#ifdef CMDRESETEVENT2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent2KHR_before(commandBuffer, event, stageMask);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdResetEvent2KHR(commandBuffer, event, stageMask);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"event=" + ptrToString((void**)std::addressof(event)) + '!');
winsockSendToUI(&ConnectSocket,"stageMask=" + ptrToString((void**)std::addressof(stageMask)) + '!');
}
#ifdef CMDRESETEVENT2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdResetEvent2KHR_after(commandBuffer, event, stageMask);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdResetEvent2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdResetEvent2KHR(commandBuffer, event, stageMask);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent* pEvents, VkDependencyInfo* pDependencyInfos) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWaitEvents2KHR!");
}
#ifdef CMDWAITEVENTS2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents2KHR_before(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"eventCount=" + std::to_string(eventCount) + '!');
winsockSendToUI(&ConnectSocket,"pEvents=" + ptrToString((void**)std::addressof(pEvents)) + '!');
if(pDependencyInfos != VK_NULL_HANDLE && pDependencyInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfos->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->memoryBarrierCount=" + std::to_string(pDependencyInfos->memoryBarrierCount) + '!');
if(pDependencyInfos->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfos->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfos->bufferMemoryBarrierCount) + '!');
if(pDependencyInfos->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfos->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfos->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfos->imageMemoryBarrierCount=" + std::to_string(pDependencyInfos->imageMemoryBarrierCount) + '!');
if(pDependencyInfos->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfos->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfos->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfos->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfos->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfos->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfos=VK_NULL_HANDLE!");
}
#ifdef CMDWAITEVENTS2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWaitEvents2KHR_after(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWaitEvents2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, VkDependencyInfo* pDependencyInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdPipelineBarrier2KHR!");
}
#ifdef CMDPIPELINEBARRIER2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier2KHR_before(commandBuffer, pDependencyInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pDependencyInfo != VK_NULL_HANDLE && pDependencyInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->dependencyFlags=" + ptrToString((void**)std::addressof(pDependencyInfo->dependencyFlags)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->memoryBarrierCount=" + std::to_string(pDependencyInfo->memoryBarrierCount) + '!');
if(pDependencyInfo->pMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pMemoryBarriers->dstAccessMask)) + '!');
}else winsockSendToUI(&ConnectSocket, "pMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->bufferMemoryBarrierCount=" + std::to_string(pDependencyInfo->bufferMemoryBarrierCount) + '!');
if(pDependencyInfo->pBufferMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pBufferMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->buffer=" + ptrToString((void**)std::addressof(pDependencyInfo->pBufferMemoryBarriers->buffer)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->offset=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->offset) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pBufferMemoryBarriers->size=" + std::to_string(pDependencyInfo->pBufferMemoryBarriers->size) + '!');
}else winsockSendToUI(&ConnectSocket, "pBufferMemoryBarriers=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pDependencyInfo->imageMemoryBarrierCount=" + std::to_string(pDependencyInfo->imageMemoryBarrierCount) + '!');
if(pDependencyInfo->pImageMemoryBarriers != VK_NULL_HANDLE && pDependencyInfo->pImageMemoryBarriers != NULL) {
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->srcAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstStageMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstStageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstAccessMask=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->dstAccessMask)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->srcQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex=" + std::to_string(pDependencyInfo->pImageMemoryBarriers->dstQueueFamilyIndex) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->image=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->image)) + '!');
winsockSendToUI(&ConnectSocket,"pDependencyInfo->pImageMemoryBarriers->subresourceRange=" + ptrToString((void**)std::addressof(pDependencyInfo->pImageMemoryBarriers->subresourceRange)) + '!');
}else winsockSendToUI(&ConnectSocket, "pImageMemoryBarriers=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pDependencyInfo=VK_NULL_HANDLE!");
}
#ifdef CMDPIPELINEBARRIER2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdPipelineBarrier2KHR_after(commandBuffer, pDependencyInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdPipelineBarrier2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
}
}

 VK_LAYER_EXPORT VkResult VKAPI_CALL DebuggerLayer_QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, VkSubmitInfo2* pSubmits, VkFence fence) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkQueueSubmit2KHR!");
}
#ifdef QUEUESUBMIT2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_QueueSubmit2KHR_before(queue, submitCount, pSubmits, fence);
}
#endif 
auto ret = device_dispatch[GetKey(queue)].QueueSubmit2KHR(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
if(connected){
winsockSendToUI(&ConnectSocket,"queue=" + ptrToString((void**)std::addressof(queue)) + '!');
winsockSendToUI(&ConnectSocket,"submitCount=" + std::to_string(submitCount) + '!');
if(pSubmits != VK_NULL_HANDLE && pSubmits != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->flags=" + ptrToString((void**)std::addressof(pSubmits->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->waitSemaphoreInfoCount=" + std::to_string(pSubmits->waitSemaphoreInfoCount) + '!');
if(pSubmits->pWaitSemaphoreInfos != VK_NULL_HANDLE && pSubmits->pWaitSemaphoreInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->semaphore=" + ptrToString((void**)std::addressof(pSubmits->pWaitSemaphoreInfos->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->value=" + std::to_string(pSubmits->pWaitSemaphoreInfos->value) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->stageMask=" + ptrToString((void**)std::addressof(pSubmits->pWaitSemaphoreInfos->stageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pWaitSemaphoreInfos->deviceIndex=" + std::to_string(pSubmits->pWaitSemaphoreInfos->deviceIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pWaitSemaphoreInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSubmits->commandBufferInfoCount=" + std::to_string(pSubmits->commandBufferInfoCount) + '!');
if(pSubmits->pCommandBufferInfos != VK_NULL_HANDLE && pSubmits->pCommandBufferInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pCommandBufferInfos->commandBuffer=" + ptrToString((void**)std::addressof(pSubmits->pCommandBufferInfos->commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pCommandBufferInfos->deviceMask=" + std::to_string(pSubmits->pCommandBufferInfos->deviceMask) + '!');
}else winsockSendToUI(&ConnectSocket, "pCommandBufferInfos=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"pSubmits->signalSemaphoreInfoCount=" + std::to_string(pSubmits->signalSemaphoreInfoCount) + '!');
if(pSubmits->pSignalSemaphoreInfos != VK_NULL_HANDLE && pSubmits->pSignalSemaphoreInfos != NULL) {
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->semaphore=" + ptrToString((void**)std::addressof(pSubmits->pSignalSemaphoreInfos->semaphore)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->value=" + std::to_string(pSubmits->pSignalSemaphoreInfos->value) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->stageMask=" + ptrToString((void**)std::addressof(pSubmits->pSignalSemaphoreInfos->stageMask)) + '!');
winsockSendToUI(&ConnectSocket,"pSubmits->pSignalSemaphoreInfos->deviceIndex=" + std::to_string(pSubmits->pSignalSemaphoreInfos->deviceIndex) + '!');
}else winsockSendToUI(&ConnectSocket, "pSignalSemaphoreInfos=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pSubmits=VK_NULL_HANDLE!");
winsockSendToUI(&ConnectSocket,"fence=" + ptrToString((void**)std::addressof(fence)) + '!');
}
#ifdef QUEUESUBMIT2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_QueueSubmit2KHR_after(queue, submitCount, pSubmits, fence);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkQueueSubmit2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
return ret;
} else {
auto ret = device_dispatch[GetKey(queue)].QueueSubmit2KHR(queue, submitCount, pSubmits, fence);
winsockSendToUI(&ConnectSocket, "vkResult=" + std::to_string(ret) + '!');
return ret;
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdWriteTimestamp2KHR!");
}
#ifdef CMDWRITETIMESTAMP2KHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp2KHR_before(commandBuffer, stage, queryPool, query);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
winsockSendToUI(&ConnectSocket,"stage=" + ptrToString((void**)std::addressof(stage)) + '!');
winsockSendToUI(&ConnectSocket,"queryPool=" + ptrToString((void**)std::addressof(queryPool)) + '!');
winsockSendToUI(&ConnectSocket,"query=" + std::to_string(query) + '!');
}
#ifdef CMDWRITETIMESTAMP2KHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdWriteTimestamp2KHR_after(commandBuffer, stage, queryPool, query);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdWriteTimestamp2KHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, VkRenderingInfo* pRenderingInfo) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdBeginRenderingKHR!");
}
#ifdef CMDBEGINRENDERINGKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderingKHR_before(commandBuffer, pRenderingInfo);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderingKHR(commandBuffer, pRenderingInfo);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
if(pRenderingInfo != VK_NULL_HANDLE && pRenderingInfo != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->flags=" + ptrToString((void**)std::addressof(pRenderingInfo->flags)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->renderArea=" + ptrToString((void**)std::addressof(pRenderingInfo->renderArea)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->layerCount=" + std::to_string(pRenderingInfo->layerCount) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->viewMask=" + std::to_string(pRenderingInfo->viewMask) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->colorAttachmentCount=" + std::to_string(pRenderingInfo->colorAttachmentCount) + '!');
if(pRenderingInfo->pColorAttachments != VK_NULL_HANDLE && pRenderingInfo->pColorAttachments != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pColorAttachments->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pColorAttachments->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pColorAttachments=VK_NULL_HANDLE!");
if(pRenderingInfo->pDepthAttachment != VK_NULL_HANDLE && pRenderingInfo->pDepthAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pDepthAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pDepthAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pDepthAttachment=VK_NULL_HANDLE!");
if(pRenderingInfo->pStencilAttachment != VK_NULL_HANDLE && pRenderingInfo->pStencilAttachment != NULL) {
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->imageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->imageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->resolveImageView=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->resolveImageView)) + '!');
winsockSendToUI(&ConnectSocket,"pRenderingInfo->pStencilAttachment->clearValue=" + ptrToString((void**)std::addressof(pRenderingInfo->pStencilAttachment->clearValue)) + '!');
}else winsockSendToUI(&ConnectSocket, "pStencilAttachment=VK_NULL_HANDLE!");
}else winsockSendToUI(&ConnectSocket, "pRenderingInfo=VK_NULL_HANDLE!");
}
#ifdef CMDBEGINRENDERINGKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdBeginRenderingKHR_after(commandBuffer, pRenderingInfo);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdBeginRenderingKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdBeginRenderingKHR(commandBuffer, pRenderingInfo);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_CmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkCmdEndRenderingKHR!");
}
#ifdef CMDENDRENDERINGKHR_BEFORE_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderingKHR_before(commandBuffer);
}
#endif 
device_dispatch[GetKey(commandBuffer)].CmdEndRenderingKHR(commandBuffer);
if(connected){
winsockSendToUI(&ConnectSocket,"commandBuffer=" + ptrToString((void**)std::addressof(commandBuffer)) + '!');
}
#ifdef CMDENDRENDERINGKHR_AFTER_EXEC_EXISTS
if(connected) {
layer_CmdEndRenderingKHR_after(commandBuffer);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkCmdEndRenderingKHR!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(commandBuffer)].CmdEndRenderingKHR(commandBuffer);
}
}

 VK_LAYER_EXPORT void VKAPI_CALL DebuggerLayer_GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, VkImageSubresource2KHR* pSubresource, VkSubresourceLayout2KHR* pLayout) {
if(skipLock == false) {
	scoped_lock l(global_lock);
if(connected) {
winsockSendToUI(&ConnectSocket, "begin_vkGetImageSubresourceLayout2EXT!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT2EXT_BEFORE_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout2EXT_before(device, image, pSubresource, pLayout);
}
#endif 
device_dispatch[GetKey(device)].GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout);
if(connected){
winsockSendToUI(&ConnectSocket,"device=" + ptrToString((void**)std::addressof(device)) + '!');
winsockSendToUI(&ConnectSocket,"image=" + ptrToString((void**)std::addressof(image)) + '!');
if(pSubresource != VK_NULL_HANDLE && pSubresource != NULL) {
winsockSendToUI(&ConnectSocket,"pSubresource->imageSubresource=" + ptrToString((void**)std::addressof(pSubresource->imageSubresource)) + '!');
}else winsockSendToUI(&ConnectSocket, "pSubresource=VK_NULL_HANDLE!");
if(pLayout != VK_NULL_HANDLE && pLayout != NULL) {
winsockSendToUI(&ConnectSocket,"pLayout->subresourceLayout=" + ptrToString((void**)std::addressof(pLayout->subresourceLayout)) + '!');
}else winsockSendToUI(&ConnectSocket, "pLayout=VK_NULL_HANDLE!");
}
#ifdef GETIMAGESUBRESOURCELAYOUT2EXT_AFTER_EXEC_EXISTS
if(connected) {
layer_GetImageSubresourceLayout2EXT_after(device, image, pSubresource, pLayout);
}
#endif 
if(connected) {
winsockSendToUI(&ConnectSocket, "end_vkGetImageSubresourceLayout2EXT!");
if (callEveryBreak || callAtBreak)
	newCall();
}
} else {
device_dispatch[GetKey(device)].GetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout);
}
}
#define GETPROCADDR(func) if(!strcmp(pName, "vk" #func)) return (PFN_vkVoidFunction)&DebuggerLayer_##func;
VK_LAYER_EXPORT PFN_vkVoidFunction VKAPI_CALL DebuggerLayer_GetDeviceProcAddr(VkDevice device, const char* pName) {
if (GetWindowName() == "vkDetails.exe") { return device_dispatch[GetKey(device)].GetDeviceProcAddr(device, pName); }
GETPROCADDR(GetDeviceProcAddr);
GETPROCADDR(DestroyDevice);
GETPROCADDR(GetDeviceQueue);
GETPROCADDR(QueueSubmit);
GETPROCADDR(QueueWaitIdle);
GETPROCADDR(DeviceWaitIdle);
GETPROCADDR(AllocateMemory);
GETPROCADDR(FreeMemory);
GETPROCADDR(MapMemory);
GETPROCADDR(UnmapMemory);
GETPROCADDR(FlushMappedMemoryRanges);
GETPROCADDR(InvalidateMappedMemoryRanges);
GETPROCADDR(GetDeviceMemoryCommitment);
GETPROCADDR(GetBufferMemoryRequirements);
GETPROCADDR(BindBufferMemory);
GETPROCADDR(GetImageMemoryRequirements);
GETPROCADDR(BindImageMemory);
GETPROCADDR(GetImageSparseMemoryRequirements);
GETPROCADDR(QueueBindSparse);
GETPROCADDR(CreateFence);
GETPROCADDR(DestroyFence);
GETPROCADDR(ResetFences);
GETPROCADDR(GetFenceStatus);
GETPROCADDR(WaitForFences);
GETPROCADDR(CreateSemaphore);
GETPROCADDR(DestroySemaphore);
GETPROCADDR(CreateEvent);
GETPROCADDR(DestroyEvent);
GETPROCADDR(GetEventStatus);
GETPROCADDR(SetEvent);
GETPROCADDR(ResetEvent);
GETPROCADDR(CreateQueryPool);
GETPROCADDR(DestroyQueryPool);
GETPROCADDR(GetQueryPoolResults);
GETPROCADDR(ResetQueryPool);
GETPROCADDR(CreateBuffer);
GETPROCADDR(DestroyBuffer);
GETPROCADDR(CreateBufferView);
GETPROCADDR(DestroyBufferView);
GETPROCADDR(CreateImage);
GETPROCADDR(DestroyImage);
GETPROCADDR(GetImageSubresourceLayout);
GETPROCADDR(CreateImageView);
GETPROCADDR(DestroyImageView);
GETPROCADDR(CreateShaderModule);
GETPROCADDR(DestroyShaderModule);
GETPROCADDR(CreatePipelineCache);
GETPROCADDR(DestroyPipelineCache);
GETPROCADDR(GetPipelineCacheData);
GETPROCADDR(MergePipelineCaches);
GETPROCADDR(CreateGraphicsPipelines);
GETPROCADDR(CreateComputePipelines);
GETPROCADDR(GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI);
GETPROCADDR(DestroyPipeline);
GETPROCADDR(CreatePipelineLayout);
GETPROCADDR(DestroyPipelineLayout);
GETPROCADDR(CreateSampler);
GETPROCADDR(DestroySampler);
GETPROCADDR(CreateDescriptorSetLayout);
GETPROCADDR(DestroyDescriptorSetLayout);
GETPROCADDR(CreateDescriptorPool);
GETPROCADDR(DestroyDescriptorPool);
GETPROCADDR(ResetDescriptorPool);
GETPROCADDR(AllocateDescriptorSets);
GETPROCADDR(FreeDescriptorSets);
GETPROCADDR(UpdateDescriptorSets);
GETPROCADDR(CreateFramebuffer);
GETPROCADDR(DestroyFramebuffer);
GETPROCADDR(CreateRenderPass);
GETPROCADDR(DestroyRenderPass);
GETPROCADDR(GetRenderAreaGranularity);
GETPROCADDR(GetRenderingAreaGranularityKHR);
GETPROCADDR(CreateCommandPool);
GETPROCADDR(DestroyCommandPool);
GETPROCADDR(ResetCommandPool);
GETPROCADDR(AllocateCommandBuffers);
GETPROCADDR(FreeCommandBuffers);
GETPROCADDR(BeginCommandBuffer);
GETPROCADDR(EndCommandBuffer);
GETPROCADDR(ResetCommandBuffer);
GETPROCADDR(CmdBindPipeline);
GETPROCADDR(CmdSetAttachmentFeedbackLoopEnableEXT);
GETPROCADDR(CmdSetViewport);
GETPROCADDR(CmdSetScissor);
GETPROCADDR(CmdSetLineWidth);
GETPROCADDR(CmdSetDepthBias);
GETPROCADDR(CmdSetBlendConstants);
GETPROCADDR(CmdSetDepthBounds);
GETPROCADDR(CmdSetStencilCompareMask);
GETPROCADDR(CmdSetStencilWriteMask);
GETPROCADDR(CmdSetStencilReference);
GETPROCADDR(CmdBindDescriptorSets);
GETPROCADDR(CmdBindIndexBuffer);
GETPROCADDR(CmdBindVertexBuffers);
GETPROCADDR(CmdDraw);
GETPROCADDR(CmdDrawIndexed);
GETPROCADDR(CmdDrawMultiEXT);
GETPROCADDR(CmdDrawMultiIndexedEXT);
GETPROCADDR(CmdDrawIndirect);
GETPROCADDR(CmdDrawIndexedIndirect);
GETPROCADDR(CmdDispatch);
GETPROCADDR(CmdDispatchIndirect);
GETPROCADDR(CmdSubpassShadingHUAWEI);
GETPROCADDR(CmdDrawClusterHUAWEI);
GETPROCADDR(CmdDrawClusterIndirectHUAWEI);
GETPROCADDR(CmdUpdatePipelineIndirectBufferNV);
GETPROCADDR(CmdCopyBuffer);
GETPROCADDR(CmdCopyImage);
GETPROCADDR(CmdBlitImage);
GETPROCADDR(CmdCopyBufferToImage);
GETPROCADDR(CmdCopyImageToBuffer);
GETPROCADDR(CmdCopyMemoryIndirectNV);
GETPROCADDR(CmdCopyMemoryToImageIndirectNV);
GETPROCADDR(CmdUpdateBuffer);
GETPROCADDR(CmdFillBuffer);
GETPROCADDR(CmdClearColorImage);
GETPROCADDR(CmdClearDepthStencilImage);
GETPROCADDR(CmdClearAttachments);
GETPROCADDR(CmdResolveImage);
GETPROCADDR(CmdSetEvent);
GETPROCADDR(CmdResetEvent);
GETPROCADDR(CmdWaitEvents);
GETPROCADDR(CmdPipelineBarrier);
GETPROCADDR(CmdBeginQuery);
GETPROCADDR(CmdEndQuery);
GETPROCADDR(CmdBeginConditionalRenderingEXT);
GETPROCADDR(CmdEndConditionalRenderingEXT);
GETPROCADDR(CmdResetQueryPool);
GETPROCADDR(CmdWriteTimestamp);
GETPROCADDR(CmdCopyQueryPoolResults);
GETPROCADDR(CmdPushConstants);
GETPROCADDR(CmdBeginRenderPass);
GETPROCADDR(CmdNextSubpass);
GETPROCADDR(CmdEndRenderPass);
GETPROCADDR(CmdExecuteCommands);
GETPROCADDR(CreateSharedSwapchainsKHR);
GETPROCADDR(CreateSwapchainKHR);
GETPROCADDR(DestroySwapchainKHR);
GETPROCADDR(GetSwapchainImagesKHR);
GETPROCADDR(AcquireNextImageKHR);
GETPROCADDR(QueuePresentKHR);
GETPROCADDR(DebugMarkerSetObjectNameEXT);
GETPROCADDR(DebugMarkerSetObjectTagEXT);
GETPROCADDR(CmdDebugMarkerBeginEXT);
GETPROCADDR(CmdDebugMarkerEndEXT);
GETPROCADDR(CmdDebugMarkerInsertEXT);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandleNV);
#endif
GETPROCADDR(CmdExecuteGeneratedCommandsNV);
GETPROCADDR(CmdPreprocessGeneratedCommandsNV);
GETPROCADDR(CmdBindPipelineShaderGroupNV);
GETPROCADDR(GetGeneratedCommandsMemoryRequirementsNV);
GETPROCADDR(CreateIndirectCommandsLayoutNV);
GETPROCADDR(DestroyIndirectCommandsLayoutNV);
GETPROCADDR(CmdPushDescriptorSetKHR);
GETPROCADDR(TrimCommandPool);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandlePropertiesKHR);
#endif
GETPROCADDR(GetMemoryFdKHR);
GETPROCADDR(GetMemoryFdPropertiesKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetMemoryZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetMemoryZirconHandlePropertiesFUCHSIA);
#endif
GETPROCADDR(GetMemoryRemoteAddressNV);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetMemorySciBufNV);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetSemaphoreWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ImportSemaphoreWin32HandleKHR);
#endif
GETPROCADDR(GetSemaphoreFdKHR);
GETPROCADDR(ImportSemaphoreFdKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetSemaphoreZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(ImportSemaphoreZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetFenceWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ImportFenceWin32HandleKHR);
#endif
GETPROCADDR(GetFenceFdKHR);
GETPROCADDR(ImportFenceFdKHR);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetFenceSciSyncFenceNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetFenceSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportFenceSciSyncFenceNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportFenceSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetSemaphoreSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportSemaphoreSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(CreateSemaphoreSciSyncPoolNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(DestroySemaphoreSciSyncPoolNV);
#endif
GETPROCADDR(DisplayPowerControlEXT);
GETPROCADDR(RegisterDeviceEventEXT);
GETPROCADDR(RegisterDisplayEventEXT);
GETPROCADDR(GetSwapchainCounterEXT);
GETPROCADDR(GetDeviceGroupPeerMemoryFeatures);
GETPROCADDR(BindBufferMemory2);
GETPROCADDR(BindImageMemory2);
GETPROCADDR(CmdSetDeviceMask);
GETPROCADDR(GetDeviceGroupPresentCapabilitiesKHR);
GETPROCADDR(GetDeviceGroupSurfacePresentModesKHR);
GETPROCADDR(AcquireNextImage2KHR);
GETPROCADDR(CmdDispatchBase);
GETPROCADDR(CreateDescriptorUpdateTemplate);
GETPROCADDR(DestroyDescriptorUpdateTemplate);
GETPROCADDR(UpdateDescriptorSetWithTemplate);
GETPROCADDR(CmdPushDescriptorSetWithTemplateKHR);
GETPROCADDR(SetHdrMetadataEXT);
GETPROCADDR(GetSwapchainStatusKHR);
GETPROCADDR(GetRefreshCycleDurationGOOGLE);
GETPROCADDR(GetPastPresentationTimingGOOGLE);
GETPROCADDR(CmdSetViewportWScalingNV);
GETPROCADDR(CmdSetDiscardRectangleEXT);
GETPROCADDR(CmdSetDiscardRectangleEnableEXT);
GETPROCADDR(CmdSetDiscardRectangleModeEXT);
GETPROCADDR(CmdSetSampleLocationsEXT);
GETPROCADDR(GetBufferMemoryRequirements2);
GETPROCADDR(GetImageMemoryRequirements2);
GETPROCADDR(GetImageSparseMemoryRequirements2);
GETPROCADDR(GetDeviceBufferMemoryRequirements);
GETPROCADDR(GetDeviceImageMemoryRequirements);
GETPROCADDR(GetDeviceImageSparseMemoryRequirements);
GETPROCADDR(CreateSamplerYcbcrConversion);
GETPROCADDR(DestroySamplerYcbcrConversion);
GETPROCADDR(GetDeviceQueue2);
GETPROCADDR(CreateValidationCacheEXT);
GETPROCADDR(DestroyValidationCacheEXT);
GETPROCADDR(GetValidationCacheDataEXT);
GETPROCADDR(MergeValidationCachesEXT);
GETPROCADDR(GetDescriptorSetLayoutSupport);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetSwapchainGrallocUsageANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetSwapchainGrallocUsage2ANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(AcquireImageANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(QueueSignalReleaseImageANDROID);
#endif
GETPROCADDR(GetShaderInfoAMD);
GETPROCADDR(SetLocalDimmingAMD);
GETPROCADDR(GetCalibratedTimestampsKHR);
GETPROCADDR(SetDebugUtilsObjectNameEXT);
GETPROCADDR(SetDebugUtilsObjectTagEXT);
GETPROCADDR(QueueBeginDebugUtilsLabelEXT);
GETPROCADDR(QueueEndDebugUtilsLabelEXT);
GETPROCADDR(QueueInsertDebugUtilsLabelEXT);
GETPROCADDR(CmdBeginDebugUtilsLabelEXT);
GETPROCADDR(CmdEndDebugUtilsLabelEXT);
GETPROCADDR(CmdInsertDebugUtilsLabelEXT);
GETPROCADDR(GetMemoryHostPointerPropertiesEXT);
GETPROCADDR(CmdWriteBufferMarkerAMD);
GETPROCADDR(CreateRenderPass2);
GETPROCADDR(CmdBeginRenderPass2);
GETPROCADDR(CmdNextSubpass2);
GETPROCADDR(CmdEndRenderPass2);
GETPROCADDR(GetSemaphoreCounterValue);
GETPROCADDR(WaitSemaphores);
GETPROCADDR(SignalSemaphore);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetAndroidHardwareBufferPropertiesANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetMemoryAndroidHardwareBufferANDROID);
#endif
GETPROCADDR(CmdDrawIndirectCount);
GETPROCADDR(CmdDrawIndexedIndirectCount);
GETPROCADDR(CmdSetCheckpointNV);
GETPROCADDR(GetQueueCheckpointDataNV);
GETPROCADDR(CmdBindTransformFeedbackBuffersEXT);
GETPROCADDR(CmdBeginTransformFeedbackEXT);
GETPROCADDR(CmdEndTransformFeedbackEXT);
GETPROCADDR(CmdBeginQueryIndexedEXT);
GETPROCADDR(CmdEndQueryIndexedEXT);
GETPROCADDR(CmdDrawIndirectByteCountEXT);
GETPROCADDR(CmdSetExclusiveScissorNV);
GETPROCADDR(CmdSetExclusiveScissorEnableNV);
GETPROCADDR(CmdBindShadingRateImageNV);
GETPROCADDR(CmdSetViewportShadingRatePaletteNV);
GETPROCADDR(CmdSetCoarseSampleOrderNV);
GETPROCADDR(CmdDrawMeshTasksNV);
GETPROCADDR(CmdDrawMeshTasksIndirectNV);
GETPROCADDR(CmdDrawMeshTasksIndirectCountNV);
GETPROCADDR(CmdDrawMeshTasksEXT);
GETPROCADDR(CmdDrawMeshTasksIndirectEXT);
GETPROCADDR(CmdDrawMeshTasksIndirectCountEXT);
GETPROCADDR(CompileDeferredNV);
GETPROCADDR(CreateAccelerationStructureNV);
GETPROCADDR(CmdBindInvocationMaskHUAWEI);
GETPROCADDR(DestroyAccelerationStructureKHR);
GETPROCADDR(DestroyAccelerationStructureNV);
GETPROCADDR(GetAccelerationStructureMemoryRequirementsNV);
GETPROCADDR(BindAccelerationStructureMemoryNV);
GETPROCADDR(CmdCopyAccelerationStructureNV);
GETPROCADDR(CmdCopyAccelerationStructureKHR);
GETPROCADDR(CopyAccelerationStructureKHR);
GETPROCADDR(CmdCopyAccelerationStructureToMemoryKHR);
GETPROCADDR(CopyAccelerationStructureToMemoryKHR);
GETPROCADDR(CmdCopyMemoryToAccelerationStructureKHR);
GETPROCADDR(CopyMemoryToAccelerationStructureKHR);
GETPROCADDR(CmdWriteAccelerationStructuresPropertiesKHR);
GETPROCADDR(CmdWriteAccelerationStructuresPropertiesNV);
GETPROCADDR(CmdBuildAccelerationStructureNV);
GETPROCADDR(WriteAccelerationStructuresPropertiesKHR);
GETPROCADDR(CmdTraceRaysKHR);
GETPROCADDR(CmdTraceRaysNV);
GETPROCADDR(GetRayTracingShaderGroupHandlesKHR);
GETPROCADDR(GetRayTracingCaptureReplayShaderGroupHandlesKHR);
GETPROCADDR(GetAccelerationStructureHandleNV);
GETPROCADDR(CreateRayTracingPipelinesNV);
GETPROCADDR(CreateRayTracingPipelinesKHR);
GETPROCADDR(CmdTraceRaysIndirectKHR);
GETPROCADDR(CmdTraceRaysIndirect2KHR);
GETPROCADDR(GetDeviceAccelerationStructureCompatibilityKHR);
GETPROCADDR(GetRayTracingShaderGroupStackSizeKHR);
GETPROCADDR(CmdSetRayTracingPipelineStackSizeKHR);
GETPROCADDR(GetImageViewHandleNVX);
GETPROCADDR(GetImageViewAddressNVX);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetDeviceGroupSurfacePresentModes2EXT);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(AcquireFullScreenExclusiveModeEXT);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ReleaseFullScreenExclusiveModeEXT);
#endif
GETPROCADDR(AcquireProfilingLockKHR);
GETPROCADDR(ReleaseProfilingLockKHR);
GETPROCADDR(GetImageDrmFormatModifierPropertiesEXT);
GETPROCADDR(GetBufferOpaqueCaptureAddress);
GETPROCADDR(GetBufferDeviceAddress);
GETPROCADDR(InitializePerformanceApiINTEL);
GETPROCADDR(UninitializePerformanceApiINTEL);
GETPROCADDR(CmdSetPerformanceMarkerINTEL);
GETPROCADDR(CmdSetPerformanceStreamMarkerINTEL);
GETPROCADDR(CmdSetPerformanceOverrideINTEL);
GETPROCADDR(AcquirePerformanceConfigurationINTEL);
GETPROCADDR(ReleasePerformanceConfigurationINTEL);
GETPROCADDR(QueueSetPerformanceConfigurationINTEL);
GETPROCADDR(GetPerformanceParameterINTEL);
GETPROCADDR(GetDeviceMemoryOpaqueCaptureAddress);
GETPROCADDR(GetPipelineExecutablePropertiesKHR);
GETPROCADDR(GetPipelineExecutableStatisticsKHR);
GETPROCADDR(GetPipelineExecutableInternalRepresentationsKHR);
GETPROCADDR(CreateAccelerationStructureKHR);
GETPROCADDR(CmdBuildAccelerationStructuresKHR);
GETPROCADDR(CmdBuildAccelerationStructuresIndirectKHR);
GETPROCADDR(BuildAccelerationStructuresKHR);
GETPROCADDR(GetAccelerationStructureDeviceAddressKHR);
GETPROCADDR(CreateDeferredOperationKHR);
GETPROCADDR(DestroyDeferredOperationKHR);
GETPROCADDR(GetDeferredOperationMaxConcurrencyKHR);
GETPROCADDR(GetDeferredOperationResultKHR);
GETPROCADDR(DeferredOperationJoinKHR);
GETPROCADDR(GetPipelineIndirectMemoryRequirementsNV);
GETPROCADDR(GetPipelineIndirectDeviceAddressNV);
GETPROCADDR(CmdSetCullMode);
GETPROCADDR(CmdSetFrontFace);
GETPROCADDR(CmdSetPrimitiveTopology);
GETPROCADDR(CmdSetViewportWithCount);
GETPROCADDR(CmdSetScissorWithCount);
GETPROCADDR(CmdBindIndexBuffer2KHR);
GETPROCADDR(CmdBindVertexBuffers2);
GETPROCADDR(CmdSetDepthTestEnable);
GETPROCADDR(CmdSetDepthWriteEnable);
GETPROCADDR(CmdSetDepthCompareOp);
GETPROCADDR(CmdSetDepthBoundsTestEnable);
GETPROCADDR(CmdSetStencilTestEnable);
GETPROCADDR(CmdSetStencilOp);
GETPROCADDR(CmdSetPatchControlPointsEXT);
GETPROCADDR(CmdSetRasterizerDiscardEnable);
GETPROCADDR(CmdSetDepthBiasEnable);
GETPROCADDR(CmdSetLogicOpEXT);
GETPROCADDR(CmdSetPrimitiveRestartEnable);
GETPROCADDR(CmdSetTessellationDomainOriginEXT);
GETPROCADDR(CmdSetDepthClampEnableEXT);
GETPROCADDR(CmdSetPolygonModeEXT);
GETPROCADDR(CmdSetRasterizationSamplesEXT);
GETPROCADDR(CmdSetSampleMaskEXT);
GETPROCADDR(CmdSetAlphaToCoverageEnableEXT);
GETPROCADDR(CmdSetAlphaToOneEnableEXT);
GETPROCADDR(CmdSetLogicOpEnableEXT);
GETPROCADDR(CmdSetColorBlendEnableEXT);
GETPROCADDR(CmdSetColorBlendEquationEXT);
GETPROCADDR(CmdSetColorWriteMaskEXT);
GETPROCADDR(CmdSetRasterizationStreamEXT);
GETPROCADDR(CmdSetConservativeRasterizationModeEXT);
GETPROCADDR(CmdSetExtraPrimitiveOverestimationSizeEXT);
GETPROCADDR(CmdSetDepthClipEnableEXT);
GETPROCADDR(CmdSetSampleLocationsEnableEXT);
GETPROCADDR(CmdSetColorBlendAdvancedEXT);
GETPROCADDR(CmdSetProvokingVertexModeEXT);
GETPROCADDR(CmdSetLineRasterizationModeEXT);
GETPROCADDR(CmdSetLineStippleEnableEXT);
GETPROCADDR(CmdSetDepthClipNegativeOneToOneEXT);
GETPROCADDR(CmdSetViewportWScalingEnableNV);
GETPROCADDR(CmdSetViewportSwizzleNV);
GETPROCADDR(CmdSetCoverageToColorEnableNV);
GETPROCADDR(CmdSetCoverageToColorLocationNV);
GETPROCADDR(CmdSetCoverageModulationModeNV);
GETPROCADDR(CmdSetCoverageModulationTableEnableNV);
GETPROCADDR(CmdSetCoverageModulationTableNV);
GETPROCADDR(CmdSetShadingRateImageEnableNV);
GETPROCADDR(CmdSetCoverageReductionModeNV);
GETPROCADDR(CmdSetRepresentativeFragmentTestEnableNV);
GETPROCADDR(CreatePrivateDataSlot);
GETPROCADDR(DestroyPrivateDataSlot);
GETPROCADDR(SetPrivateData);
GETPROCADDR(GetPrivateData);
GETPROCADDR(CmdCopyBuffer2);
GETPROCADDR(CmdCopyImage2);
GETPROCADDR(CmdBlitImage2);
GETPROCADDR(CmdCopyBufferToImage2);
GETPROCADDR(CmdCopyImageToBuffer2);
GETPROCADDR(CmdResolveImage2);
GETPROCADDR(CmdSetFragmentShadingRateKHR);
GETPROCADDR(CmdSetFragmentShadingRateEnumNV);
GETPROCADDR(GetAccelerationStructureBuildSizesKHR);
GETPROCADDR(CmdSetVertexInputEXT);
GETPROCADDR(CmdSetColorWriteEnableEXT);
GETPROCADDR(CmdSetEvent2);
GETPROCADDR(CmdResetEvent2);
GETPROCADDR(CmdWaitEvents2);
GETPROCADDR(CmdPipelineBarrier2);
GETPROCADDR(QueueSubmit2);
GETPROCADDR(CmdWriteTimestamp2);
GETPROCADDR(CmdWriteBufferMarker2AMD);
GETPROCADDR(GetQueueCheckpointData2NV);
GETPROCADDR(CopyMemoryToImageEXT);
GETPROCADDR(CopyImageToMemoryEXT);
GETPROCADDR(CopyImageToImageEXT);
GETPROCADDR(TransitionImageLayoutEXT);
GETPROCADDR(CreateVideoSessionKHR);
GETPROCADDR(DestroyVideoSessionKHR);
GETPROCADDR(CreateVideoSessionParametersKHR);
GETPROCADDR(UpdateVideoSessionParametersKHR);
GETPROCADDR(GetEncodedVideoSessionParametersKHR);
GETPROCADDR(DestroyVideoSessionParametersKHR);
GETPROCADDR(GetVideoSessionMemoryRequirementsKHR);
GETPROCADDR(BindVideoSessionMemoryKHR);
GETPROCADDR(CmdDecodeVideoKHR);
GETPROCADDR(CmdBeginVideoCodingKHR);
GETPROCADDR(CmdControlVideoCodingKHR);
GETPROCADDR(CmdEndVideoCodingKHR);
GETPROCADDR(CmdEncodeVideoKHR);
GETPROCADDR(CmdDecompressMemoryNV);
GETPROCADDR(CmdDecompressMemoryIndirectCountNV);
GETPROCADDR(CreateCuModuleNVX);
GETPROCADDR(CreateCuFunctionNVX);
GETPROCADDR(DestroyCuModuleNVX);
GETPROCADDR(DestroyCuFunctionNVX);
GETPROCADDR(CmdCuLaunchKernelNVX);
GETPROCADDR(GetDescriptorSetLayoutSizeEXT);
GETPROCADDR(GetDescriptorSetLayoutBindingOffsetEXT);
GETPROCADDR(GetDescriptorEXT);
GETPROCADDR(CmdBindDescriptorBuffersEXT);
GETPROCADDR(CmdSetDescriptorBufferOffsetsEXT);
GETPROCADDR(CmdBindDescriptorBufferEmbeddedSamplersEXT);
GETPROCADDR(GetBufferOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetImageOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetImageViewOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetSamplerOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetAccelerationStructureOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(SetDeviceMemoryPriorityEXT);
GETPROCADDR(WaitForPresentKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(CreateBufferCollectionFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(SetBufferCollectionBufferConstraintsFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(SetBufferCollectionImageConstraintsFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(DestroyBufferCollectionFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetBufferCollectionPropertiesFUCHSIA);
#endif
GETPROCADDR(CreateCudaModuleNV);
GETPROCADDR(GetCudaModuleCacheNV);
GETPROCADDR(CreateCudaFunctionNV);
GETPROCADDR(DestroyCudaModuleNV);
GETPROCADDR(DestroyCudaFunctionNV);
GETPROCADDR(CmdCudaLaunchKernelNV);
GETPROCADDR(CmdBeginRendering);
GETPROCADDR(CmdEndRendering);
GETPROCADDR(GetDescriptorSetLayoutHostMappingInfoVALVE);
GETPROCADDR(GetDescriptorSetHostMappingVALVE);
GETPROCADDR(CreateMicromapEXT);
GETPROCADDR(CmdBuildMicromapsEXT);
GETPROCADDR(BuildMicromapsEXT);
GETPROCADDR(DestroyMicromapEXT);
GETPROCADDR(CmdCopyMicromapEXT);
GETPROCADDR(CopyMicromapEXT);
GETPROCADDR(CmdCopyMicromapToMemoryEXT);
GETPROCADDR(CopyMicromapToMemoryEXT);
GETPROCADDR(CmdCopyMemoryToMicromapEXT);
GETPROCADDR(CopyMemoryToMicromapEXT);
GETPROCADDR(CmdWriteMicromapsPropertiesEXT);
GETPROCADDR(WriteMicromapsPropertiesEXT);
GETPROCADDR(GetDeviceMicromapCompatibilityEXT);
GETPROCADDR(GetMicromapBuildSizesEXT);
GETPROCADDR(GetShaderModuleIdentifierEXT);
GETPROCADDR(GetShaderModuleCreateInfoIdentifierEXT);
GETPROCADDR(GetImageSubresourceLayout2KHR);
GETPROCADDR(GetPipelinePropertiesEXT);
#if defined(VK_USE_PLATFORM_METAL_EXT)
GETPROCADDR(ExportMetalObjectsEXT);
#endif
GETPROCADDR(GetFramebufferTilePropertiesQCOM);
GETPROCADDR(GetDynamicRenderingTilePropertiesQCOM);
GETPROCADDR(CreateOpticalFlowSessionNV);
GETPROCADDR(DestroyOpticalFlowSessionNV);
GETPROCADDR(BindOpticalFlowSessionImageNV);
GETPROCADDR(CmdOpticalFlowExecuteNV);
GETPROCADDR(GetDeviceFaultInfoEXT);
GETPROCADDR(CmdSetDepthBias2EXT);
GETPROCADDR(ReleaseSwapchainImagesEXT);
GETPROCADDR(GetDeviceImageSubresourceLayoutKHR);
GETPROCADDR(MapMemory2KHR);
GETPROCADDR(UnmapMemory2KHR);
GETPROCADDR(CreateShadersEXT);
GETPROCADDR(DestroyShaderEXT);
GETPROCADDR(GetShaderBinaryDataEXT);
GETPROCADDR(CmdBindShadersEXT);
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
GETPROCADDR(GetScreenBufferPropertiesQNX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(GetExecutionGraphPipelineScratchSizeAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(GetExecutionGraphPipelineNodeIndexAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CreateExecutionGraphPipelinesAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdInitializeGraphScratchMemoryAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphIndirectAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphIndirectCountAMDX);
#endif
GETPROCADDR(CmdBindDescriptorSets2KHR);
GETPROCADDR(CmdPushConstants2KHR);
GETPROCADDR(CmdPushDescriptorSet2KHR);
GETPROCADDR(CmdPushDescriptorSetWithTemplate2KHR);
GETPROCADDR(CmdSetDescriptorBufferOffsets2EXT);
GETPROCADDR(CmdBindDescriptorBufferEmbeddedSamplers2EXT);
GETPROCADDR(SetLatencySleepModeNV);
GETPROCADDR(LatencySleepNV);
GETPROCADDR(SetLatencyMarkerNV);
GETPROCADDR(GetLatencyTimingsNV);
GETPROCADDR(QueueNotifyOutOfBandNV);
GETPROCADDR(ResetQueryPoolEXT);
GETPROCADDR(TrimCommandPoolKHR);
GETPROCADDR(GetDeviceGroupPeerMemoryFeaturesKHR);
GETPROCADDR(BindBufferMemory2KHR);
GETPROCADDR(BindImageMemory2KHR);
GETPROCADDR(CmdSetDeviceMaskKHR);
GETPROCADDR(CmdDispatchBaseKHR);
GETPROCADDR(CreateDescriptorUpdateTemplateKHR);
GETPROCADDR(DestroyDescriptorUpdateTemplateKHR);
GETPROCADDR(UpdateDescriptorSetWithTemplateKHR);
GETPROCADDR(GetBufferMemoryRequirements2KHR);
GETPROCADDR(GetImageMemoryRequirements2KHR);
GETPROCADDR(GetImageSparseMemoryRequirements2KHR);
GETPROCADDR(GetDeviceBufferMemoryRequirementsKHR);
GETPROCADDR(GetDeviceImageMemoryRequirementsKHR);
GETPROCADDR(GetDeviceImageSparseMemoryRequirementsKHR);
GETPROCADDR(CreateSamplerYcbcrConversionKHR);
GETPROCADDR(DestroySamplerYcbcrConversionKHR);
GETPROCADDR(GetDescriptorSetLayoutSupportKHR);
GETPROCADDR(GetCalibratedTimestampsEXT);
GETPROCADDR(CreateRenderPass2KHR);
GETPROCADDR(CmdBeginRenderPass2KHR);
GETPROCADDR(CmdNextSubpass2KHR);
GETPROCADDR(CmdEndRenderPass2KHR);
GETPROCADDR(GetSemaphoreCounterValueKHR);
GETPROCADDR(WaitSemaphoresKHR);
GETPROCADDR(SignalSemaphoreKHR);
GETPROCADDR(CmdDrawIndirectCountKHR);
GETPROCADDR(CmdDrawIndirectCountAMD);
GETPROCADDR(CmdDrawIndexedIndirectCountKHR);
GETPROCADDR(CmdDrawIndexedIndirectCountAMD);
GETPROCADDR(GetRayTracingShaderGroupHandlesNV);
GETPROCADDR(GetBufferOpaqueCaptureAddressKHR);
GETPROCADDR(GetBufferDeviceAddressKHR);
GETPROCADDR(GetBufferDeviceAddressEXT);
GETPROCADDR(GetDeviceMemoryOpaqueCaptureAddressKHR);
GETPROCADDR(CmdSetLineStippleEXT);
GETPROCADDR(CmdSetCullModeEXT);
GETPROCADDR(CmdSetFrontFaceEXT);
GETPROCADDR(CmdSetPrimitiveTopologyEXT);
GETPROCADDR(CmdSetViewportWithCountEXT);
GETPROCADDR(CmdSetScissorWithCountEXT);
GETPROCADDR(CmdBindVertexBuffers2EXT);
GETPROCADDR(CmdSetDepthTestEnableEXT);
GETPROCADDR(CmdSetDepthWriteEnableEXT);
GETPROCADDR(CmdSetDepthCompareOpEXT);
GETPROCADDR(CmdSetDepthBoundsTestEnableEXT);
GETPROCADDR(CmdSetStencilTestEnableEXT);
GETPROCADDR(CmdSetStencilOpEXT);
GETPROCADDR(CmdSetRasterizerDiscardEnableEXT);
GETPROCADDR(CmdSetDepthBiasEnableEXT);
GETPROCADDR(CmdSetPrimitiveRestartEnableEXT);
GETPROCADDR(CreatePrivateDataSlotEXT);
GETPROCADDR(DestroyPrivateDataSlotEXT);
GETPROCADDR(SetPrivateDataEXT);
GETPROCADDR(GetPrivateDataEXT);
GETPROCADDR(CmdCopyBuffer2KHR);
GETPROCADDR(CmdCopyImage2KHR);
GETPROCADDR(CmdBlitImage2KHR);
GETPROCADDR(CmdCopyBufferToImage2KHR);
GETPROCADDR(CmdCopyImageToBuffer2KHR);
GETPROCADDR(CmdResolveImage2KHR);
GETPROCADDR(CmdSetEvent2KHR);
GETPROCADDR(CmdResetEvent2KHR);
GETPROCADDR(CmdWaitEvents2KHR);
GETPROCADDR(CmdPipelineBarrier2KHR);
GETPROCADDR(QueueSubmit2KHR);
GETPROCADDR(CmdWriteTimestamp2KHR);
GETPROCADDR(CmdBeginRenderingKHR);
GETPROCADDR(CmdEndRenderingKHR);
GETPROCADDR(GetImageSubresourceLayout2EXT);
if(skipLock == false) {
	scoped_lock l(global_lock);
return device_dispatch[GetKey(device)].GetDeviceProcAddr(device, pName);}
}VK_LAYER_EXPORT PFN_vkVoidFunction VKAPI_CALL DebuggerLayer_GetInstanceProcAddr(VkInstance instance, const char* pName) {
if (GetWindowName() == "vkDetails.exe") { GETPROCADDR(CreateDevice); GETPROCADDR(CreateInstance); return instance_dispatch[GetKey(instance)].GetInstanceProcAddr(instance, pName); }
GETPROCADDR(CreateInstance);
GETPROCADDR(DestroyInstance);
GETPROCADDR(EnumeratePhysicalDevices);
GETPROCADDR(GetInstanceProcAddr);
GETPROCADDR(GetPhysicalDeviceProperties);
GETPROCADDR(GetPhysicalDeviceQueueFamilyProperties);
GETPROCADDR(GetPhysicalDeviceMemoryProperties);
GETPROCADDR(GetPhysicalDeviceFeatures);
GETPROCADDR(GetPhysicalDeviceFormatProperties);
GETPROCADDR(GetPhysicalDeviceImageFormatProperties);
GETPROCADDR(CreateDevice);
GETPROCADDR(EnumerateInstanceExtensionProperties);
GETPROCADDR(EnumerateDeviceLayerProperties);
GETPROCADDR(EnumerateDeviceExtensionProperties);
GETPROCADDR(GetPhysicalDeviceSparseImageFormatProperties);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(CreateAndroidSurfaceKHR);
#endif
GETPROCADDR(GetPhysicalDeviceDisplayPropertiesKHR);
GETPROCADDR(GetPhysicalDeviceDisplayPlanePropertiesKHR);
GETPROCADDR(GetDisplayPlaneSupportedDisplaysKHR);
GETPROCADDR(GetDisplayModePropertiesKHR);
GETPROCADDR(CreateDisplayModeKHR);
GETPROCADDR(GetDisplayPlaneCapabilitiesKHR);
GETPROCADDR(CreateDisplayPlaneSurfaceKHR);
GETPROCADDR(DestroySurfaceKHR);
GETPROCADDR(GetPhysicalDeviceSurfaceSupportKHR);
GETPROCADDR(GetPhysicalDeviceSurfaceCapabilitiesKHR);
GETPROCADDR(GetPhysicalDeviceSurfaceFormatsKHR);
GETPROCADDR(GetPhysicalDeviceSurfacePresentModesKHR);
#if defined(VK_USE_PLATFORM_VI_NN)
GETPROCADDR(CreateViSurfaceNN);
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
GETPROCADDR(CreateWaylandSurfaceKHR);
#endif
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
GETPROCADDR(GetPhysicalDeviceWaylandPresentationSupportKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(CreateWin32SurfaceKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetPhysicalDeviceWin32PresentationSupportKHR);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
GETPROCADDR(CreateXlibSurfaceKHR);
#endif
#if defined(VK_USE_PLATFORM_XLIB_KHR)
GETPROCADDR(GetPhysicalDeviceXlibPresentationSupportKHR);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
GETPROCADDR(CreateXcbSurfaceKHR);
#endif
#if defined(VK_USE_PLATFORM_XCB_KHR)
GETPROCADDR(GetPhysicalDeviceXcbPresentationSupportKHR);
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
GETPROCADDR(CreateDirectFBSurfaceEXT);
#endif
#if defined(VK_USE_PLATFORM_DIRECTFB_EXT)
GETPROCADDR(GetPhysicalDeviceDirectFBPresentationSupportEXT);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(CreateImagePipeSurfaceFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_GGP)
GETPROCADDR(CreateStreamDescriptorSurfaceGGP);
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
GETPROCADDR(CreateScreenSurfaceQNX);
#endif
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
GETPROCADDR(GetPhysicalDeviceScreenPresentationSupportQNX);
#endif
GETPROCADDR(CreateDebugReportCallbackEXT);
GETPROCADDR(DestroyDebugReportCallbackEXT);
GETPROCADDR(DebugReportMessageEXT);
GETPROCADDR(GetPhysicalDeviceExternalImageFormatPropertiesNV);
GETPROCADDR(GetPhysicalDeviceFeatures2);
GETPROCADDR(GetPhysicalDeviceProperties2);
GETPROCADDR(GetPhysicalDeviceFormatProperties2);
GETPROCADDR(GetPhysicalDeviceImageFormatProperties2);
GETPROCADDR(GetPhysicalDeviceQueueFamilyProperties2);
GETPROCADDR(GetPhysicalDeviceMemoryProperties2);
GETPROCADDR(GetPhysicalDeviceSparseImageFormatProperties2);
GETPROCADDR(GetPhysicalDeviceExternalBufferProperties);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetPhysicalDeviceExternalMemorySciBufPropertiesNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetPhysicalDeviceSciBufAttributesNV);
#endif
GETPROCADDR(GetPhysicalDeviceExternalSemaphoreProperties);
GETPROCADDR(GetPhysicalDeviceExternalFenceProperties);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetPhysicalDeviceSciSyncAttributesNV);
#endif
GETPROCADDR(ReleaseDisplayEXT);
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
GETPROCADDR(AcquireXlibDisplayEXT);
#endif
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
GETPROCADDR(GetRandROutputDisplayEXT);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(AcquireWinrtDisplayNV);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetWinrtDisplayNV);
#endif
GETPROCADDR(GetPhysicalDeviceSurfaceCapabilities2EXT);
GETPROCADDR(EnumeratePhysicalDeviceGroups);
GETPROCADDR(GetPhysicalDevicePresentRectanglesKHR);
#if defined(VK_USE_PLATFORM_IOS_MVK)
GETPROCADDR(CreateIOSSurfaceMVK);
#endif
#if defined(VK_USE_PLATFORM_MACOS_MVK)
GETPROCADDR(CreateMacOSSurfaceMVK);
#endif
#if defined(VK_USE_PLATFORM_METAL_EXT)
GETPROCADDR(CreateMetalSurfaceEXT);
#endif
GETPROCADDR(GetPhysicalDeviceMultisamplePropertiesEXT);
GETPROCADDR(GetPhysicalDeviceSurfaceCapabilities2KHR);
GETPROCADDR(GetPhysicalDeviceSurfaceFormats2KHR);
GETPROCADDR(GetPhysicalDeviceDisplayProperties2KHR);
GETPROCADDR(GetPhysicalDeviceDisplayPlaneProperties2KHR);
GETPROCADDR(GetDisplayModeProperties2KHR);
GETPROCADDR(GetDisplayPlaneCapabilities2KHR);
GETPROCADDR(GetPhysicalDeviceCalibrateableTimeDomainsKHR);
GETPROCADDR(CreateDebugUtilsMessengerEXT);
GETPROCADDR(DestroyDebugUtilsMessengerEXT);
GETPROCADDR(SubmitDebugUtilsMessageEXT);
GETPROCADDR(GetPhysicalDeviceCooperativeMatrixPropertiesNV);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetPhysicalDeviceSurfacePresentModes2EXT);
#endif
GETPROCADDR(EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR);
GETPROCADDR(GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR);
GETPROCADDR(CreateHeadlessSurfaceEXT);
GETPROCADDR(GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV);
GETPROCADDR(GetPhysicalDeviceToolProperties);
GETPROCADDR(GetPhysicalDeviceFragmentShadingRatesKHR);
GETPROCADDR(GetPhysicalDeviceVideoCapabilitiesKHR);
GETPROCADDR(GetPhysicalDeviceVideoFormatPropertiesKHR);
GETPROCADDR(GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR);
GETPROCADDR(AcquireDrmDisplayEXT);
GETPROCADDR(GetDrmDisplayEXT);
GETPROCADDR(GetPhysicalDeviceOpticalFlowImageFormatsNV);
GETPROCADDR(GetPhysicalDeviceCooperativeMatrixPropertiesKHR);
GETPROCADDR(GetPhysicalDeviceFeatures2KHR);
GETPROCADDR(GetPhysicalDeviceProperties2KHR);
GETPROCADDR(GetPhysicalDeviceFormatProperties2KHR);
GETPROCADDR(GetPhysicalDeviceImageFormatProperties2KHR);
GETPROCADDR(GetPhysicalDeviceQueueFamilyProperties2KHR);
GETPROCADDR(GetPhysicalDeviceMemoryProperties2KHR);
GETPROCADDR(GetPhysicalDeviceSparseImageFormatProperties2KHR);
GETPROCADDR(GetPhysicalDeviceExternalBufferPropertiesKHR);
GETPROCADDR(GetPhysicalDeviceExternalSemaphorePropertiesKHR);
GETPROCADDR(GetPhysicalDeviceExternalFencePropertiesKHR);
GETPROCADDR(EnumeratePhysicalDeviceGroupsKHR);
GETPROCADDR(GetPhysicalDeviceCalibrateableTimeDomainsEXT);
GETPROCADDR(GetPhysicalDeviceToolPropertiesEXT);
GETPROCADDR(GetDeviceProcAddr);
GETPROCADDR(DestroyDevice);
GETPROCADDR(GetDeviceQueue);
GETPROCADDR(QueueSubmit);
GETPROCADDR(QueueWaitIdle);
GETPROCADDR(DeviceWaitIdle);
GETPROCADDR(AllocateMemory);
GETPROCADDR(FreeMemory);
GETPROCADDR(MapMemory);
GETPROCADDR(UnmapMemory);
GETPROCADDR(FlushMappedMemoryRanges);
GETPROCADDR(InvalidateMappedMemoryRanges);
GETPROCADDR(GetDeviceMemoryCommitment);
GETPROCADDR(GetBufferMemoryRequirements);
GETPROCADDR(BindBufferMemory);
GETPROCADDR(GetImageMemoryRequirements);
GETPROCADDR(BindImageMemory);
GETPROCADDR(GetImageSparseMemoryRequirements);
GETPROCADDR(QueueBindSparse);
GETPROCADDR(CreateFence);
GETPROCADDR(DestroyFence);
GETPROCADDR(ResetFences);
GETPROCADDR(GetFenceStatus);
GETPROCADDR(WaitForFences);
GETPROCADDR(CreateSemaphore);
GETPROCADDR(DestroySemaphore);
GETPROCADDR(CreateEvent);
GETPROCADDR(DestroyEvent);
GETPROCADDR(GetEventStatus);
GETPROCADDR(SetEvent);
GETPROCADDR(ResetEvent);
GETPROCADDR(CreateQueryPool);
GETPROCADDR(DestroyQueryPool);
GETPROCADDR(GetQueryPoolResults);
GETPROCADDR(ResetQueryPool);
GETPROCADDR(CreateBuffer);
GETPROCADDR(DestroyBuffer);
GETPROCADDR(CreateBufferView);
GETPROCADDR(DestroyBufferView);
GETPROCADDR(CreateImage);
GETPROCADDR(DestroyImage);
GETPROCADDR(GetImageSubresourceLayout);
GETPROCADDR(CreateImageView);
GETPROCADDR(DestroyImageView);
GETPROCADDR(CreateShaderModule);
GETPROCADDR(DestroyShaderModule);
GETPROCADDR(CreatePipelineCache);
GETPROCADDR(DestroyPipelineCache);
GETPROCADDR(GetPipelineCacheData);
GETPROCADDR(MergePipelineCaches);
GETPROCADDR(CreateGraphicsPipelines);
GETPROCADDR(CreateComputePipelines);
GETPROCADDR(GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI);
GETPROCADDR(DestroyPipeline);
GETPROCADDR(CreatePipelineLayout);
GETPROCADDR(DestroyPipelineLayout);
GETPROCADDR(CreateSampler);
GETPROCADDR(DestroySampler);
GETPROCADDR(CreateDescriptorSetLayout);
GETPROCADDR(DestroyDescriptorSetLayout);
GETPROCADDR(CreateDescriptorPool);
GETPROCADDR(DestroyDescriptorPool);
GETPROCADDR(ResetDescriptorPool);
GETPROCADDR(AllocateDescriptorSets);
GETPROCADDR(FreeDescriptorSets);
GETPROCADDR(UpdateDescriptorSets);
GETPROCADDR(CreateFramebuffer);
GETPROCADDR(DestroyFramebuffer);
GETPROCADDR(CreateRenderPass);
GETPROCADDR(DestroyRenderPass);
GETPROCADDR(GetRenderAreaGranularity);
GETPROCADDR(GetRenderingAreaGranularityKHR);
GETPROCADDR(CreateCommandPool);
GETPROCADDR(DestroyCommandPool);
GETPROCADDR(ResetCommandPool);
GETPROCADDR(AllocateCommandBuffers);
GETPROCADDR(FreeCommandBuffers);
GETPROCADDR(BeginCommandBuffer);
GETPROCADDR(EndCommandBuffer);
GETPROCADDR(ResetCommandBuffer);
GETPROCADDR(CmdBindPipeline);
GETPROCADDR(CmdSetAttachmentFeedbackLoopEnableEXT);
GETPROCADDR(CmdSetViewport);
GETPROCADDR(CmdSetScissor);
GETPROCADDR(CmdSetLineWidth);
GETPROCADDR(CmdSetDepthBias);
GETPROCADDR(CmdSetBlendConstants);
GETPROCADDR(CmdSetDepthBounds);
GETPROCADDR(CmdSetStencilCompareMask);
GETPROCADDR(CmdSetStencilWriteMask);
GETPROCADDR(CmdSetStencilReference);
GETPROCADDR(CmdBindDescriptorSets);
GETPROCADDR(CmdBindIndexBuffer);
GETPROCADDR(CmdBindVertexBuffers);
GETPROCADDR(CmdDraw);
GETPROCADDR(CmdDrawIndexed);
GETPROCADDR(CmdDrawMultiEXT);
GETPROCADDR(CmdDrawMultiIndexedEXT);
GETPROCADDR(CmdDrawIndirect);
GETPROCADDR(CmdDrawIndexedIndirect);
GETPROCADDR(CmdDispatch);
GETPROCADDR(CmdDispatchIndirect);
GETPROCADDR(CmdSubpassShadingHUAWEI);
GETPROCADDR(CmdDrawClusterHUAWEI);
GETPROCADDR(CmdDrawClusterIndirectHUAWEI);
GETPROCADDR(CmdUpdatePipelineIndirectBufferNV);
GETPROCADDR(CmdCopyBuffer);
GETPROCADDR(CmdCopyImage);
GETPROCADDR(CmdBlitImage);
GETPROCADDR(CmdCopyBufferToImage);
GETPROCADDR(CmdCopyImageToBuffer);
GETPROCADDR(CmdCopyMemoryIndirectNV);
GETPROCADDR(CmdCopyMemoryToImageIndirectNV);
GETPROCADDR(CmdUpdateBuffer);
GETPROCADDR(CmdFillBuffer);
GETPROCADDR(CmdClearColorImage);
GETPROCADDR(CmdClearDepthStencilImage);
GETPROCADDR(CmdClearAttachments);
GETPROCADDR(CmdResolveImage);
GETPROCADDR(CmdSetEvent);
GETPROCADDR(CmdResetEvent);
GETPROCADDR(CmdWaitEvents);
GETPROCADDR(CmdPipelineBarrier);
GETPROCADDR(CmdBeginQuery);
GETPROCADDR(CmdEndQuery);
GETPROCADDR(CmdBeginConditionalRenderingEXT);
GETPROCADDR(CmdEndConditionalRenderingEXT);
GETPROCADDR(CmdResetQueryPool);
GETPROCADDR(CmdWriteTimestamp);
GETPROCADDR(CmdCopyQueryPoolResults);
GETPROCADDR(CmdPushConstants);
GETPROCADDR(CmdBeginRenderPass);
GETPROCADDR(CmdNextSubpass);
GETPROCADDR(CmdEndRenderPass);
GETPROCADDR(CmdExecuteCommands);
GETPROCADDR(CreateSharedSwapchainsKHR);
GETPROCADDR(CreateSwapchainKHR);
GETPROCADDR(DestroySwapchainKHR);
GETPROCADDR(GetSwapchainImagesKHR);
GETPROCADDR(AcquireNextImageKHR);
GETPROCADDR(QueuePresentKHR);
GETPROCADDR(DebugMarkerSetObjectNameEXT);
GETPROCADDR(DebugMarkerSetObjectTagEXT);
GETPROCADDR(CmdDebugMarkerBeginEXT);
GETPROCADDR(CmdDebugMarkerEndEXT);
GETPROCADDR(CmdDebugMarkerInsertEXT);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandleNV);
#endif
GETPROCADDR(CmdExecuteGeneratedCommandsNV);
GETPROCADDR(CmdPreprocessGeneratedCommandsNV);
GETPROCADDR(CmdBindPipelineShaderGroupNV);
GETPROCADDR(GetGeneratedCommandsMemoryRequirementsNV);
GETPROCADDR(CreateIndirectCommandsLayoutNV);
GETPROCADDR(DestroyIndirectCommandsLayoutNV);
GETPROCADDR(CmdPushDescriptorSetKHR);
GETPROCADDR(TrimCommandPool);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetMemoryWin32HandlePropertiesKHR);
#endif
GETPROCADDR(GetMemoryFdKHR);
GETPROCADDR(GetMemoryFdPropertiesKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetMemoryZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetMemoryZirconHandlePropertiesFUCHSIA);
#endif
GETPROCADDR(GetMemoryRemoteAddressNV);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetMemorySciBufNV);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetSemaphoreWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ImportSemaphoreWin32HandleKHR);
#endif
GETPROCADDR(GetSemaphoreFdKHR);
GETPROCADDR(ImportSemaphoreFdKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetSemaphoreZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(ImportSemaphoreZirconHandleFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetFenceWin32HandleKHR);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ImportFenceWin32HandleKHR);
#endif
GETPROCADDR(GetFenceFdKHR);
GETPROCADDR(ImportFenceFdKHR);
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetFenceSciSyncFenceNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetFenceSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportFenceSciSyncFenceNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportFenceSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(GetSemaphoreSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(ImportSemaphoreSciSyncObjNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(CreateSemaphoreSciSyncPoolNV);
#endif
#if defined(VK_USE_PLATFORM_SCI)
GETPROCADDR(DestroySemaphoreSciSyncPoolNV);
#endif
GETPROCADDR(DisplayPowerControlEXT);
GETPROCADDR(RegisterDeviceEventEXT);
GETPROCADDR(RegisterDisplayEventEXT);
GETPROCADDR(GetSwapchainCounterEXT);
GETPROCADDR(GetDeviceGroupPeerMemoryFeatures);
GETPROCADDR(BindBufferMemory2);
GETPROCADDR(BindImageMemory2);
GETPROCADDR(CmdSetDeviceMask);
GETPROCADDR(GetDeviceGroupPresentCapabilitiesKHR);
GETPROCADDR(GetDeviceGroupSurfacePresentModesKHR);
GETPROCADDR(AcquireNextImage2KHR);
GETPROCADDR(CmdDispatchBase);
GETPROCADDR(CreateDescriptorUpdateTemplate);
GETPROCADDR(DestroyDescriptorUpdateTemplate);
GETPROCADDR(UpdateDescriptorSetWithTemplate);
GETPROCADDR(CmdPushDescriptorSetWithTemplateKHR);
GETPROCADDR(SetHdrMetadataEXT);
GETPROCADDR(GetSwapchainStatusKHR);
GETPROCADDR(GetRefreshCycleDurationGOOGLE);
GETPROCADDR(GetPastPresentationTimingGOOGLE);
GETPROCADDR(CmdSetViewportWScalingNV);
GETPROCADDR(CmdSetDiscardRectangleEXT);
GETPROCADDR(CmdSetDiscardRectangleEnableEXT);
GETPROCADDR(CmdSetDiscardRectangleModeEXT);
GETPROCADDR(CmdSetSampleLocationsEXT);
GETPROCADDR(GetBufferMemoryRequirements2);
GETPROCADDR(GetImageMemoryRequirements2);
GETPROCADDR(GetImageSparseMemoryRequirements2);
GETPROCADDR(GetDeviceBufferMemoryRequirements);
GETPROCADDR(GetDeviceImageMemoryRequirements);
GETPROCADDR(GetDeviceImageSparseMemoryRequirements);
GETPROCADDR(CreateSamplerYcbcrConversion);
GETPROCADDR(DestroySamplerYcbcrConversion);
GETPROCADDR(GetDeviceQueue2);
GETPROCADDR(CreateValidationCacheEXT);
GETPROCADDR(DestroyValidationCacheEXT);
GETPROCADDR(GetValidationCacheDataEXT);
GETPROCADDR(MergeValidationCachesEXT);
GETPROCADDR(GetDescriptorSetLayoutSupport);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetSwapchainGrallocUsageANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetSwapchainGrallocUsage2ANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(AcquireImageANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(QueueSignalReleaseImageANDROID);
#endif
GETPROCADDR(GetShaderInfoAMD);
GETPROCADDR(SetLocalDimmingAMD);
GETPROCADDR(GetCalibratedTimestampsKHR);
GETPROCADDR(SetDebugUtilsObjectNameEXT);
GETPROCADDR(SetDebugUtilsObjectTagEXT);
GETPROCADDR(QueueBeginDebugUtilsLabelEXT);
GETPROCADDR(QueueEndDebugUtilsLabelEXT);
GETPROCADDR(QueueInsertDebugUtilsLabelEXT);
GETPROCADDR(CmdBeginDebugUtilsLabelEXT);
GETPROCADDR(CmdEndDebugUtilsLabelEXT);
GETPROCADDR(CmdInsertDebugUtilsLabelEXT);
GETPROCADDR(GetMemoryHostPointerPropertiesEXT);
GETPROCADDR(CmdWriteBufferMarkerAMD);
GETPROCADDR(CreateRenderPass2);
GETPROCADDR(CmdBeginRenderPass2);
GETPROCADDR(CmdNextSubpass2);
GETPROCADDR(CmdEndRenderPass2);
GETPROCADDR(GetSemaphoreCounterValue);
GETPROCADDR(WaitSemaphores);
GETPROCADDR(SignalSemaphore);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetAndroidHardwareBufferPropertiesANDROID);
#endif
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
GETPROCADDR(GetMemoryAndroidHardwareBufferANDROID);
#endif
GETPROCADDR(CmdDrawIndirectCount);
GETPROCADDR(CmdDrawIndexedIndirectCount);
GETPROCADDR(CmdSetCheckpointNV);
GETPROCADDR(GetQueueCheckpointDataNV);
GETPROCADDR(CmdBindTransformFeedbackBuffersEXT);
GETPROCADDR(CmdBeginTransformFeedbackEXT);
GETPROCADDR(CmdEndTransformFeedbackEXT);
GETPROCADDR(CmdBeginQueryIndexedEXT);
GETPROCADDR(CmdEndQueryIndexedEXT);
GETPROCADDR(CmdDrawIndirectByteCountEXT);
GETPROCADDR(CmdSetExclusiveScissorNV);
GETPROCADDR(CmdSetExclusiveScissorEnableNV);
GETPROCADDR(CmdBindShadingRateImageNV);
GETPROCADDR(CmdSetViewportShadingRatePaletteNV);
GETPROCADDR(CmdSetCoarseSampleOrderNV);
GETPROCADDR(CmdDrawMeshTasksNV);
GETPROCADDR(CmdDrawMeshTasksIndirectNV);
GETPROCADDR(CmdDrawMeshTasksIndirectCountNV);
GETPROCADDR(CmdDrawMeshTasksEXT);
GETPROCADDR(CmdDrawMeshTasksIndirectEXT);
GETPROCADDR(CmdDrawMeshTasksIndirectCountEXT);
GETPROCADDR(CompileDeferredNV);
GETPROCADDR(CreateAccelerationStructureNV);
GETPROCADDR(CmdBindInvocationMaskHUAWEI);
GETPROCADDR(DestroyAccelerationStructureKHR);
GETPROCADDR(DestroyAccelerationStructureNV);
GETPROCADDR(GetAccelerationStructureMemoryRequirementsNV);
GETPROCADDR(BindAccelerationStructureMemoryNV);
GETPROCADDR(CmdCopyAccelerationStructureNV);
GETPROCADDR(CmdCopyAccelerationStructureKHR);
GETPROCADDR(CopyAccelerationStructureKHR);
GETPROCADDR(CmdCopyAccelerationStructureToMemoryKHR);
GETPROCADDR(CopyAccelerationStructureToMemoryKHR);
GETPROCADDR(CmdCopyMemoryToAccelerationStructureKHR);
GETPROCADDR(CopyMemoryToAccelerationStructureKHR);
GETPROCADDR(CmdWriteAccelerationStructuresPropertiesKHR);
GETPROCADDR(CmdWriteAccelerationStructuresPropertiesNV);
GETPROCADDR(CmdBuildAccelerationStructureNV);
GETPROCADDR(WriteAccelerationStructuresPropertiesKHR);
GETPROCADDR(CmdTraceRaysKHR);
GETPROCADDR(CmdTraceRaysNV);
GETPROCADDR(GetRayTracingShaderGroupHandlesKHR);
GETPROCADDR(GetRayTracingCaptureReplayShaderGroupHandlesKHR);
GETPROCADDR(GetAccelerationStructureHandleNV);
GETPROCADDR(CreateRayTracingPipelinesNV);
GETPROCADDR(CreateRayTracingPipelinesKHR);
GETPROCADDR(CmdTraceRaysIndirectKHR);
GETPROCADDR(CmdTraceRaysIndirect2KHR);
GETPROCADDR(GetDeviceAccelerationStructureCompatibilityKHR);
GETPROCADDR(GetRayTracingShaderGroupStackSizeKHR);
GETPROCADDR(CmdSetRayTracingPipelineStackSizeKHR);
GETPROCADDR(GetImageViewHandleNVX);
GETPROCADDR(GetImageViewAddressNVX);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(GetDeviceGroupSurfacePresentModes2EXT);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(AcquireFullScreenExclusiveModeEXT);
#endif
#if defined(VK_USE_PLATFORM_WIN32_KHR)
GETPROCADDR(ReleaseFullScreenExclusiveModeEXT);
#endif
GETPROCADDR(AcquireProfilingLockKHR);
GETPROCADDR(ReleaseProfilingLockKHR);
GETPROCADDR(GetImageDrmFormatModifierPropertiesEXT);
GETPROCADDR(GetBufferOpaqueCaptureAddress);
GETPROCADDR(GetBufferDeviceAddress);
GETPROCADDR(InitializePerformanceApiINTEL);
GETPROCADDR(UninitializePerformanceApiINTEL);
GETPROCADDR(CmdSetPerformanceMarkerINTEL);
GETPROCADDR(CmdSetPerformanceStreamMarkerINTEL);
GETPROCADDR(CmdSetPerformanceOverrideINTEL);
GETPROCADDR(AcquirePerformanceConfigurationINTEL);
GETPROCADDR(ReleasePerformanceConfigurationINTEL);
GETPROCADDR(QueueSetPerformanceConfigurationINTEL);
GETPROCADDR(GetPerformanceParameterINTEL);
GETPROCADDR(GetDeviceMemoryOpaqueCaptureAddress);
GETPROCADDR(GetPipelineExecutablePropertiesKHR);
GETPROCADDR(GetPipelineExecutableStatisticsKHR);
GETPROCADDR(GetPipelineExecutableInternalRepresentationsKHR);
GETPROCADDR(CreateAccelerationStructureKHR);
GETPROCADDR(CmdBuildAccelerationStructuresKHR);
GETPROCADDR(CmdBuildAccelerationStructuresIndirectKHR);
GETPROCADDR(BuildAccelerationStructuresKHR);
GETPROCADDR(GetAccelerationStructureDeviceAddressKHR);
GETPROCADDR(CreateDeferredOperationKHR);
GETPROCADDR(DestroyDeferredOperationKHR);
GETPROCADDR(GetDeferredOperationMaxConcurrencyKHR);
GETPROCADDR(GetDeferredOperationResultKHR);
GETPROCADDR(DeferredOperationJoinKHR);
GETPROCADDR(GetPipelineIndirectMemoryRequirementsNV);
GETPROCADDR(GetPipelineIndirectDeviceAddressNV);
GETPROCADDR(CmdSetCullMode);
GETPROCADDR(CmdSetFrontFace);
GETPROCADDR(CmdSetPrimitiveTopology);
GETPROCADDR(CmdSetViewportWithCount);
GETPROCADDR(CmdSetScissorWithCount);
GETPROCADDR(CmdBindIndexBuffer2KHR);
GETPROCADDR(CmdBindVertexBuffers2);
GETPROCADDR(CmdSetDepthTestEnable);
GETPROCADDR(CmdSetDepthWriteEnable);
GETPROCADDR(CmdSetDepthCompareOp);
GETPROCADDR(CmdSetDepthBoundsTestEnable);
GETPROCADDR(CmdSetStencilTestEnable);
GETPROCADDR(CmdSetStencilOp);
GETPROCADDR(CmdSetPatchControlPointsEXT);
GETPROCADDR(CmdSetRasterizerDiscardEnable);
GETPROCADDR(CmdSetDepthBiasEnable);
GETPROCADDR(CmdSetLogicOpEXT);
GETPROCADDR(CmdSetPrimitiveRestartEnable);
GETPROCADDR(CmdSetTessellationDomainOriginEXT);
GETPROCADDR(CmdSetDepthClampEnableEXT);
GETPROCADDR(CmdSetPolygonModeEXT);
GETPROCADDR(CmdSetRasterizationSamplesEXT);
GETPROCADDR(CmdSetSampleMaskEXT);
GETPROCADDR(CmdSetAlphaToCoverageEnableEXT);
GETPROCADDR(CmdSetAlphaToOneEnableEXT);
GETPROCADDR(CmdSetLogicOpEnableEXT);
GETPROCADDR(CmdSetColorBlendEnableEXT);
GETPROCADDR(CmdSetColorBlendEquationEXT);
GETPROCADDR(CmdSetColorWriteMaskEXT);
GETPROCADDR(CmdSetRasterizationStreamEXT);
GETPROCADDR(CmdSetConservativeRasterizationModeEXT);
GETPROCADDR(CmdSetExtraPrimitiveOverestimationSizeEXT);
GETPROCADDR(CmdSetDepthClipEnableEXT);
GETPROCADDR(CmdSetSampleLocationsEnableEXT);
GETPROCADDR(CmdSetColorBlendAdvancedEXT);
GETPROCADDR(CmdSetProvokingVertexModeEXT);
GETPROCADDR(CmdSetLineRasterizationModeEXT);
GETPROCADDR(CmdSetLineStippleEnableEXT);
GETPROCADDR(CmdSetDepthClipNegativeOneToOneEXT);
GETPROCADDR(CmdSetViewportWScalingEnableNV);
GETPROCADDR(CmdSetViewportSwizzleNV);
GETPROCADDR(CmdSetCoverageToColorEnableNV);
GETPROCADDR(CmdSetCoverageToColorLocationNV);
GETPROCADDR(CmdSetCoverageModulationModeNV);
GETPROCADDR(CmdSetCoverageModulationTableEnableNV);
GETPROCADDR(CmdSetCoverageModulationTableNV);
GETPROCADDR(CmdSetShadingRateImageEnableNV);
GETPROCADDR(CmdSetCoverageReductionModeNV);
GETPROCADDR(CmdSetRepresentativeFragmentTestEnableNV);
GETPROCADDR(CreatePrivateDataSlot);
GETPROCADDR(DestroyPrivateDataSlot);
GETPROCADDR(SetPrivateData);
GETPROCADDR(GetPrivateData);
GETPROCADDR(CmdCopyBuffer2);
GETPROCADDR(CmdCopyImage2);
GETPROCADDR(CmdBlitImage2);
GETPROCADDR(CmdCopyBufferToImage2);
GETPROCADDR(CmdCopyImageToBuffer2);
GETPROCADDR(CmdResolveImage2);
GETPROCADDR(CmdSetFragmentShadingRateKHR);
GETPROCADDR(CmdSetFragmentShadingRateEnumNV);
GETPROCADDR(GetAccelerationStructureBuildSizesKHR);
GETPROCADDR(CmdSetVertexInputEXT);
GETPROCADDR(CmdSetColorWriteEnableEXT);
GETPROCADDR(CmdSetEvent2);
GETPROCADDR(CmdResetEvent2);
GETPROCADDR(CmdWaitEvents2);
GETPROCADDR(CmdPipelineBarrier2);
GETPROCADDR(QueueSubmit2);
GETPROCADDR(CmdWriteTimestamp2);
GETPROCADDR(CmdWriteBufferMarker2AMD);
GETPROCADDR(GetQueueCheckpointData2NV);
GETPROCADDR(CopyMemoryToImageEXT);
GETPROCADDR(CopyImageToMemoryEXT);
GETPROCADDR(CopyImageToImageEXT);
GETPROCADDR(TransitionImageLayoutEXT);
GETPROCADDR(CreateVideoSessionKHR);
GETPROCADDR(DestroyVideoSessionKHR);
GETPROCADDR(CreateVideoSessionParametersKHR);
GETPROCADDR(UpdateVideoSessionParametersKHR);
GETPROCADDR(GetEncodedVideoSessionParametersKHR);
GETPROCADDR(DestroyVideoSessionParametersKHR);
GETPROCADDR(GetVideoSessionMemoryRequirementsKHR);
GETPROCADDR(BindVideoSessionMemoryKHR);
GETPROCADDR(CmdDecodeVideoKHR);
GETPROCADDR(CmdBeginVideoCodingKHR);
GETPROCADDR(CmdControlVideoCodingKHR);
GETPROCADDR(CmdEndVideoCodingKHR);
GETPROCADDR(CmdEncodeVideoKHR);
GETPROCADDR(CmdDecompressMemoryNV);
GETPROCADDR(CmdDecompressMemoryIndirectCountNV);
GETPROCADDR(CreateCuModuleNVX);
GETPROCADDR(CreateCuFunctionNVX);
GETPROCADDR(DestroyCuModuleNVX);
GETPROCADDR(DestroyCuFunctionNVX);
GETPROCADDR(CmdCuLaunchKernelNVX);
GETPROCADDR(GetDescriptorSetLayoutSizeEXT);
GETPROCADDR(GetDescriptorSetLayoutBindingOffsetEXT);
GETPROCADDR(GetDescriptorEXT);
GETPROCADDR(CmdBindDescriptorBuffersEXT);
GETPROCADDR(CmdSetDescriptorBufferOffsetsEXT);
GETPROCADDR(CmdBindDescriptorBufferEmbeddedSamplersEXT);
GETPROCADDR(GetBufferOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetImageOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetImageViewOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetSamplerOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(GetAccelerationStructureOpaqueCaptureDescriptorDataEXT);
GETPROCADDR(SetDeviceMemoryPriorityEXT);
GETPROCADDR(WaitForPresentKHR);
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(CreateBufferCollectionFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(SetBufferCollectionBufferConstraintsFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(SetBufferCollectionImageConstraintsFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(DestroyBufferCollectionFUCHSIA);
#endif
#if defined(VK_USE_PLATFORM_FUCHSIA)
GETPROCADDR(GetBufferCollectionPropertiesFUCHSIA);
#endif
GETPROCADDR(CreateCudaModuleNV);
GETPROCADDR(GetCudaModuleCacheNV);
GETPROCADDR(CreateCudaFunctionNV);
GETPROCADDR(DestroyCudaModuleNV);
GETPROCADDR(DestroyCudaFunctionNV);
GETPROCADDR(CmdCudaLaunchKernelNV);
GETPROCADDR(CmdBeginRendering);
GETPROCADDR(CmdEndRendering);
GETPROCADDR(GetDescriptorSetLayoutHostMappingInfoVALVE);
GETPROCADDR(GetDescriptorSetHostMappingVALVE);
GETPROCADDR(CreateMicromapEXT);
GETPROCADDR(CmdBuildMicromapsEXT);
GETPROCADDR(BuildMicromapsEXT);
GETPROCADDR(DestroyMicromapEXT);
GETPROCADDR(CmdCopyMicromapEXT);
GETPROCADDR(CopyMicromapEXT);
GETPROCADDR(CmdCopyMicromapToMemoryEXT);
GETPROCADDR(CopyMicromapToMemoryEXT);
GETPROCADDR(CmdCopyMemoryToMicromapEXT);
GETPROCADDR(CopyMemoryToMicromapEXT);
GETPROCADDR(CmdWriteMicromapsPropertiesEXT);
GETPROCADDR(WriteMicromapsPropertiesEXT);
GETPROCADDR(GetDeviceMicromapCompatibilityEXT);
GETPROCADDR(GetMicromapBuildSizesEXT);
GETPROCADDR(GetShaderModuleIdentifierEXT);
GETPROCADDR(GetShaderModuleCreateInfoIdentifierEXT);
GETPROCADDR(GetImageSubresourceLayout2KHR);
GETPROCADDR(GetPipelinePropertiesEXT);
#if defined(VK_USE_PLATFORM_METAL_EXT)
GETPROCADDR(ExportMetalObjectsEXT);
#endif
GETPROCADDR(GetFramebufferTilePropertiesQCOM);
GETPROCADDR(GetDynamicRenderingTilePropertiesQCOM);
GETPROCADDR(CreateOpticalFlowSessionNV);
GETPROCADDR(DestroyOpticalFlowSessionNV);
GETPROCADDR(BindOpticalFlowSessionImageNV);
GETPROCADDR(CmdOpticalFlowExecuteNV);
GETPROCADDR(GetDeviceFaultInfoEXT);
GETPROCADDR(CmdSetDepthBias2EXT);
GETPROCADDR(ReleaseSwapchainImagesEXT);
GETPROCADDR(GetDeviceImageSubresourceLayoutKHR);
GETPROCADDR(MapMemory2KHR);
GETPROCADDR(UnmapMemory2KHR);
GETPROCADDR(CreateShadersEXT);
GETPROCADDR(DestroyShaderEXT);
GETPROCADDR(GetShaderBinaryDataEXT);
GETPROCADDR(CmdBindShadersEXT);
#if defined(VK_USE_PLATFORM_SCREEN_QNX)
GETPROCADDR(GetScreenBufferPropertiesQNX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(GetExecutionGraphPipelineScratchSizeAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(GetExecutionGraphPipelineNodeIndexAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CreateExecutionGraphPipelinesAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdInitializeGraphScratchMemoryAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphIndirectAMDX);
#endif
#if defined(VK_ENABLE_BETA_EXTENSIONS)
GETPROCADDR(CmdDispatchGraphIndirectCountAMDX);
#endif
GETPROCADDR(CmdBindDescriptorSets2KHR);
GETPROCADDR(CmdPushConstants2KHR);
GETPROCADDR(CmdPushDescriptorSet2KHR);
GETPROCADDR(CmdPushDescriptorSetWithTemplate2KHR);
GETPROCADDR(CmdSetDescriptorBufferOffsets2EXT);
GETPROCADDR(CmdBindDescriptorBufferEmbeddedSamplers2EXT);
GETPROCADDR(SetLatencySleepModeNV);
GETPROCADDR(LatencySleepNV);
GETPROCADDR(SetLatencyMarkerNV);
GETPROCADDR(GetLatencyTimingsNV);
GETPROCADDR(QueueNotifyOutOfBandNV);
GETPROCADDR(ResetQueryPoolEXT);
GETPROCADDR(TrimCommandPoolKHR);
GETPROCADDR(GetDeviceGroupPeerMemoryFeaturesKHR);
GETPROCADDR(BindBufferMemory2KHR);
GETPROCADDR(BindImageMemory2KHR);
GETPROCADDR(CmdSetDeviceMaskKHR);
GETPROCADDR(CmdDispatchBaseKHR);
GETPROCADDR(CreateDescriptorUpdateTemplateKHR);
GETPROCADDR(DestroyDescriptorUpdateTemplateKHR);
GETPROCADDR(UpdateDescriptorSetWithTemplateKHR);
GETPROCADDR(GetBufferMemoryRequirements2KHR);
GETPROCADDR(GetImageMemoryRequirements2KHR);
GETPROCADDR(GetImageSparseMemoryRequirements2KHR);
GETPROCADDR(GetDeviceBufferMemoryRequirementsKHR);
GETPROCADDR(GetDeviceImageMemoryRequirementsKHR);
GETPROCADDR(GetDeviceImageSparseMemoryRequirementsKHR);
GETPROCADDR(CreateSamplerYcbcrConversionKHR);
GETPROCADDR(DestroySamplerYcbcrConversionKHR);
GETPROCADDR(GetDescriptorSetLayoutSupportKHR);
GETPROCADDR(GetCalibratedTimestampsEXT);
GETPROCADDR(CreateRenderPass2KHR);
GETPROCADDR(CmdBeginRenderPass2KHR);
GETPROCADDR(CmdNextSubpass2KHR);
GETPROCADDR(CmdEndRenderPass2KHR);
GETPROCADDR(GetSemaphoreCounterValueKHR);
GETPROCADDR(WaitSemaphoresKHR);
GETPROCADDR(SignalSemaphoreKHR);
GETPROCADDR(CmdDrawIndirectCountKHR);
GETPROCADDR(CmdDrawIndirectCountAMD);
GETPROCADDR(CmdDrawIndexedIndirectCountKHR);
GETPROCADDR(CmdDrawIndexedIndirectCountAMD);
GETPROCADDR(GetRayTracingShaderGroupHandlesNV);
GETPROCADDR(GetBufferOpaqueCaptureAddressKHR);
GETPROCADDR(GetBufferDeviceAddressKHR);
GETPROCADDR(GetBufferDeviceAddressEXT);
GETPROCADDR(GetDeviceMemoryOpaqueCaptureAddressKHR);
GETPROCADDR(CmdSetLineStippleEXT);
GETPROCADDR(CmdSetCullModeEXT);
GETPROCADDR(CmdSetFrontFaceEXT);
GETPROCADDR(CmdSetPrimitiveTopologyEXT);
GETPROCADDR(CmdSetViewportWithCountEXT);
GETPROCADDR(CmdSetScissorWithCountEXT);
GETPROCADDR(CmdBindVertexBuffers2EXT);
GETPROCADDR(CmdSetDepthTestEnableEXT);
GETPROCADDR(CmdSetDepthWriteEnableEXT);
GETPROCADDR(CmdSetDepthCompareOpEXT);
GETPROCADDR(CmdSetDepthBoundsTestEnableEXT);
GETPROCADDR(CmdSetStencilTestEnableEXT);
GETPROCADDR(CmdSetStencilOpEXT);
GETPROCADDR(CmdSetRasterizerDiscardEnableEXT);
GETPROCADDR(CmdSetDepthBiasEnableEXT);
GETPROCADDR(CmdSetPrimitiveRestartEnableEXT);
GETPROCADDR(CreatePrivateDataSlotEXT);
GETPROCADDR(DestroyPrivateDataSlotEXT);
GETPROCADDR(SetPrivateDataEXT);
GETPROCADDR(GetPrivateDataEXT);
GETPROCADDR(CmdCopyBuffer2KHR);
GETPROCADDR(CmdCopyImage2KHR);
GETPROCADDR(CmdBlitImage2KHR);
GETPROCADDR(CmdCopyBufferToImage2KHR);
GETPROCADDR(CmdCopyImageToBuffer2KHR);
GETPROCADDR(CmdResolveImage2KHR);
GETPROCADDR(CmdSetEvent2KHR);
GETPROCADDR(CmdResetEvent2KHR);
GETPROCADDR(CmdWaitEvents2KHR);
GETPROCADDR(CmdPipelineBarrier2KHR);
GETPROCADDR(QueueSubmit2KHR);
GETPROCADDR(CmdWriteTimestamp2KHR);
GETPROCADDR(CmdBeginRenderingKHR);
GETPROCADDR(CmdEndRenderingKHR);
GETPROCADDR(GetImageSubresourceLayout2EXT);
if(skipLock == false) {
	scoped_lock l(global_lock);
return instance_dispatch[GetKey(instance)].GetInstanceProcAddr(instance, pName);}
}